
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Pokemon
 * 
 */
export type Pokemon = $Result.DefaultSelection<Prisma.$PokemonPayload>
/**
 * Model Ability
 * 
 */
export type Ability = $Result.DefaultSelection<Prisma.$AbilityPayload>
/**
 * Model PokemonAbility
 * 
 */
export type PokemonAbility = $Result.DefaultSelection<Prisma.$PokemonAbilityPayload>
/**
 * Model Nature
 * 
 */
export type Nature = $Result.DefaultSelection<Prisma.$NaturePayload>
/**
 * Model PokemonNature
 * 
 */
export type PokemonNature = $Result.DefaultSelection<Prisma.$PokemonNaturePayload>
/**
 * Model Stat
 * 
 */
export type Stat = $Result.DefaultSelection<Prisma.$StatPayload>
/**
 * Model PokemonStat
 * 
 */
export type PokemonStat = $Result.DefaultSelection<Prisma.$PokemonStatPayload>
/**
 * Model Type
 * 
 */
export type Type = $Result.DefaultSelection<Prisma.$TypePayload>
/**
 * Model TypeEffectiveness
 * 
 */
export type TypeEffectiveness = $Result.DefaultSelection<Prisma.$TypeEffectivenessPayload>
/**
 * Model PokemonType
 * 
 */
export type PokemonType = $Result.DefaultSelection<Prisma.$PokemonTypePayload>
/**
 * Model EggGroup
 * 
 */
export type EggGroup = $Result.DefaultSelection<Prisma.$EggGroupPayload>
/**
 * Model PokemonEggGroup
 * 
 */
export type PokemonEggGroup = $Result.DefaultSelection<Prisma.$PokemonEggGroupPayload>
/**
 * Model Region
 * 
 */
export type Region = $Result.DefaultSelection<Prisma.$RegionPayload>
/**
 * Model Generation
 * 
 */
export type Generation = $Result.DefaultSelection<Prisma.$GenerationPayload>
/**
 * Model VersionGroup
 * 
 */
export type VersionGroup = $Result.DefaultSelection<Prisma.$VersionGroupPayload>
/**
 * Model VersionGroupRegion
 * 
 */
export type VersionGroupRegion = $Result.DefaultSelection<Prisma.$VersionGroupRegionPayload>
/**
 * Model Version
 * 
 */
export type Version = $Result.DefaultSelection<Prisma.$VersionPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model LocationArea
 * 
 */
export type LocationArea = $Result.DefaultSelection<Prisma.$LocationAreaPayload>
/**
 * Model EncounterMethod
 * 
 */
export type EncounterMethod = $Result.DefaultSelection<Prisma.$EncounterMethodPayload>
/**
 * Model EncounterSlot
 * 
 */
export type EncounterSlot = $Result.DefaultSelection<Prisma.$EncounterSlotPayload>
/**
 * Model Encounter
 * 
 */
export type Encounter = $Result.DefaultSelection<Prisma.$EncounterPayload>
/**
 * Model EncounterCondition
 * 
 */
export type EncounterCondition = $Result.DefaultSelection<Prisma.$EncounterConditionPayload>
/**
 * Model EncounterConditionValue
 * 
 */
export type EncounterConditionValue = $Result.DefaultSelection<Prisma.$EncounterConditionValuePayload>
/**
 * Model EncounterConditionValueMap
 * 
 */
export type EncounterConditionValueMap = $Result.DefaultSelection<Prisma.$EncounterConditionValueMapPayload>
/**
 * Model LocationAreaEncounterRate
 * 
 */
export type LocationAreaEncounterRate = $Result.DefaultSelection<Prisma.$LocationAreaEncounterRatePayload>
/**
 * Model MoveDamageClass
 * 
 */
export type MoveDamageClass = $Result.DefaultSelection<Prisma.$MoveDamageClassPayload>
/**
 * Model MoveEffect
 * 
 */
export type MoveEffect = $Result.DefaultSelection<Prisma.$MoveEffectPayload>
/**
 * Model MoveMethod
 * 
 */
export type MoveMethod = $Result.DefaultSelection<Prisma.$MoveMethodPayload>
/**
 * Model Move
 * 
 */
export type Move = $Result.DefaultSelection<Prisma.$MovePayload>
/**
 * Model PokemonMove
 * 
 */
export type PokemonMove = $Result.DefaultSelection<Prisma.$PokemonMovePayload>
/**
 * Model Pokedex
 * 
 */
export type Pokedex = $Result.DefaultSelection<Prisma.$PokedexPayload>
/**
 * Model PokedexVersionGroup
 * 
 */
export type PokedexVersionGroup = $Result.DefaultSelection<Prisma.$PokedexVersionGroupPayload>
/**
 * Model PokemonDexNumber
 * 
 */
export type PokemonDexNumber = $Result.DefaultSelection<Prisma.$PokemonDexNumberPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pokemon`: Exposes CRUD operations for the **Pokemon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pokemon
    * const pokemon = await prisma.pokemon.findMany()
    * ```
    */
  get pokemon(): Prisma.PokemonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ability`: Exposes CRUD operations for the **Ability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Abilities
    * const abilities = await prisma.ability.findMany()
    * ```
    */
  get ability(): Prisma.AbilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pokemonAbility`: Exposes CRUD operations for the **PokemonAbility** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PokemonAbilities
    * const pokemonAbilities = await prisma.pokemonAbility.findMany()
    * ```
    */
  get pokemonAbility(): Prisma.PokemonAbilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nature`: Exposes CRUD operations for the **Nature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Natures
    * const natures = await prisma.nature.findMany()
    * ```
    */
  get nature(): Prisma.NatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pokemonNature`: Exposes CRUD operations for the **PokemonNature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PokemonNatures
    * const pokemonNatures = await prisma.pokemonNature.findMany()
    * ```
    */
  get pokemonNature(): Prisma.PokemonNatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stat`: Exposes CRUD operations for the **Stat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stats
    * const stats = await prisma.stat.findMany()
    * ```
    */
  get stat(): Prisma.StatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pokemonStat`: Exposes CRUD operations for the **PokemonStat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PokemonStats
    * const pokemonStats = await prisma.pokemonStat.findMany()
    * ```
    */
  get pokemonStat(): Prisma.PokemonStatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.type`: Exposes CRUD operations for the **Type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Types
    * const types = await prisma.type.findMany()
    * ```
    */
  get type(): Prisma.TypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.typeEffectiveness`: Exposes CRUD operations for the **TypeEffectiveness** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TypeEffectivenesses
    * const typeEffectivenesses = await prisma.typeEffectiveness.findMany()
    * ```
    */
  get typeEffectiveness(): Prisma.TypeEffectivenessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pokemonType`: Exposes CRUD operations for the **PokemonType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PokemonTypes
    * const pokemonTypes = await prisma.pokemonType.findMany()
    * ```
    */
  get pokemonType(): Prisma.PokemonTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eggGroup`: Exposes CRUD operations for the **EggGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EggGroups
    * const eggGroups = await prisma.eggGroup.findMany()
    * ```
    */
  get eggGroup(): Prisma.EggGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pokemonEggGroup`: Exposes CRUD operations for the **PokemonEggGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PokemonEggGroups
    * const pokemonEggGroups = await prisma.pokemonEggGroup.findMany()
    * ```
    */
  get pokemonEggGroup(): Prisma.PokemonEggGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.region`: Exposes CRUD operations for the **Region** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.region.findMany()
    * ```
    */
  get region(): Prisma.RegionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.generation`: Exposes CRUD operations for the **Generation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Generations
    * const generations = await prisma.generation.findMany()
    * ```
    */
  get generation(): Prisma.GenerationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.versionGroup`: Exposes CRUD operations for the **VersionGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VersionGroups
    * const versionGroups = await prisma.versionGroup.findMany()
    * ```
    */
  get versionGroup(): Prisma.VersionGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.versionGroupRegion`: Exposes CRUD operations for the **VersionGroupRegion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VersionGroupRegions
    * const versionGroupRegions = await prisma.versionGroupRegion.findMany()
    * ```
    */
  get versionGroupRegion(): Prisma.VersionGroupRegionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.version`: Exposes CRUD operations for the **Version** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Versions
    * const versions = await prisma.version.findMany()
    * ```
    */
  get version(): Prisma.VersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.locationArea`: Exposes CRUD operations for the **LocationArea** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocationAreas
    * const locationAreas = await prisma.locationArea.findMany()
    * ```
    */
  get locationArea(): Prisma.LocationAreaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.encounterMethod`: Exposes CRUD operations for the **EncounterMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncounterMethods
    * const encounterMethods = await prisma.encounterMethod.findMany()
    * ```
    */
  get encounterMethod(): Prisma.EncounterMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.encounterSlot`: Exposes CRUD operations for the **EncounterSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncounterSlots
    * const encounterSlots = await prisma.encounterSlot.findMany()
    * ```
    */
  get encounterSlot(): Prisma.EncounterSlotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.encounter`: Exposes CRUD operations for the **Encounter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Encounters
    * const encounters = await prisma.encounter.findMany()
    * ```
    */
  get encounter(): Prisma.EncounterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.encounterCondition`: Exposes CRUD operations for the **EncounterCondition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncounterConditions
    * const encounterConditions = await prisma.encounterCondition.findMany()
    * ```
    */
  get encounterCondition(): Prisma.EncounterConditionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.encounterConditionValue`: Exposes CRUD operations for the **EncounterConditionValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncounterConditionValues
    * const encounterConditionValues = await prisma.encounterConditionValue.findMany()
    * ```
    */
  get encounterConditionValue(): Prisma.EncounterConditionValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.encounterConditionValueMap`: Exposes CRUD operations for the **EncounterConditionValueMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncounterConditionValueMaps
    * const encounterConditionValueMaps = await prisma.encounterConditionValueMap.findMany()
    * ```
    */
  get encounterConditionValueMap(): Prisma.EncounterConditionValueMapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.locationAreaEncounterRate`: Exposes CRUD operations for the **LocationAreaEncounterRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocationAreaEncounterRates
    * const locationAreaEncounterRates = await prisma.locationAreaEncounterRate.findMany()
    * ```
    */
  get locationAreaEncounterRate(): Prisma.LocationAreaEncounterRateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moveDamageClass`: Exposes CRUD operations for the **MoveDamageClass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MoveDamageClasses
    * const moveDamageClasses = await prisma.moveDamageClass.findMany()
    * ```
    */
  get moveDamageClass(): Prisma.MoveDamageClassDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moveEffect`: Exposes CRUD operations for the **MoveEffect** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MoveEffects
    * const moveEffects = await prisma.moveEffect.findMany()
    * ```
    */
  get moveEffect(): Prisma.MoveEffectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moveMethod`: Exposes CRUD operations for the **MoveMethod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MoveMethods
    * const moveMethods = await prisma.moveMethod.findMany()
    * ```
    */
  get moveMethod(): Prisma.MoveMethodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.move`: Exposes CRUD operations for the **Move** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Moves
    * const moves = await prisma.move.findMany()
    * ```
    */
  get move(): Prisma.MoveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pokemonMove`: Exposes CRUD operations for the **PokemonMove** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PokemonMoves
    * const pokemonMoves = await prisma.pokemonMove.findMany()
    * ```
    */
  get pokemonMove(): Prisma.PokemonMoveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pokedex`: Exposes CRUD operations for the **Pokedex** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pokedexes
    * const pokedexes = await prisma.pokedex.findMany()
    * ```
    */
  get pokedex(): Prisma.PokedexDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pokedexVersionGroup`: Exposes CRUD operations for the **PokedexVersionGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PokedexVersionGroups
    * const pokedexVersionGroups = await prisma.pokedexVersionGroup.findMany()
    * ```
    */
  get pokedexVersionGroup(): Prisma.PokedexVersionGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pokemonDexNumber`: Exposes CRUD operations for the **PokemonDexNumber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PokemonDexNumbers
    * const pokemonDexNumbers = await prisma.pokemonDexNumber.findMany()
    * ```
    */
  get pokemonDexNumber(): Prisma.PokemonDexNumberDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Pokemon: 'Pokemon',
    Ability: 'Ability',
    PokemonAbility: 'PokemonAbility',
    Nature: 'Nature',
    PokemonNature: 'PokemonNature',
    Stat: 'Stat',
    PokemonStat: 'PokemonStat',
    Type: 'Type',
    TypeEffectiveness: 'TypeEffectiveness',
    PokemonType: 'PokemonType',
    EggGroup: 'EggGroup',
    PokemonEggGroup: 'PokemonEggGroup',
    Region: 'Region',
    Generation: 'Generation',
    VersionGroup: 'VersionGroup',
    VersionGroupRegion: 'VersionGroupRegion',
    Version: 'Version',
    Location: 'Location',
    LocationArea: 'LocationArea',
    EncounterMethod: 'EncounterMethod',
    EncounterSlot: 'EncounterSlot',
    Encounter: 'Encounter',
    EncounterCondition: 'EncounterCondition',
    EncounterConditionValue: 'EncounterConditionValue',
    EncounterConditionValueMap: 'EncounterConditionValueMap',
    LocationAreaEncounterRate: 'LocationAreaEncounterRate',
    MoveDamageClass: 'MoveDamageClass',
    MoveEffect: 'MoveEffect',
    MoveMethod: 'MoveMethod',
    Move: 'Move',
    PokemonMove: 'PokemonMove',
    Pokedex: 'Pokedex',
    PokedexVersionGroup: 'PokedexVersionGroup',
    PokemonDexNumber: 'PokemonDexNumber'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "pokemon" | "ability" | "pokemonAbility" | "nature" | "pokemonNature" | "stat" | "pokemonStat" | "type" | "typeEffectiveness" | "pokemonType" | "eggGroup" | "pokemonEggGroup" | "region" | "generation" | "versionGroup" | "versionGroupRegion" | "version" | "location" | "locationArea" | "encounterMethod" | "encounterSlot" | "encounter" | "encounterCondition" | "encounterConditionValue" | "encounterConditionValueMap" | "locationAreaEncounterRate" | "moveDamageClass" | "moveEffect" | "moveMethod" | "move" | "pokemonMove" | "pokedex" | "pokedexVersionGroup" | "pokemonDexNumber"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Pokemon: {
        payload: Prisma.$PokemonPayload<ExtArgs>
        fields: Prisma.PokemonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PokemonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PokemonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonPayload>
          }
          findFirst: {
            args: Prisma.PokemonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PokemonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonPayload>
          }
          findMany: {
            args: Prisma.PokemonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonPayload>[]
          }
          create: {
            args: Prisma.PokemonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonPayload>
          }
          createMany: {
            args: Prisma.PokemonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PokemonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonPayload>[]
          }
          delete: {
            args: Prisma.PokemonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonPayload>
          }
          update: {
            args: Prisma.PokemonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonPayload>
          }
          deleteMany: {
            args: Prisma.PokemonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PokemonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PokemonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonPayload>[]
          }
          upsert: {
            args: Prisma.PokemonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonPayload>
          }
          aggregate: {
            args: Prisma.PokemonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePokemon>
          }
          groupBy: {
            args: Prisma.PokemonGroupByArgs<ExtArgs>
            result: $Utils.Optional<PokemonGroupByOutputType>[]
          }
          count: {
            args: Prisma.PokemonCountArgs<ExtArgs>
            result: $Utils.Optional<PokemonCountAggregateOutputType> | number
          }
        }
      }
      Ability: {
        payload: Prisma.$AbilityPayload<ExtArgs>
        fields: Prisma.AbilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AbilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AbilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>
          }
          findFirst: {
            args: Prisma.AbilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AbilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>
          }
          findMany: {
            args: Prisma.AbilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>[]
          }
          create: {
            args: Prisma.AbilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>
          }
          createMany: {
            args: Prisma.AbilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AbilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>[]
          }
          delete: {
            args: Prisma.AbilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>
          }
          update: {
            args: Prisma.AbilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>
          }
          deleteMany: {
            args: Prisma.AbilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AbilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AbilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>[]
          }
          upsert: {
            args: Prisma.AbilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbilityPayload>
          }
          aggregate: {
            args: Prisma.AbilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAbility>
          }
          groupBy: {
            args: Prisma.AbilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AbilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AbilityCountArgs<ExtArgs>
            result: $Utils.Optional<AbilityCountAggregateOutputType> | number
          }
        }
      }
      PokemonAbility: {
        payload: Prisma.$PokemonAbilityPayload<ExtArgs>
        fields: Prisma.PokemonAbilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PokemonAbilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonAbilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PokemonAbilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonAbilityPayload>
          }
          findFirst: {
            args: Prisma.PokemonAbilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonAbilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PokemonAbilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonAbilityPayload>
          }
          findMany: {
            args: Prisma.PokemonAbilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonAbilityPayload>[]
          }
          create: {
            args: Prisma.PokemonAbilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonAbilityPayload>
          }
          createMany: {
            args: Prisma.PokemonAbilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PokemonAbilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonAbilityPayload>[]
          }
          delete: {
            args: Prisma.PokemonAbilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonAbilityPayload>
          }
          update: {
            args: Prisma.PokemonAbilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonAbilityPayload>
          }
          deleteMany: {
            args: Prisma.PokemonAbilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PokemonAbilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PokemonAbilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonAbilityPayload>[]
          }
          upsert: {
            args: Prisma.PokemonAbilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonAbilityPayload>
          }
          aggregate: {
            args: Prisma.PokemonAbilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePokemonAbility>
          }
          groupBy: {
            args: Prisma.PokemonAbilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<PokemonAbilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.PokemonAbilityCountArgs<ExtArgs>
            result: $Utils.Optional<PokemonAbilityCountAggregateOutputType> | number
          }
        }
      }
      Nature: {
        payload: Prisma.$NaturePayload<ExtArgs>
        fields: Prisma.NatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NaturePayload>
          }
          findFirst: {
            args: Prisma.NatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NaturePayload>
          }
          findMany: {
            args: Prisma.NatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NaturePayload>[]
          }
          create: {
            args: Prisma.NatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NaturePayload>
          }
          createMany: {
            args: Prisma.NatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NaturePayload>[]
          }
          delete: {
            args: Prisma.NatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NaturePayload>
          }
          update: {
            args: Prisma.NatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NaturePayload>
          }
          deleteMany: {
            args: Prisma.NatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NaturePayload>[]
          }
          upsert: {
            args: Prisma.NatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NaturePayload>
          }
          aggregate: {
            args: Prisma.NatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNature>
          }
          groupBy: {
            args: Prisma.NatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<NatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.NatureCountArgs<ExtArgs>
            result: $Utils.Optional<NatureCountAggregateOutputType> | number
          }
        }
      }
      PokemonNature: {
        payload: Prisma.$PokemonNaturePayload<ExtArgs>
        fields: Prisma.PokemonNatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PokemonNatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonNaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PokemonNatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonNaturePayload>
          }
          findFirst: {
            args: Prisma.PokemonNatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonNaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PokemonNatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonNaturePayload>
          }
          findMany: {
            args: Prisma.PokemonNatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonNaturePayload>[]
          }
          create: {
            args: Prisma.PokemonNatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonNaturePayload>
          }
          createMany: {
            args: Prisma.PokemonNatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PokemonNatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonNaturePayload>[]
          }
          delete: {
            args: Prisma.PokemonNatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonNaturePayload>
          }
          update: {
            args: Prisma.PokemonNatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonNaturePayload>
          }
          deleteMany: {
            args: Prisma.PokemonNatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PokemonNatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PokemonNatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonNaturePayload>[]
          }
          upsert: {
            args: Prisma.PokemonNatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonNaturePayload>
          }
          aggregate: {
            args: Prisma.PokemonNatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePokemonNature>
          }
          groupBy: {
            args: Prisma.PokemonNatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<PokemonNatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.PokemonNatureCountArgs<ExtArgs>
            result: $Utils.Optional<PokemonNatureCountAggregateOutputType> | number
          }
        }
      }
      Stat: {
        payload: Prisma.$StatPayload<ExtArgs>
        fields: Prisma.StatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>
          }
          findFirst: {
            args: Prisma.StatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>
          }
          findMany: {
            args: Prisma.StatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>[]
          }
          create: {
            args: Prisma.StatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>
          }
          createMany: {
            args: Prisma.StatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>[]
          }
          delete: {
            args: Prisma.StatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>
          }
          update: {
            args: Prisma.StatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>
          }
          deleteMany: {
            args: Prisma.StatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>[]
          }
          upsert: {
            args: Prisma.StatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatPayload>
          }
          aggregate: {
            args: Prisma.StatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStat>
          }
          groupBy: {
            args: Prisma.StatGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatCountArgs<ExtArgs>
            result: $Utils.Optional<StatCountAggregateOutputType> | number
          }
        }
      }
      PokemonStat: {
        payload: Prisma.$PokemonStatPayload<ExtArgs>
        fields: Prisma.PokemonStatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PokemonStatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonStatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PokemonStatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonStatPayload>
          }
          findFirst: {
            args: Prisma.PokemonStatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonStatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PokemonStatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonStatPayload>
          }
          findMany: {
            args: Prisma.PokemonStatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonStatPayload>[]
          }
          create: {
            args: Prisma.PokemonStatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonStatPayload>
          }
          createMany: {
            args: Prisma.PokemonStatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PokemonStatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonStatPayload>[]
          }
          delete: {
            args: Prisma.PokemonStatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonStatPayload>
          }
          update: {
            args: Prisma.PokemonStatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonStatPayload>
          }
          deleteMany: {
            args: Prisma.PokemonStatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PokemonStatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PokemonStatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonStatPayload>[]
          }
          upsert: {
            args: Prisma.PokemonStatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonStatPayload>
          }
          aggregate: {
            args: Prisma.PokemonStatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePokemonStat>
          }
          groupBy: {
            args: Prisma.PokemonStatGroupByArgs<ExtArgs>
            result: $Utils.Optional<PokemonStatGroupByOutputType>[]
          }
          count: {
            args: Prisma.PokemonStatCountArgs<ExtArgs>
            result: $Utils.Optional<PokemonStatCountAggregateOutputType> | number
          }
        }
      }
      Type: {
        payload: Prisma.$TypePayload<ExtArgs>
        fields: Prisma.TypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          findFirst: {
            args: Prisma.TypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          findMany: {
            args: Prisma.TypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>[]
          }
          create: {
            args: Prisma.TypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          createMany: {
            args: Prisma.TypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>[]
          }
          delete: {
            args: Prisma.TypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          update: {
            args: Prisma.TypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          deleteMany: {
            args: Prisma.TypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>[]
          }
          upsert: {
            args: Prisma.TypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypePayload>
          }
          aggregate: {
            args: Prisma.TypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateType>
          }
          groupBy: {
            args: Prisma.TypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TypeCountArgs<ExtArgs>
            result: $Utils.Optional<TypeCountAggregateOutputType> | number
          }
        }
      }
      TypeEffectiveness: {
        payload: Prisma.$TypeEffectivenessPayload<ExtArgs>
        fields: Prisma.TypeEffectivenessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TypeEffectivenessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeEffectivenessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TypeEffectivenessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeEffectivenessPayload>
          }
          findFirst: {
            args: Prisma.TypeEffectivenessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeEffectivenessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TypeEffectivenessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeEffectivenessPayload>
          }
          findMany: {
            args: Prisma.TypeEffectivenessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeEffectivenessPayload>[]
          }
          create: {
            args: Prisma.TypeEffectivenessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeEffectivenessPayload>
          }
          createMany: {
            args: Prisma.TypeEffectivenessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TypeEffectivenessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeEffectivenessPayload>[]
          }
          delete: {
            args: Prisma.TypeEffectivenessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeEffectivenessPayload>
          }
          update: {
            args: Prisma.TypeEffectivenessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeEffectivenessPayload>
          }
          deleteMany: {
            args: Prisma.TypeEffectivenessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TypeEffectivenessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TypeEffectivenessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeEffectivenessPayload>[]
          }
          upsert: {
            args: Prisma.TypeEffectivenessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeEffectivenessPayload>
          }
          aggregate: {
            args: Prisma.TypeEffectivenessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTypeEffectiveness>
          }
          groupBy: {
            args: Prisma.TypeEffectivenessGroupByArgs<ExtArgs>
            result: $Utils.Optional<TypeEffectivenessGroupByOutputType>[]
          }
          count: {
            args: Prisma.TypeEffectivenessCountArgs<ExtArgs>
            result: $Utils.Optional<TypeEffectivenessCountAggregateOutputType> | number
          }
        }
      }
      PokemonType: {
        payload: Prisma.$PokemonTypePayload<ExtArgs>
        fields: Prisma.PokemonTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PokemonTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PokemonTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonTypePayload>
          }
          findFirst: {
            args: Prisma.PokemonTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PokemonTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonTypePayload>
          }
          findMany: {
            args: Prisma.PokemonTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonTypePayload>[]
          }
          create: {
            args: Prisma.PokemonTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonTypePayload>
          }
          createMany: {
            args: Prisma.PokemonTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PokemonTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonTypePayload>[]
          }
          delete: {
            args: Prisma.PokemonTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonTypePayload>
          }
          update: {
            args: Prisma.PokemonTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonTypePayload>
          }
          deleteMany: {
            args: Prisma.PokemonTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PokemonTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PokemonTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonTypePayload>[]
          }
          upsert: {
            args: Prisma.PokemonTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonTypePayload>
          }
          aggregate: {
            args: Prisma.PokemonTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePokemonType>
          }
          groupBy: {
            args: Prisma.PokemonTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PokemonTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PokemonTypeCountArgs<ExtArgs>
            result: $Utils.Optional<PokemonTypeCountAggregateOutputType> | number
          }
        }
      }
      EggGroup: {
        payload: Prisma.$EggGroupPayload<ExtArgs>
        fields: Prisma.EggGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EggGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EggGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggGroupPayload>
          }
          findFirst: {
            args: Prisma.EggGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EggGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggGroupPayload>
          }
          findMany: {
            args: Prisma.EggGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggGroupPayload>[]
          }
          create: {
            args: Prisma.EggGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggGroupPayload>
          }
          createMany: {
            args: Prisma.EggGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EggGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggGroupPayload>[]
          }
          delete: {
            args: Prisma.EggGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggGroupPayload>
          }
          update: {
            args: Prisma.EggGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggGroupPayload>
          }
          deleteMany: {
            args: Prisma.EggGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EggGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EggGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggGroupPayload>[]
          }
          upsert: {
            args: Prisma.EggGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EggGroupPayload>
          }
          aggregate: {
            args: Prisma.EggGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEggGroup>
          }
          groupBy: {
            args: Prisma.EggGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<EggGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.EggGroupCountArgs<ExtArgs>
            result: $Utils.Optional<EggGroupCountAggregateOutputType> | number
          }
        }
      }
      PokemonEggGroup: {
        payload: Prisma.$PokemonEggGroupPayload<ExtArgs>
        fields: Prisma.PokemonEggGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PokemonEggGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonEggGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PokemonEggGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonEggGroupPayload>
          }
          findFirst: {
            args: Prisma.PokemonEggGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonEggGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PokemonEggGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonEggGroupPayload>
          }
          findMany: {
            args: Prisma.PokemonEggGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonEggGroupPayload>[]
          }
          create: {
            args: Prisma.PokemonEggGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonEggGroupPayload>
          }
          createMany: {
            args: Prisma.PokemonEggGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PokemonEggGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonEggGroupPayload>[]
          }
          delete: {
            args: Prisma.PokemonEggGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonEggGroupPayload>
          }
          update: {
            args: Prisma.PokemonEggGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonEggGroupPayload>
          }
          deleteMany: {
            args: Prisma.PokemonEggGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PokemonEggGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PokemonEggGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonEggGroupPayload>[]
          }
          upsert: {
            args: Prisma.PokemonEggGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonEggGroupPayload>
          }
          aggregate: {
            args: Prisma.PokemonEggGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePokemonEggGroup>
          }
          groupBy: {
            args: Prisma.PokemonEggGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<PokemonEggGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.PokemonEggGroupCountArgs<ExtArgs>
            result: $Utils.Optional<PokemonEggGroupCountAggregateOutputType> | number
          }
        }
      }
      Region: {
        payload: Prisma.$RegionPayload<ExtArgs>
        fields: Prisma.RegionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findFirst: {
            args: Prisma.RegionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findMany: {
            args: Prisma.RegionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          create: {
            args: Prisma.RegionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          createMany: {
            args: Prisma.RegionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          delete: {
            args: Prisma.RegionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          update: {
            args: Prisma.RegionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          deleteMany: {
            args: Prisma.RegionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RegionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          upsert: {
            args: Prisma.RegionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          aggregate: {
            args: Prisma.RegionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegion>
          }
          groupBy: {
            args: Prisma.RegionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionCountArgs<ExtArgs>
            result: $Utils.Optional<RegionCountAggregateOutputType> | number
          }
        }
      }
      Generation: {
        payload: Prisma.$GenerationPayload<ExtArgs>
        fields: Prisma.GenerationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenerationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenerationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenerationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenerationPayload>
          }
          findFirst: {
            args: Prisma.GenerationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenerationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenerationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenerationPayload>
          }
          findMany: {
            args: Prisma.GenerationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenerationPayload>[]
          }
          create: {
            args: Prisma.GenerationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenerationPayload>
          }
          createMany: {
            args: Prisma.GenerationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GenerationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenerationPayload>[]
          }
          delete: {
            args: Prisma.GenerationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenerationPayload>
          }
          update: {
            args: Prisma.GenerationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenerationPayload>
          }
          deleteMany: {
            args: Prisma.GenerationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenerationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GenerationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenerationPayload>[]
          }
          upsert: {
            args: Prisma.GenerationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenerationPayload>
          }
          aggregate: {
            args: Prisma.GenerationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeneration>
          }
          groupBy: {
            args: Prisma.GenerationGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenerationGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenerationCountArgs<ExtArgs>
            result: $Utils.Optional<GenerationCountAggregateOutputType> | number
          }
        }
      }
      VersionGroup: {
        payload: Prisma.$VersionGroupPayload<ExtArgs>
        fields: Prisma.VersionGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VersionGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VersionGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupPayload>
          }
          findFirst: {
            args: Prisma.VersionGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VersionGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupPayload>
          }
          findMany: {
            args: Prisma.VersionGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupPayload>[]
          }
          create: {
            args: Prisma.VersionGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupPayload>
          }
          createMany: {
            args: Prisma.VersionGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VersionGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupPayload>[]
          }
          delete: {
            args: Prisma.VersionGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupPayload>
          }
          update: {
            args: Prisma.VersionGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupPayload>
          }
          deleteMany: {
            args: Prisma.VersionGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VersionGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VersionGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupPayload>[]
          }
          upsert: {
            args: Prisma.VersionGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupPayload>
          }
          aggregate: {
            args: Prisma.VersionGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVersionGroup>
          }
          groupBy: {
            args: Prisma.VersionGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<VersionGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.VersionGroupCountArgs<ExtArgs>
            result: $Utils.Optional<VersionGroupCountAggregateOutputType> | number
          }
        }
      }
      VersionGroupRegion: {
        payload: Prisma.$VersionGroupRegionPayload<ExtArgs>
        fields: Prisma.VersionGroupRegionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VersionGroupRegionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupRegionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VersionGroupRegionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupRegionPayload>
          }
          findFirst: {
            args: Prisma.VersionGroupRegionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupRegionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VersionGroupRegionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupRegionPayload>
          }
          findMany: {
            args: Prisma.VersionGroupRegionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupRegionPayload>[]
          }
          create: {
            args: Prisma.VersionGroupRegionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupRegionPayload>
          }
          createMany: {
            args: Prisma.VersionGroupRegionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VersionGroupRegionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupRegionPayload>[]
          }
          delete: {
            args: Prisma.VersionGroupRegionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupRegionPayload>
          }
          update: {
            args: Prisma.VersionGroupRegionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupRegionPayload>
          }
          deleteMany: {
            args: Prisma.VersionGroupRegionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VersionGroupRegionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VersionGroupRegionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupRegionPayload>[]
          }
          upsert: {
            args: Prisma.VersionGroupRegionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionGroupRegionPayload>
          }
          aggregate: {
            args: Prisma.VersionGroupRegionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVersionGroupRegion>
          }
          groupBy: {
            args: Prisma.VersionGroupRegionGroupByArgs<ExtArgs>
            result: $Utils.Optional<VersionGroupRegionGroupByOutputType>[]
          }
          count: {
            args: Prisma.VersionGroupRegionCountArgs<ExtArgs>
            result: $Utils.Optional<VersionGroupRegionCountAggregateOutputType> | number
          }
        }
      }
      Version: {
        payload: Prisma.$VersionPayload<ExtArgs>
        fields: Prisma.VersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          findFirst: {
            args: Prisma.VersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          findMany: {
            args: Prisma.VersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>[]
          }
          create: {
            args: Prisma.VersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          createMany: {
            args: Prisma.VersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>[]
          }
          delete: {
            args: Prisma.VersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          update: {
            args: Prisma.VersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          deleteMany: {
            args: Prisma.VersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>[]
          }
          upsert: {
            args: Prisma.VersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          aggregate: {
            args: Prisma.VersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVersion>
          }
          groupBy: {
            args: Prisma.VersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<VersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.VersionCountArgs<ExtArgs>
            result: $Utils.Optional<VersionCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      LocationArea: {
        payload: Prisma.$LocationAreaPayload<ExtArgs>
        fields: Prisma.LocationAreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationAreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationAreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaPayload>
          }
          findFirst: {
            args: Prisma.LocationAreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationAreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaPayload>
          }
          findMany: {
            args: Prisma.LocationAreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaPayload>[]
          }
          create: {
            args: Prisma.LocationAreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaPayload>
          }
          createMany: {
            args: Prisma.LocationAreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationAreaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaPayload>[]
          }
          delete: {
            args: Prisma.LocationAreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaPayload>
          }
          update: {
            args: Prisma.LocationAreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaPayload>
          }
          deleteMany: {
            args: Prisma.LocationAreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationAreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationAreaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaPayload>[]
          }
          upsert: {
            args: Prisma.LocationAreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaPayload>
          }
          aggregate: {
            args: Prisma.LocationAreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocationArea>
          }
          groupBy: {
            args: Prisma.LocationAreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationAreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationAreaCountArgs<ExtArgs>
            result: $Utils.Optional<LocationAreaCountAggregateOutputType> | number
          }
        }
      }
      EncounterMethod: {
        payload: Prisma.$EncounterMethodPayload<ExtArgs>
        fields: Prisma.EncounterMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterMethodPayload>
          }
          findFirst: {
            args: Prisma.EncounterMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterMethodPayload>
          }
          findMany: {
            args: Prisma.EncounterMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterMethodPayload>[]
          }
          create: {
            args: Prisma.EncounterMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterMethodPayload>
          }
          createMany: {
            args: Prisma.EncounterMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterMethodPayload>[]
          }
          delete: {
            args: Prisma.EncounterMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterMethodPayload>
          }
          update: {
            args: Prisma.EncounterMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterMethodPayload>
          }
          deleteMany: {
            args: Prisma.EncounterMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EncounterMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterMethodPayload>[]
          }
          upsert: {
            args: Prisma.EncounterMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterMethodPayload>
          }
          aggregate: {
            args: Prisma.EncounterMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounterMethod>
          }
          groupBy: {
            args: Prisma.EncounterMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterMethodCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterMethodCountAggregateOutputType> | number
          }
        }
      }
      EncounterSlot: {
        payload: Prisma.$EncounterSlotPayload<ExtArgs>
        fields: Prisma.EncounterSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSlotPayload>
          }
          findFirst: {
            args: Prisma.EncounterSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSlotPayload>
          }
          findMany: {
            args: Prisma.EncounterSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSlotPayload>[]
          }
          create: {
            args: Prisma.EncounterSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSlotPayload>
          }
          createMany: {
            args: Prisma.EncounterSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterSlotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSlotPayload>[]
          }
          delete: {
            args: Prisma.EncounterSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSlotPayload>
          }
          update: {
            args: Prisma.EncounterSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSlotPayload>
          }
          deleteMany: {
            args: Prisma.EncounterSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EncounterSlotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSlotPayload>[]
          }
          upsert: {
            args: Prisma.EncounterSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterSlotPayload>
          }
          aggregate: {
            args: Prisma.EncounterSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounterSlot>
          }
          groupBy: {
            args: Prisma.EncounterSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterSlotCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterSlotCountAggregateOutputType> | number
          }
        }
      }
      Encounter: {
        payload: Prisma.$EncounterPayload<ExtArgs>
        fields: Prisma.EncounterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findFirst: {
            args: Prisma.EncounterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          findMany: {
            args: Prisma.EncounterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          create: {
            args: Prisma.EncounterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          createMany: {
            args: Prisma.EncounterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          delete: {
            args: Prisma.EncounterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          update: {
            args: Prisma.EncounterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          deleteMany: {
            args: Prisma.EncounterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EncounterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>[]
          }
          upsert: {
            args: Prisma.EncounterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterPayload>
          }
          aggregate: {
            args: Prisma.EncounterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounter>
          }
          groupBy: {
            args: Prisma.EncounterGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterCountAggregateOutputType> | number
          }
        }
      }
      EncounterCondition: {
        payload: Prisma.$EncounterConditionPayload<ExtArgs>
        fields: Prisma.EncounterConditionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterConditionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterConditionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionPayload>
          }
          findFirst: {
            args: Prisma.EncounterConditionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterConditionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionPayload>
          }
          findMany: {
            args: Prisma.EncounterConditionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionPayload>[]
          }
          create: {
            args: Prisma.EncounterConditionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionPayload>
          }
          createMany: {
            args: Prisma.EncounterConditionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterConditionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionPayload>[]
          }
          delete: {
            args: Prisma.EncounterConditionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionPayload>
          }
          update: {
            args: Prisma.EncounterConditionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionPayload>
          }
          deleteMany: {
            args: Prisma.EncounterConditionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterConditionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EncounterConditionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionPayload>[]
          }
          upsert: {
            args: Prisma.EncounterConditionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionPayload>
          }
          aggregate: {
            args: Prisma.EncounterConditionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounterCondition>
          }
          groupBy: {
            args: Prisma.EncounterConditionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterConditionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterConditionCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterConditionCountAggregateOutputType> | number
          }
        }
      }
      EncounterConditionValue: {
        payload: Prisma.$EncounterConditionValuePayload<ExtArgs>
        fields: Prisma.EncounterConditionValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterConditionValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterConditionValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValuePayload>
          }
          findFirst: {
            args: Prisma.EncounterConditionValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterConditionValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValuePayload>
          }
          findMany: {
            args: Prisma.EncounterConditionValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValuePayload>[]
          }
          create: {
            args: Prisma.EncounterConditionValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValuePayload>
          }
          createMany: {
            args: Prisma.EncounterConditionValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterConditionValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValuePayload>[]
          }
          delete: {
            args: Prisma.EncounterConditionValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValuePayload>
          }
          update: {
            args: Prisma.EncounterConditionValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValuePayload>
          }
          deleteMany: {
            args: Prisma.EncounterConditionValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterConditionValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EncounterConditionValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValuePayload>[]
          }
          upsert: {
            args: Prisma.EncounterConditionValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValuePayload>
          }
          aggregate: {
            args: Prisma.EncounterConditionValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounterConditionValue>
          }
          groupBy: {
            args: Prisma.EncounterConditionValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterConditionValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterConditionValueCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterConditionValueCountAggregateOutputType> | number
          }
        }
      }
      EncounterConditionValueMap: {
        payload: Prisma.$EncounterConditionValueMapPayload<ExtArgs>
        fields: Prisma.EncounterConditionValueMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncounterConditionValueMapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValueMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncounterConditionValueMapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValueMapPayload>
          }
          findFirst: {
            args: Prisma.EncounterConditionValueMapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValueMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncounterConditionValueMapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValueMapPayload>
          }
          findMany: {
            args: Prisma.EncounterConditionValueMapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValueMapPayload>[]
          }
          create: {
            args: Prisma.EncounterConditionValueMapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValueMapPayload>
          }
          createMany: {
            args: Prisma.EncounterConditionValueMapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncounterConditionValueMapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValueMapPayload>[]
          }
          delete: {
            args: Prisma.EncounterConditionValueMapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValueMapPayload>
          }
          update: {
            args: Prisma.EncounterConditionValueMapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValueMapPayload>
          }
          deleteMany: {
            args: Prisma.EncounterConditionValueMapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncounterConditionValueMapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EncounterConditionValueMapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValueMapPayload>[]
          }
          upsert: {
            args: Prisma.EncounterConditionValueMapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncounterConditionValueMapPayload>
          }
          aggregate: {
            args: Prisma.EncounterConditionValueMapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncounterConditionValueMap>
          }
          groupBy: {
            args: Prisma.EncounterConditionValueMapGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncounterConditionValueMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncounterConditionValueMapCountArgs<ExtArgs>
            result: $Utils.Optional<EncounterConditionValueMapCountAggregateOutputType> | number
          }
        }
      }
      LocationAreaEncounterRate: {
        payload: Prisma.$LocationAreaEncounterRatePayload<ExtArgs>
        fields: Prisma.LocationAreaEncounterRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationAreaEncounterRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaEncounterRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationAreaEncounterRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaEncounterRatePayload>
          }
          findFirst: {
            args: Prisma.LocationAreaEncounterRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaEncounterRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationAreaEncounterRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaEncounterRatePayload>
          }
          findMany: {
            args: Prisma.LocationAreaEncounterRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaEncounterRatePayload>[]
          }
          create: {
            args: Prisma.LocationAreaEncounterRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaEncounterRatePayload>
          }
          createMany: {
            args: Prisma.LocationAreaEncounterRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationAreaEncounterRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaEncounterRatePayload>[]
          }
          delete: {
            args: Prisma.LocationAreaEncounterRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaEncounterRatePayload>
          }
          update: {
            args: Prisma.LocationAreaEncounterRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaEncounterRatePayload>
          }
          deleteMany: {
            args: Prisma.LocationAreaEncounterRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationAreaEncounterRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationAreaEncounterRateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaEncounterRatePayload>[]
          }
          upsert: {
            args: Prisma.LocationAreaEncounterRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAreaEncounterRatePayload>
          }
          aggregate: {
            args: Prisma.LocationAreaEncounterRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocationAreaEncounterRate>
          }
          groupBy: {
            args: Prisma.LocationAreaEncounterRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationAreaEncounterRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationAreaEncounterRateCountArgs<ExtArgs>
            result: $Utils.Optional<LocationAreaEncounterRateCountAggregateOutputType> | number
          }
        }
      }
      MoveDamageClass: {
        payload: Prisma.$MoveDamageClassPayload<ExtArgs>
        fields: Prisma.MoveDamageClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MoveDamageClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveDamageClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MoveDamageClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveDamageClassPayload>
          }
          findFirst: {
            args: Prisma.MoveDamageClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveDamageClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MoveDamageClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveDamageClassPayload>
          }
          findMany: {
            args: Prisma.MoveDamageClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveDamageClassPayload>[]
          }
          create: {
            args: Prisma.MoveDamageClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveDamageClassPayload>
          }
          createMany: {
            args: Prisma.MoveDamageClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MoveDamageClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveDamageClassPayload>[]
          }
          delete: {
            args: Prisma.MoveDamageClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveDamageClassPayload>
          }
          update: {
            args: Prisma.MoveDamageClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveDamageClassPayload>
          }
          deleteMany: {
            args: Prisma.MoveDamageClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MoveDamageClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MoveDamageClassUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveDamageClassPayload>[]
          }
          upsert: {
            args: Prisma.MoveDamageClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveDamageClassPayload>
          }
          aggregate: {
            args: Prisma.MoveDamageClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMoveDamageClass>
          }
          groupBy: {
            args: Prisma.MoveDamageClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<MoveDamageClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.MoveDamageClassCountArgs<ExtArgs>
            result: $Utils.Optional<MoveDamageClassCountAggregateOutputType> | number
          }
        }
      }
      MoveEffect: {
        payload: Prisma.$MoveEffectPayload<ExtArgs>
        fields: Prisma.MoveEffectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MoveEffectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveEffectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MoveEffectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveEffectPayload>
          }
          findFirst: {
            args: Prisma.MoveEffectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveEffectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MoveEffectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveEffectPayload>
          }
          findMany: {
            args: Prisma.MoveEffectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveEffectPayload>[]
          }
          create: {
            args: Prisma.MoveEffectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveEffectPayload>
          }
          createMany: {
            args: Prisma.MoveEffectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MoveEffectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveEffectPayload>[]
          }
          delete: {
            args: Prisma.MoveEffectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveEffectPayload>
          }
          update: {
            args: Prisma.MoveEffectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveEffectPayload>
          }
          deleteMany: {
            args: Prisma.MoveEffectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MoveEffectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MoveEffectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveEffectPayload>[]
          }
          upsert: {
            args: Prisma.MoveEffectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveEffectPayload>
          }
          aggregate: {
            args: Prisma.MoveEffectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMoveEffect>
          }
          groupBy: {
            args: Prisma.MoveEffectGroupByArgs<ExtArgs>
            result: $Utils.Optional<MoveEffectGroupByOutputType>[]
          }
          count: {
            args: Prisma.MoveEffectCountArgs<ExtArgs>
            result: $Utils.Optional<MoveEffectCountAggregateOutputType> | number
          }
        }
      }
      MoveMethod: {
        payload: Prisma.$MoveMethodPayload<ExtArgs>
        fields: Prisma.MoveMethodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MoveMethodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveMethodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MoveMethodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveMethodPayload>
          }
          findFirst: {
            args: Prisma.MoveMethodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveMethodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MoveMethodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveMethodPayload>
          }
          findMany: {
            args: Prisma.MoveMethodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveMethodPayload>[]
          }
          create: {
            args: Prisma.MoveMethodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveMethodPayload>
          }
          createMany: {
            args: Prisma.MoveMethodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MoveMethodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveMethodPayload>[]
          }
          delete: {
            args: Prisma.MoveMethodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveMethodPayload>
          }
          update: {
            args: Prisma.MoveMethodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveMethodPayload>
          }
          deleteMany: {
            args: Prisma.MoveMethodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MoveMethodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MoveMethodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveMethodPayload>[]
          }
          upsert: {
            args: Prisma.MoveMethodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MoveMethodPayload>
          }
          aggregate: {
            args: Prisma.MoveMethodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMoveMethod>
          }
          groupBy: {
            args: Prisma.MoveMethodGroupByArgs<ExtArgs>
            result: $Utils.Optional<MoveMethodGroupByOutputType>[]
          }
          count: {
            args: Prisma.MoveMethodCountArgs<ExtArgs>
            result: $Utils.Optional<MoveMethodCountAggregateOutputType> | number
          }
        }
      }
      Move: {
        payload: Prisma.$MovePayload<ExtArgs>
        fields: Prisma.MoveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MoveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MoveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload>
          }
          findFirst: {
            args: Prisma.MoveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MoveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload>
          }
          findMany: {
            args: Prisma.MoveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload>[]
          }
          create: {
            args: Prisma.MoveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload>
          }
          createMany: {
            args: Prisma.MoveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MoveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload>[]
          }
          delete: {
            args: Prisma.MoveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload>
          }
          update: {
            args: Prisma.MoveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload>
          }
          deleteMany: {
            args: Prisma.MoveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MoveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MoveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload>[]
          }
          upsert: {
            args: Prisma.MoveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MovePayload>
          }
          aggregate: {
            args: Prisma.MoveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMove>
          }
          groupBy: {
            args: Prisma.MoveGroupByArgs<ExtArgs>
            result: $Utils.Optional<MoveGroupByOutputType>[]
          }
          count: {
            args: Prisma.MoveCountArgs<ExtArgs>
            result: $Utils.Optional<MoveCountAggregateOutputType> | number
          }
        }
      }
      PokemonMove: {
        payload: Prisma.$PokemonMovePayload<ExtArgs>
        fields: Prisma.PokemonMoveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PokemonMoveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonMovePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PokemonMoveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonMovePayload>
          }
          findFirst: {
            args: Prisma.PokemonMoveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonMovePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PokemonMoveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonMovePayload>
          }
          findMany: {
            args: Prisma.PokemonMoveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonMovePayload>[]
          }
          create: {
            args: Prisma.PokemonMoveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonMovePayload>
          }
          createMany: {
            args: Prisma.PokemonMoveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PokemonMoveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonMovePayload>[]
          }
          delete: {
            args: Prisma.PokemonMoveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonMovePayload>
          }
          update: {
            args: Prisma.PokemonMoveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonMovePayload>
          }
          deleteMany: {
            args: Prisma.PokemonMoveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PokemonMoveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PokemonMoveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonMovePayload>[]
          }
          upsert: {
            args: Prisma.PokemonMoveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonMovePayload>
          }
          aggregate: {
            args: Prisma.PokemonMoveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePokemonMove>
          }
          groupBy: {
            args: Prisma.PokemonMoveGroupByArgs<ExtArgs>
            result: $Utils.Optional<PokemonMoveGroupByOutputType>[]
          }
          count: {
            args: Prisma.PokemonMoveCountArgs<ExtArgs>
            result: $Utils.Optional<PokemonMoveCountAggregateOutputType> | number
          }
        }
      }
      Pokedex: {
        payload: Prisma.$PokedexPayload<ExtArgs>
        fields: Prisma.PokedexFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PokedexFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PokedexFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexPayload>
          }
          findFirst: {
            args: Prisma.PokedexFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PokedexFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexPayload>
          }
          findMany: {
            args: Prisma.PokedexFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexPayload>[]
          }
          create: {
            args: Prisma.PokedexCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexPayload>
          }
          createMany: {
            args: Prisma.PokedexCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PokedexCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexPayload>[]
          }
          delete: {
            args: Prisma.PokedexDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexPayload>
          }
          update: {
            args: Prisma.PokedexUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexPayload>
          }
          deleteMany: {
            args: Prisma.PokedexDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PokedexUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PokedexUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexPayload>[]
          }
          upsert: {
            args: Prisma.PokedexUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexPayload>
          }
          aggregate: {
            args: Prisma.PokedexAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePokedex>
          }
          groupBy: {
            args: Prisma.PokedexGroupByArgs<ExtArgs>
            result: $Utils.Optional<PokedexGroupByOutputType>[]
          }
          count: {
            args: Prisma.PokedexCountArgs<ExtArgs>
            result: $Utils.Optional<PokedexCountAggregateOutputType> | number
          }
        }
      }
      PokedexVersionGroup: {
        payload: Prisma.$PokedexVersionGroupPayload<ExtArgs>
        fields: Prisma.PokedexVersionGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PokedexVersionGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexVersionGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PokedexVersionGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexVersionGroupPayload>
          }
          findFirst: {
            args: Prisma.PokedexVersionGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexVersionGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PokedexVersionGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexVersionGroupPayload>
          }
          findMany: {
            args: Prisma.PokedexVersionGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexVersionGroupPayload>[]
          }
          create: {
            args: Prisma.PokedexVersionGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexVersionGroupPayload>
          }
          createMany: {
            args: Prisma.PokedexVersionGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PokedexVersionGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexVersionGroupPayload>[]
          }
          delete: {
            args: Prisma.PokedexVersionGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexVersionGroupPayload>
          }
          update: {
            args: Prisma.PokedexVersionGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexVersionGroupPayload>
          }
          deleteMany: {
            args: Prisma.PokedexVersionGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PokedexVersionGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PokedexVersionGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexVersionGroupPayload>[]
          }
          upsert: {
            args: Prisma.PokedexVersionGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokedexVersionGroupPayload>
          }
          aggregate: {
            args: Prisma.PokedexVersionGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePokedexVersionGroup>
          }
          groupBy: {
            args: Prisma.PokedexVersionGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<PokedexVersionGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.PokedexVersionGroupCountArgs<ExtArgs>
            result: $Utils.Optional<PokedexVersionGroupCountAggregateOutputType> | number
          }
        }
      }
      PokemonDexNumber: {
        payload: Prisma.$PokemonDexNumberPayload<ExtArgs>
        fields: Prisma.PokemonDexNumberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PokemonDexNumberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonDexNumberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PokemonDexNumberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonDexNumberPayload>
          }
          findFirst: {
            args: Prisma.PokemonDexNumberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonDexNumberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PokemonDexNumberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonDexNumberPayload>
          }
          findMany: {
            args: Prisma.PokemonDexNumberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonDexNumberPayload>[]
          }
          create: {
            args: Prisma.PokemonDexNumberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonDexNumberPayload>
          }
          createMany: {
            args: Prisma.PokemonDexNumberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PokemonDexNumberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonDexNumberPayload>[]
          }
          delete: {
            args: Prisma.PokemonDexNumberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonDexNumberPayload>
          }
          update: {
            args: Prisma.PokemonDexNumberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonDexNumberPayload>
          }
          deleteMany: {
            args: Prisma.PokemonDexNumberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PokemonDexNumberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PokemonDexNumberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonDexNumberPayload>[]
          }
          upsert: {
            args: Prisma.PokemonDexNumberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PokemonDexNumberPayload>
          }
          aggregate: {
            args: Prisma.PokemonDexNumberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePokemonDexNumber>
          }
          groupBy: {
            args: Prisma.PokemonDexNumberGroupByArgs<ExtArgs>
            result: $Utils.Optional<PokemonDexNumberGroupByOutputType>[]
          }
          count: {
            args: Prisma.PokemonDexNumberCountArgs<ExtArgs>
            result: $Utils.Optional<PokemonDexNumberCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    pokemon?: PokemonOmit
    ability?: AbilityOmit
    pokemonAbility?: PokemonAbilityOmit
    nature?: NatureOmit
    pokemonNature?: PokemonNatureOmit
    stat?: StatOmit
    pokemonStat?: PokemonStatOmit
    type?: TypeOmit
    typeEffectiveness?: TypeEffectivenessOmit
    pokemonType?: PokemonTypeOmit
    eggGroup?: EggGroupOmit
    pokemonEggGroup?: PokemonEggGroupOmit
    region?: RegionOmit
    generation?: GenerationOmit
    versionGroup?: VersionGroupOmit
    versionGroupRegion?: VersionGroupRegionOmit
    version?: VersionOmit
    location?: LocationOmit
    locationArea?: LocationAreaOmit
    encounterMethod?: EncounterMethodOmit
    encounterSlot?: EncounterSlotOmit
    encounter?: EncounterOmit
    encounterCondition?: EncounterConditionOmit
    encounterConditionValue?: EncounterConditionValueOmit
    encounterConditionValueMap?: EncounterConditionValueMapOmit
    locationAreaEncounterRate?: LocationAreaEncounterRateOmit
    moveDamageClass?: MoveDamageClassOmit
    moveEffect?: MoveEffectOmit
    moveMethod?: MoveMethodOmit
    move?: MoveOmit
    pokemonMove?: PokemonMoveOmit
    pokedex?: PokedexOmit
    pokedexVersionGroup?: PokedexVersionGroupOmit
    pokemonDexNumber?: PokemonDexNumberOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PokemonCountOutputType
   */

  export type PokemonCountOutputType = {
    abilities: number
    natures: number
    stats: number
    types: number
    egg_groups: number
    encounters: number
    dex_numbers: number
    move: number
  }

  export type PokemonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abilities?: boolean | PokemonCountOutputTypeCountAbilitiesArgs
    natures?: boolean | PokemonCountOutputTypeCountNaturesArgs
    stats?: boolean | PokemonCountOutputTypeCountStatsArgs
    types?: boolean | PokemonCountOutputTypeCountTypesArgs
    egg_groups?: boolean | PokemonCountOutputTypeCountEgg_groupsArgs
    encounters?: boolean | PokemonCountOutputTypeCountEncountersArgs
    dex_numbers?: boolean | PokemonCountOutputTypeCountDex_numbersArgs
    move?: boolean | PokemonCountOutputTypeCountMoveArgs
  }

  // Custom InputTypes
  /**
   * PokemonCountOutputType without action
   */
  export type PokemonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonCountOutputType
     */
    select?: PokemonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PokemonCountOutputType without action
   */
  export type PokemonCountOutputTypeCountAbilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonAbilityWhereInput
  }

  /**
   * PokemonCountOutputType without action
   */
  export type PokemonCountOutputTypeCountNaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonNatureWhereInput
  }

  /**
   * PokemonCountOutputType without action
   */
  export type PokemonCountOutputTypeCountStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonStatWhereInput
  }

  /**
   * PokemonCountOutputType without action
   */
  export type PokemonCountOutputTypeCountTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonTypeWhereInput
  }

  /**
   * PokemonCountOutputType without action
   */
  export type PokemonCountOutputTypeCountEgg_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonEggGroupWhereInput
  }

  /**
   * PokemonCountOutputType without action
   */
  export type PokemonCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }

  /**
   * PokemonCountOutputType without action
   */
  export type PokemonCountOutputTypeCountDex_numbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonDexNumberWhereInput
  }

  /**
   * PokemonCountOutputType without action
   */
  export type PokemonCountOutputTypeCountMoveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonMoveWhereInput
  }


  /**
   * Count Type AbilityCountOutputType
   */

  export type AbilityCountOutputType = {
    pokemon: number
  }

  export type AbilityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | AbilityCountOutputTypeCountPokemonArgs
  }

  // Custom InputTypes
  /**
   * AbilityCountOutputType without action
   */
  export type AbilityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbilityCountOutputType
     */
    select?: AbilityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AbilityCountOutputType without action
   */
  export type AbilityCountOutputTypeCountPokemonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonAbilityWhereInput
  }


  /**
   * Count Type NatureCountOutputType
   */

  export type NatureCountOutputType = {
    pokemon: number
  }

  export type NatureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | NatureCountOutputTypeCountPokemonArgs
  }

  // Custom InputTypes
  /**
   * NatureCountOutputType without action
   */
  export type NatureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NatureCountOutputType
     */
    select?: NatureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NatureCountOutputType without action
   */
  export type NatureCountOutputTypeCountPokemonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonNatureWhereInput
  }


  /**
   * Count Type StatCountOutputType
   */

  export type StatCountOutputType = {
    natures_increase: number
    natures_decrease: number
    pokemon_stats: number
  }

  export type StatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    natures_increase?: boolean | StatCountOutputTypeCountNatures_increaseArgs
    natures_decrease?: boolean | StatCountOutputTypeCountNatures_decreaseArgs
    pokemon_stats?: boolean | StatCountOutputTypeCountPokemon_statsArgs
  }

  // Custom InputTypes
  /**
   * StatCountOutputType without action
   */
  export type StatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatCountOutputType
     */
    select?: StatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StatCountOutputType without action
   */
  export type StatCountOutputTypeCountNatures_increaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NatureWhereInput
  }

  /**
   * StatCountOutputType without action
   */
  export type StatCountOutputTypeCountNatures_decreaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NatureWhereInput
  }

  /**
   * StatCountOutputType without action
   */
  export type StatCountOutputTypeCountPokemon_statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonStatWhereInput
  }


  /**
   * Count Type TypeCountOutputType
   */

  export type TypeCountOutputType = {
    pokemon: number
    attacking: number
    defending: number
    move: number
  }

  export type TypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | TypeCountOutputTypeCountPokemonArgs
    attacking?: boolean | TypeCountOutputTypeCountAttackingArgs
    defending?: boolean | TypeCountOutputTypeCountDefendingArgs
    move?: boolean | TypeCountOutputTypeCountMoveArgs
  }

  // Custom InputTypes
  /**
   * TypeCountOutputType without action
   */
  export type TypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeCountOutputType
     */
    select?: TypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TypeCountOutputType without action
   */
  export type TypeCountOutputTypeCountPokemonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonTypeWhereInput
  }

  /**
   * TypeCountOutputType without action
   */
  export type TypeCountOutputTypeCountAttackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TypeEffectivenessWhereInput
  }

  /**
   * TypeCountOutputType without action
   */
  export type TypeCountOutputTypeCountDefendingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TypeEffectivenessWhereInput
  }

  /**
   * TypeCountOutputType without action
   */
  export type TypeCountOutputTypeCountMoveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoveWhereInput
  }


  /**
   * Count Type EggGroupCountOutputType
   */

  export type EggGroupCountOutputType = {
    pokemon_egg_group: number
  }

  export type EggGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon_egg_group?: boolean | EggGroupCountOutputTypeCountPokemon_egg_groupArgs
  }

  // Custom InputTypes
  /**
   * EggGroupCountOutputType without action
   */
  export type EggGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggGroupCountOutputType
     */
    select?: EggGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EggGroupCountOutputType without action
   */
  export type EggGroupCountOutputTypeCountPokemon_egg_groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonEggGroupWhereInput
  }


  /**
   * Count Type RegionCountOutputType
   */

  export type RegionCountOutputType = {
    locations: number
    version_groups: number
    pokedex: number
  }

  export type RegionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | RegionCountOutputTypeCountLocationsArgs
    version_groups?: boolean | RegionCountOutputTypeCountVersion_groupsArgs
    pokedex?: boolean | RegionCountOutputTypeCountPokedexArgs
  }

  // Custom InputTypes
  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCountOutputType
     */
    select?: RegionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountLocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountVersion_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VersionGroupRegionWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountPokedexArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokedexWhereInput
  }


  /**
   * Count Type GenerationCountOutputType
   */

  export type GenerationCountOutputType = {
    types: number
    versionGroups: number
  }

  export type GenerationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    types?: boolean | GenerationCountOutputTypeCountTypesArgs
    versionGroups?: boolean | GenerationCountOutputTypeCountVersionGroupsArgs
  }

  // Custom InputTypes
  /**
   * GenerationCountOutputType without action
   */
  export type GenerationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenerationCountOutputType
     */
    select?: GenerationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GenerationCountOutputType without action
   */
  export type GenerationCountOutputTypeCountTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TypeWhereInput
  }

  /**
   * GenerationCountOutputType without action
   */
  export type GenerationCountOutputTypeCountVersionGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VersionGroupWhereInput
  }


  /**
   * Count Type VersionGroupCountOutputType
   */

  export type VersionGroupCountOutputType = {
    versions: number
    regions: number
    slots: number
    moves: number
    pokedex_version_groups: number
  }

  export type VersionGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | VersionGroupCountOutputTypeCountVersionsArgs
    regions?: boolean | VersionGroupCountOutputTypeCountRegionsArgs
    slots?: boolean | VersionGroupCountOutputTypeCountSlotsArgs
    moves?: boolean | VersionGroupCountOutputTypeCountMovesArgs
    pokedex_version_groups?: boolean | VersionGroupCountOutputTypeCountPokedex_version_groupsArgs
  }

  // Custom InputTypes
  /**
   * VersionGroupCountOutputType without action
   */
  export type VersionGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroupCountOutputType
     */
    select?: VersionGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VersionGroupCountOutputType without action
   */
  export type VersionGroupCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VersionWhereInput
  }

  /**
   * VersionGroupCountOutputType without action
   */
  export type VersionGroupCountOutputTypeCountRegionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VersionGroupRegionWhereInput
  }

  /**
   * VersionGroupCountOutputType without action
   */
  export type VersionGroupCountOutputTypeCountSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterSlotWhereInput
  }

  /**
   * VersionGroupCountOutputType without action
   */
  export type VersionGroupCountOutputTypeCountMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonMoveWhereInput
  }

  /**
   * VersionGroupCountOutputType without action
   */
  export type VersionGroupCountOutputTypeCountPokedex_version_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokedexVersionGroupWhereInput
  }


  /**
   * Count Type VersionCountOutputType
   */

  export type VersionCountOutputType = {
    encounters: number
    encounterRates: number
  }

  export type VersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounters?: boolean | VersionCountOutputTypeCountEncountersArgs
    encounterRates?: boolean | VersionCountOutputTypeCountEncounterRatesArgs
  }

  // Custom InputTypes
  /**
   * VersionCountOutputType without action
   */
  export type VersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionCountOutputType
     */
    select?: VersionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VersionCountOutputType without action
   */
  export type VersionCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }

  /**
   * VersionCountOutputType without action
   */
  export type VersionCountOutputTypeCountEncounterRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationAreaEncounterRateWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    areas: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    areas?: boolean | LocationCountOutputTypeCountAreasArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountAreasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationAreaWhereInput
  }


  /**
   * Count Type LocationAreaCountOutputType
   */

  export type LocationAreaCountOutputType = {
    encounters: number
    encounterRates: number
  }

  export type LocationAreaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounters?: boolean | LocationAreaCountOutputTypeCountEncountersArgs
    encounterRates?: boolean | LocationAreaCountOutputTypeCountEncounterRatesArgs
  }

  // Custom InputTypes
  /**
   * LocationAreaCountOutputType without action
   */
  export type LocationAreaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAreaCountOutputType
     */
    select?: LocationAreaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationAreaCountOutputType without action
   */
  export type LocationAreaCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }

  /**
   * LocationAreaCountOutputType without action
   */
  export type LocationAreaCountOutputTypeCountEncounterRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationAreaEncounterRateWhereInput
  }


  /**
   * Count Type EncounterMethodCountOutputType
   */

  export type EncounterMethodCountOutputType = {
    slots: number
    location_area_encounter_rates: number
  }

  export type EncounterMethodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    slots?: boolean | EncounterMethodCountOutputTypeCountSlotsArgs
    location_area_encounter_rates?: boolean | EncounterMethodCountOutputTypeCountLocation_area_encounter_ratesArgs
  }

  // Custom InputTypes
  /**
   * EncounterMethodCountOutputType without action
   */
  export type EncounterMethodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterMethodCountOutputType
     */
    select?: EncounterMethodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncounterMethodCountOutputType without action
   */
  export type EncounterMethodCountOutputTypeCountSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterSlotWhereInput
  }

  /**
   * EncounterMethodCountOutputType without action
   */
  export type EncounterMethodCountOutputTypeCountLocation_area_encounter_ratesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationAreaEncounterRateWhereInput
  }


  /**
   * Count Type EncounterSlotCountOutputType
   */

  export type EncounterSlotCountOutputType = {
    encounters: number
  }

  export type EncounterSlotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounters?: boolean | EncounterSlotCountOutputTypeCountEncountersArgs
  }

  // Custom InputTypes
  /**
   * EncounterSlotCountOutputType without action
   */
  export type EncounterSlotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSlotCountOutputType
     */
    select?: EncounterSlotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncounterSlotCountOutputType without action
   */
  export type EncounterSlotCountOutputTypeCountEncountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
  }


  /**
   * Count Type EncounterCountOutputType
   */

  export type EncounterCountOutputType = {
    conditions: number
  }

  export type EncounterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conditions?: boolean | EncounterCountOutputTypeCountConditionsArgs
  }

  // Custom InputTypes
  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCountOutputType
     */
    select?: EncounterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncounterCountOutputType without action
   */
  export type EncounterCountOutputTypeCountConditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterConditionValueMapWhereInput
  }


  /**
   * Count Type EncounterConditionCountOutputType
   */

  export type EncounterConditionCountOutputType = {
    values: number
  }

  export type EncounterConditionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | EncounterConditionCountOutputTypeCountValuesArgs
  }

  // Custom InputTypes
  /**
   * EncounterConditionCountOutputType without action
   */
  export type EncounterConditionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionCountOutputType
     */
    select?: EncounterConditionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncounterConditionCountOutputType without action
   */
  export type EncounterConditionCountOutputTypeCountValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterConditionValueWhereInput
  }


  /**
   * Count Type EncounterConditionValueCountOutputType
   */

  export type EncounterConditionValueCountOutputType = {
    maps: number
  }

  export type EncounterConditionValueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maps?: boolean | EncounterConditionValueCountOutputTypeCountMapsArgs
  }

  // Custom InputTypes
  /**
   * EncounterConditionValueCountOutputType without action
   */
  export type EncounterConditionValueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValueCountOutputType
     */
    select?: EncounterConditionValueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncounterConditionValueCountOutputType without action
   */
  export type EncounterConditionValueCountOutputTypeCountMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterConditionValueMapWhereInput
  }


  /**
   * Count Type MoveDamageClassCountOutputType
   */

  export type MoveDamageClassCountOutputType = {
    moves: number
  }

  export type MoveDamageClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    moves?: boolean | MoveDamageClassCountOutputTypeCountMovesArgs
  }

  // Custom InputTypes
  /**
   * MoveDamageClassCountOutputType without action
   */
  export type MoveDamageClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveDamageClassCountOutputType
     */
    select?: MoveDamageClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MoveDamageClassCountOutputType without action
   */
  export type MoveDamageClassCountOutputTypeCountMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoveWhereInput
  }


  /**
   * Count Type MoveEffectCountOutputType
   */

  export type MoveEffectCountOutputType = {
    moves: number
  }

  export type MoveEffectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    moves?: boolean | MoveEffectCountOutputTypeCountMovesArgs
  }

  // Custom InputTypes
  /**
   * MoveEffectCountOutputType without action
   */
  export type MoveEffectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveEffectCountOutputType
     */
    select?: MoveEffectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MoveEffectCountOutputType without action
   */
  export type MoveEffectCountOutputTypeCountMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoveWhereInput
  }


  /**
   * Count Type MoveMethodCountOutputType
   */

  export type MoveMethodCountOutputType = {
    moves: number
  }

  export type MoveMethodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    moves?: boolean | MoveMethodCountOutputTypeCountMovesArgs
  }

  // Custom InputTypes
  /**
   * MoveMethodCountOutputType without action
   */
  export type MoveMethodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveMethodCountOutputType
     */
    select?: MoveMethodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MoveMethodCountOutputType without action
   */
  export type MoveMethodCountOutputTypeCountMovesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonMoveWhereInput
  }


  /**
   * Count Type MoveCountOutputType
   */

  export type MoveCountOutputType = {
    pokemon_moves: number
  }

  export type MoveCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon_moves?: boolean | MoveCountOutputTypeCountPokemon_movesArgs
  }

  // Custom InputTypes
  /**
   * MoveCountOutputType without action
   */
  export type MoveCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveCountOutputType
     */
    select?: MoveCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MoveCountOutputType without action
   */
  export type MoveCountOutputTypeCountPokemon_movesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonMoveWhereInput
  }


  /**
   * Count Type PokedexCountOutputType
   */

  export type PokedexCountOutputType = {
    pokedex_version_groups: number
    pokemon_dex_numbers: number
  }

  export type PokedexCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokedex_version_groups?: boolean | PokedexCountOutputTypeCountPokedex_version_groupsArgs
    pokemon_dex_numbers?: boolean | PokedexCountOutputTypeCountPokemon_dex_numbersArgs
  }

  // Custom InputTypes
  /**
   * PokedexCountOutputType without action
   */
  export type PokedexCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokedexCountOutputType
     */
    select?: PokedexCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PokedexCountOutputType without action
   */
  export type PokedexCountOutputTypeCountPokedex_version_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokedexVersionGroupWhereInput
  }

  /**
   * PokedexCountOutputType without action
   */
  export type PokedexCountOutputTypeCountPokemon_dex_numbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonDexNumberWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
    role: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    name: string | null
    password: string | null
    role: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    role: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    created_at?: true
    updated_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    created_at?: true
    updated_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    name: string
    password: string
    role: string
    created_at: Date
    updated_at: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "role" | "created_at" | "updated_at", ExtArgs["result"]["user"]>

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      name: string
      password: string
      role: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
  }


  /**
   * Model Pokemon
   */

  export type AggregatePokemon = {
    _count: PokemonCountAggregateOutputType | null
    _avg: PokemonAvgAggregateOutputType | null
    _sum: PokemonSumAggregateOutputType | null
    _min: PokemonMinAggregateOutputType | null
    _max: PokemonMaxAggregateOutputType | null
  }

  export type PokemonAvgAggregateOutputType = {
    id: number | null
  }

  export type PokemonSumAggregateOutputType = {
    id: number | null
  }

  export type PokemonMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type PokemonMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type PokemonCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type PokemonAvgAggregateInputType = {
    id?: true
  }

  export type PokemonSumAggregateInputType = {
    id?: true
  }

  export type PokemonMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type PokemonMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type PokemonCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type PokemonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pokemon to aggregate.
     */
    where?: PokemonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pokemon to fetch.
     */
    orderBy?: PokemonOrderByWithRelationInput | PokemonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PokemonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pokemon from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pokemon.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pokemon
    **/
    _count?: true | PokemonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PokemonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PokemonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PokemonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PokemonMaxAggregateInputType
  }

  export type GetPokemonAggregateType<T extends PokemonAggregateArgs> = {
        [P in keyof T & keyof AggregatePokemon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePokemon[P]>
      : GetScalarType<T[P], AggregatePokemon[P]>
  }




  export type PokemonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonWhereInput
    orderBy?: PokemonOrderByWithAggregationInput | PokemonOrderByWithAggregationInput[]
    by: PokemonScalarFieldEnum[] | PokemonScalarFieldEnum
    having?: PokemonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PokemonCountAggregateInputType | true
    _avg?: PokemonAvgAggregateInputType
    _sum?: PokemonSumAggregateInputType
    _min?: PokemonMinAggregateInputType
    _max?: PokemonMaxAggregateInputType
  }

  export type PokemonGroupByOutputType = {
    id: number
    name: string
    _count: PokemonCountAggregateOutputType | null
    _avg: PokemonAvgAggregateOutputType | null
    _sum: PokemonSumAggregateOutputType | null
    _min: PokemonMinAggregateOutputType | null
    _max: PokemonMaxAggregateOutputType | null
  }

  type GetPokemonGroupByPayload<T extends PokemonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PokemonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PokemonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PokemonGroupByOutputType[P]>
            : GetScalarType<T[P], PokemonGroupByOutputType[P]>
        }
      >
    >


  export type PokemonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    abilities?: boolean | Pokemon$abilitiesArgs<ExtArgs>
    natures?: boolean | Pokemon$naturesArgs<ExtArgs>
    stats?: boolean | Pokemon$statsArgs<ExtArgs>
    types?: boolean | Pokemon$typesArgs<ExtArgs>
    egg_groups?: boolean | Pokemon$egg_groupsArgs<ExtArgs>
    encounters?: boolean | Pokemon$encountersArgs<ExtArgs>
    dex_numbers?: boolean | Pokemon$dex_numbersArgs<ExtArgs>
    move?: boolean | Pokemon$moveArgs<ExtArgs>
    _count?: boolean | PokemonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemon"]>

  export type PokemonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["pokemon"]>

  export type PokemonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["pokemon"]>

  export type PokemonSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type PokemonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["pokemon"]>
  export type PokemonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abilities?: boolean | Pokemon$abilitiesArgs<ExtArgs>
    natures?: boolean | Pokemon$naturesArgs<ExtArgs>
    stats?: boolean | Pokemon$statsArgs<ExtArgs>
    types?: boolean | Pokemon$typesArgs<ExtArgs>
    egg_groups?: boolean | Pokemon$egg_groupsArgs<ExtArgs>
    encounters?: boolean | Pokemon$encountersArgs<ExtArgs>
    dex_numbers?: boolean | Pokemon$dex_numbersArgs<ExtArgs>
    move?: boolean | Pokemon$moveArgs<ExtArgs>
    _count?: boolean | PokemonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PokemonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PokemonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PokemonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pokemon"
    objects: {
      abilities: Prisma.$PokemonAbilityPayload<ExtArgs>[]
      natures: Prisma.$PokemonNaturePayload<ExtArgs>[]
      stats: Prisma.$PokemonStatPayload<ExtArgs>[]
      types: Prisma.$PokemonTypePayload<ExtArgs>[]
      egg_groups: Prisma.$PokemonEggGroupPayload<ExtArgs>[]
      encounters: Prisma.$EncounterPayload<ExtArgs>[]
      dex_numbers: Prisma.$PokemonDexNumberPayload<ExtArgs>[]
      move: Prisma.$PokemonMovePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["pokemon"]>
    composites: {}
  }

  type PokemonGetPayload<S extends boolean | null | undefined | PokemonDefaultArgs> = $Result.GetResult<Prisma.$PokemonPayload, S>

  type PokemonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PokemonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PokemonCountAggregateInputType | true
    }

  export interface PokemonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pokemon'], meta: { name: 'Pokemon' } }
    /**
     * Find zero or one Pokemon that matches the filter.
     * @param {PokemonFindUniqueArgs} args - Arguments to find a Pokemon
     * @example
     * // Get one Pokemon
     * const pokemon = await prisma.pokemon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PokemonFindUniqueArgs>(args: SelectSubset<T, PokemonFindUniqueArgs<ExtArgs>>): Prisma__PokemonClient<$Result.GetResult<Prisma.$PokemonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pokemon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PokemonFindUniqueOrThrowArgs} args - Arguments to find a Pokemon
     * @example
     * // Get one Pokemon
     * const pokemon = await prisma.pokemon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PokemonFindUniqueOrThrowArgs>(args: SelectSubset<T, PokemonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PokemonClient<$Result.GetResult<Prisma.$PokemonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokemon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonFindFirstArgs} args - Arguments to find a Pokemon
     * @example
     * // Get one Pokemon
     * const pokemon = await prisma.pokemon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PokemonFindFirstArgs>(args?: SelectSubset<T, PokemonFindFirstArgs<ExtArgs>>): Prisma__PokemonClient<$Result.GetResult<Prisma.$PokemonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokemon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonFindFirstOrThrowArgs} args - Arguments to find a Pokemon
     * @example
     * // Get one Pokemon
     * const pokemon = await prisma.pokemon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PokemonFindFirstOrThrowArgs>(args?: SelectSubset<T, PokemonFindFirstOrThrowArgs<ExtArgs>>): Prisma__PokemonClient<$Result.GetResult<Prisma.$PokemonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pokemon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pokemon
     * const pokemon = await prisma.pokemon.findMany()
     * 
     * // Get first 10 Pokemon
     * const pokemon = await prisma.pokemon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pokemonWithIdOnly = await prisma.pokemon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PokemonFindManyArgs>(args?: SelectSubset<T, PokemonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pokemon.
     * @param {PokemonCreateArgs} args - Arguments to create a Pokemon.
     * @example
     * // Create one Pokemon
     * const Pokemon = await prisma.pokemon.create({
     *   data: {
     *     // ... data to create a Pokemon
     *   }
     * })
     * 
     */
    create<T extends PokemonCreateArgs>(args: SelectSubset<T, PokemonCreateArgs<ExtArgs>>): Prisma__PokemonClient<$Result.GetResult<Prisma.$PokemonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pokemon.
     * @param {PokemonCreateManyArgs} args - Arguments to create many Pokemon.
     * @example
     * // Create many Pokemon
     * const pokemon = await prisma.pokemon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PokemonCreateManyArgs>(args?: SelectSubset<T, PokemonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pokemon and returns the data saved in the database.
     * @param {PokemonCreateManyAndReturnArgs} args - Arguments to create many Pokemon.
     * @example
     * // Create many Pokemon
     * const pokemon = await prisma.pokemon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pokemon and only return the `id`
     * const pokemonWithIdOnly = await prisma.pokemon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PokemonCreateManyAndReturnArgs>(args?: SelectSubset<T, PokemonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pokemon.
     * @param {PokemonDeleteArgs} args - Arguments to delete one Pokemon.
     * @example
     * // Delete one Pokemon
     * const Pokemon = await prisma.pokemon.delete({
     *   where: {
     *     // ... filter to delete one Pokemon
     *   }
     * })
     * 
     */
    delete<T extends PokemonDeleteArgs>(args: SelectSubset<T, PokemonDeleteArgs<ExtArgs>>): Prisma__PokemonClient<$Result.GetResult<Prisma.$PokemonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pokemon.
     * @param {PokemonUpdateArgs} args - Arguments to update one Pokemon.
     * @example
     * // Update one Pokemon
     * const pokemon = await prisma.pokemon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PokemonUpdateArgs>(args: SelectSubset<T, PokemonUpdateArgs<ExtArgs>>): Prisma__PokemonClient<$Result.GetResult<Prisma.$PokemonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pokemon.
     * @param {PokemonDeleteManyArgs} args - Arguments to filter Pokemon to delete.
     * @example
     * // Delete a few Pokemon
     * const { count } = await prisma.pokemon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PokemonDeleteManyArgs>(args?: SelectSubset<T, PokemonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pokemon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pokemon
     * const pokemon = await prisma.pokemon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PokemonUpdateManyArgs>(args: SelectSubset<T, PokemonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pokemon and returns the data updated in the database.
     * @param {PokemonUpdateManyAndReturnArgs} args - Arguments to update many Pokemon.
     * @example
     * // Update many Pokemon
     * const pokemon = await prisma.pokemon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pokemon and only return the `id`
     * const pokemonWithIdOnly = await prisma.pokemon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PokemonUpdateManyAndReturnArgs>(args: SelectSubset<T, PokemonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pokemon.
     * @param {PokemonUpsertArgs} args - Arguments to update or create a Pokemon.
     * @example
     * // Update or create a Pokemon
     * const pokemon = await prisma.pokemon.upsert({
     *   create: {
     *     // ... data to create a Pokemon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pokemon we want to update
     *   }
     * })
     */
    upsert<T extends PokemonUpsertArgs>(args: SelectSubset<T, PokemonUpsertArgs<ExtArgs>>): Prisma__PokemonClient<$Result.GetResult<Prisma.$PokemonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pokemon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonCountArgs} args - Arguments to filter Pokemon to count.
     * @example
     * // Count the number of Pokemon
     * const count = await prisma.pokemon.count({
     *   where: {
     *     // ... the filter for the Pokemon we want to count
     *   }
     * })
    **/
    count<T extends PokemonCountArgs>(
      args?: Subset<T, PokemonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PokemonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pokemon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PokemonAggregateArgs>(args: Subset<T, PokemonAggregateArgs>): Prisma.PrismaPromise<GetPokemonAggregateType<T>>

    /**
     * Group by Pokemon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PokemonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PokemonGroupByArgs['orderBy'] }
        : { orderBy?: PokemonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PokemonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPokemonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pokemon model
   */
  readonly fields: PokemonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pokemon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PokemonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    abilities<T extends Pokemon$abilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Pokemon$abilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonAbilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    natures<T extends Pokemon$naturesArgs<ExtArgs> = {}>(args?: Subset<T, Pokemon$naturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonNaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stats<T extends Pokemon$statsArgs<ExtArgs> = {}>(args?: Subset<T, Pokemon$statsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonStatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    types<T extends Pokemon$typesArgs<ExtArgs> = {}>(args?: Subset<T, Pokemon$typesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    egg_groups<T extends Pokemon$egg_groupsArgs<ExtArgs> = {}>(args?: Subset<T, Pokemon$egg_groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonEggGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    encounters<T extends Pokemon$encountersArgs<ExtArgs> = {}>(args?: Subset<T, Pokemon$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dex_numbers<T extends Pokemon$dex_numbersArgs<ExtArgs> = {}>(args?: Subset<T, Pokemon$dex_numbersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonDexNumberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    move<T extends Pokemon$moveArgs<ExtArgs> = {}>(args?: Subset<T, Pokemon$moveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonMovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pokemon model
   */
  interface PokemonFieldRefs {
    readonly id: FieldRef<"Pokemon", 'Int'>
    readonly name: FieldRef<"Pokemon", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Pokemon findUnique
   */
  export type PokemonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokemon
     */
    select?: PokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokemon
     */
    omit?: PokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonInclude<ExtArgs> | null
    /**
     * Filter, which Pokemon to fetch.
     */
    where: PokemonWhereUniqueInput
  }

  /**
   * Pokemon findUniqueOrThrow
   */
  export type PokemonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokemon
     */
    select?: PokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokemon
     */
    omit?: PokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonInclude<ExtArgs> | null
    /**
     * Filter, which Pokemon to fetch.
     */
    where: PokemonWhereUniqueInput
  }

  /**
   * Pokemon findFirst
   */
  export type PokemonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokemon
     */
    select?: PokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokemon
     */
    omit?: PokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonInclude<ExtArgs> | null
    /**
     * Filter, which Pokemon to fetch.
     */
    where?: PokemonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pokemon to fetch.
     */
    orderBy?: PokemonOrderByWithRelationInput | PokemonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pokemon.
     */
    cursor?: PokemonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pokemon from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pokemon.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pokemon.
     */
    distinct?: PokemonScalarFieldEnum | PokemonScalarFieldEnum[]
  }

  /**
   * Pokemon findFirstOrThrow
   */
  export type PokemonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokemon
     */
    select?: PokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokemon
     */
    omit?: PokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonInclude<ExtArgs> | null
    /**
     * Filter, which Pokemon to fetch.
     */
    where?: PokemonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pokemon to fetch.
     */
    orderBy?: PokemonOrderByWithRelationInput | PokemonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pokemon.
     */
    cursor?: PokemonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pokemon from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pokemon.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pokemon.
     */
    distinct?: PokemonScalarFieldEnum | PokemonScalarFieldEnum[]
  }

  /**
   * Pokemon findMany
   */
  export type PokemonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokemon
     */
    select?: PokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokemon
     */
    omit?: PokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonInclude<ExtArgs> | null
    /**
     * Filter, which Pokemon to fetch.
     */
    where?: PokemonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pokemon to fetch.
     */
    orderBy?: PokemonOrderByWithRelationInput | PokemonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pokemon.
     */
    cursor?: PokemonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pokemon from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pokemon.
     */
    skip?: number
    distinct?: PokemonScalarFieldEnum | PokemonScalarFieldEnum[]
  }

  /**
   * Pokemon create
   */
  export type PokemonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokemon
     */
    select?: PokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokemon
     */
    omit?: PokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonInclude<ExtArgs> | null
    /**
     * The data needed to create a Pokemon.
     */
    data: XOR<PokemonCreateInput, PokemonUncheckedCreateInput>
  }

  /**
   * Pokemon createMany
   */
  export type PokemonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pokemon.
     */
    data: PokemonCreateManyInput | PokemonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pokemon createManyAndReturn
   */
  export type PokemonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokemon
     */
    select?: PokemonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pokemon
     */
    omit?: PokemonOmit<ExtArgs> | null
    /**
     * The data used to create many Pokemon.
     */
    data: PokemonCreateManyInput | PokemonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pokemon update
   */
  export type PokemonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokemon
     */
    select?: PokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokemon
     */
    omit?: PokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonInclude<ExtArgs> | null
    /**
     * The data needed to update a Pokemon.
     */
    data: XOR<PokemonUpdateInput, PokemonUncheckedUpdateInput>
    /**
     * Choose, which Pokemon to update.
     */
    where: PokemonWhereUniqueInput
  }

  /**
   * Pokemon updateMany
   */
  export type PokemonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pokemon.
     */
    data: XOR<PokemonUpdateManyMutationInput, PokemonUncheckedUpdateManyInput>
    /**
     * Filter which Pokemon to update
     */
    where?: PokemonWhereInput
    /**
     * Limit how many Pokemon to update.
     */
    limit?: number
  }

  /**
   * Pokemon updateManyAndReturn
   */
  export type PokemonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokemon
     */
    select?: PokemonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pokemon
     */
    omit?: PokemonOmit<ExtArgs> | null
    /**
     * The data used to update Pokemon.
     */
    data: XOR<PokemonUpdateManyMutationInput, PokemonUncheckedUpdateManyInput>
    /**
     * Filter which Pokemon to update
     */
    where?: PokemonWhereInput
    /**
     * Limit how many Pokemon to update.
     */
    limit?: number
  }

  /**
   * Pokemon upsert
   */
  export type PokemonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokemon
     */
    select?: PokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokemon
     */
    omit?: PokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonInclude<ExtArgs> | null
    /**
     * The filter to search for the Pokemon to update in case it exists.
     */
    where: PokemonWhereUniqueInput
    /**
     * In case the Pokemon found by the `where` argument doesn't exist, create a new Pokemon with this data.
     */
    create: XOR<PokemonCreateInput, PokemonUncheckedCreateInput>
    /**
     * In case the Pokemon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PokemonUpdateInput, PokemonUncheckedUpdateInput>
  }

  /**
   * Pokemon delete
   */
  export type PokemonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokemon
     */
    select?: PokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokemon
     */
    omit?: PokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonInclude<ExtArgs> | null
    /**
     * Filter which Pokemon to delete.
     */
    where: PokemonWhereUniqueInput
  }

  /**
   * Pokemon deleteMany
   */
  export type PokemonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pokemon to delete
     */
    where?: PokemonWhereInput
    /**
     * Limit how many Pokemon to delete.
     */
    limit?: number
  }

  /**
   * Pokemon.abilities
   */
  export type Pokemon$abilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonAbility
     */
    select?: PokemonAbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonAbility
     */
    omit?: PokemonAbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonAbilityInclude<ExtArgs> | null
    where?: PokemonAbilityWhereInput
    orderBy?: PokemonAbilityOrderByWithRelationInput | PokemonAbilityOrderByWithRelationInput[]
    cursor?: PokemonAbilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokemonAbilityScalarFieldEnum | PokemonAbilityScalarFieldEnum[]
  }

  /**
   * Pokemon.natures
   */
  export type Pokemon$naturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonNature
     */
    select?: PokemonNatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonNature
     */
    omit?: PokemonNatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonNatureInclude<ExtArgs> | null
    where?: PokemonNatureWhereInput
    orderBy?: PokemonNatureOrderByWithRelationInput | PokemonNatureOrderByWithRelationInput[]
    cursor?: PokemonNatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokemonNatureScalarFieldEnum | PokemonNatureScalarFieldEnum[]
  }

  /**
   * Pokemon.stats
   */
  export type Pokemon$statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonStat
     */
    select?: PokemonStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonStat
     */
    omit?: PokemonStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonStatInclude<ExtArgs> | null
    where?: PokemonStatWhereInput
    orderBy?: PokemonStatOrderByWithRelationInput | PokemonStatOrderByWithRelationInput[]
    cursor?: PokemonStatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokemonStatScalarFieldEnum | PokemonStatScalarFieldEnum[]
  }

  /**
   * Pokemon.types
   */
  export type Pokemon$typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonType
     */
    select?: PokemonTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonType
     */
    omit?: PokemonTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonTypeInclude<ExtArgs> | null
    where?: PokemonTypeWhereInput
    orderBy?: PokemonTypeOrderByWithRelationInput | PokemonTypeOrderByWithRelationInput[]
    cursor?: PokemonTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokemonTypeScalarFieldEnum | PokemonTypeScalarFieldEnum[]
  }

  /**
   * Pokemon.egg_groups
   */
  export type Pokemon$egg_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonEggGroup
     */
    select?: PokemonEggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonEggGroup
     */
    omit?: PokemonEggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonEggGroupInclude<ExtArgs> | null
    where?: PokemonEggGroupWhereInput
    orderBy?: PokemonEggGroupOrderByWithRelationInput | PokemonEggGroupOrderByWithRelationInput[]
    cursor?: PokemonEggGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokemonEggGroupScalarFieldEnum | PokemonEggGroupScalarFieldEnum[]
  }

  /**
   * Pokemon.encounters
   */
  export type Pokemon$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Pokemon.dex_numbers
   */
  export type Pokemon$dex_numbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonDexNumber
     */
    select?: PokemonDexNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonDexNumber
     */
    omit?: PokemonDexNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonDexNumberInclude<ExtArgs> | null
    where?: PokemonDexNumberWhereInput
    orderBy?: PokemonDexNumberOrderByWithRelationInput | PokemonDexNumberOrderByWithRelationInput[]
    cursor?: PokemonDexNumberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokemonDexNumberScalarFieldEnum | PokemonDexNumberScalarFieldEnum[]
  }

  /**
   * Pokemon.move
   */
  export type Pokemon$moveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonMove
     */
    select?: PokemonMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonMove
     */
    omit?: PokemonMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonMoveInclude<ExtArgs> | null
    where?: PokemonMoveWhereInput
    orderBy?: PokemonMoveOrderByWithRelationInput | PokemonMoveOrderByWithRelationInput[]
    cursor?: PokemonMoveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokemonMoveScalarFieldEnum | PokemonMoveScalarFieldEnum[]
  }

  /**
   * Pokemon without action
   */
  export type PokemonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokemon
     */
    select?: PokemonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokemon
     */
    omit?: PokemonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonInclude<ExtArgs> | null
  }


  /**
   * Model Ability
   */

  export type AggregateAbility = {
    _count: AbilityCountAggregateOutputType | null
    _avg: AbilityAvgAggregateOutputType | null
    _sum: AbilitySumAggregateOutputType | null
    _min: AbilityMinAggregateOutputType | null
    _max: AbilityMaxAggregateOutputType | null
  }

  export type AbilityAvgAggregateOutputType = {
    id: number | null
  }

  export type AbilitySumAggregateOutputType = {
    id: number | null
  }

  export type AbilityMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type AbilityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type AbilityCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type AbilityAvgAggregateInputType = {
    id?: true
  }

  export type AbilitySumAggregateInputType = {
    id?: true
  }

  export type AbilityMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type AbilityMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type AbilityCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type AbilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ability to aggregate.
     */
    where?: AbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abilities to fetch.
     */
    orderBy?: AbilityOrderByWithRelationInput | AbilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Abilities
    **/
    _count?: true | AbilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AbilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AbilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AbilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AbilityMaxAggregateInputType
  }

  export type GetAbilityAggregateType<T extends AbilityAggregateArgs> = {
        [P in keyof T & keyof AggregateAbility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbility[P]>
      : GetScalarType<T[P], AggregateAbility[P]>
  }




  export type AbilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbilityWhereInput
    orderBy?: AbilityOrderByWithAggregationInput | AbilityOrderByWithAggregationInput[]
    by: AbilityScalarFieldEnum[] | AbilityScalarFieldEnum
    having?: AbilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AbilityCountAggregateInputType | true
    _avg?: AbilityAvgAggregateInputType
    _sum?: AbilitySumAggregateInputType
    _min?: AbilityMinAggregateInputType
    _max?: AbilityMaxAggregateInputType
  }

  export type AbilityGroupByOutputType = {
    id: number
    name: string
    description: string
    _count: AbilityCountAggregateOutputType | null
    _avg: AbilityAvgAggregateOutputType | null
    _sum: AbilitySumAggregateOutputType | null
    _min: AbilityMinAggregateOutputType | null
    _max: AbilityMaxAggregateOutputType | null
  }

  type GetAbilityGroupByPayload<T extends AbilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AbilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AbilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AbilityGroupByOutputType[P]>
            : GetScalarType<T[P], AbilityGroupByOutputType[P]>
        }
      >
    >


  export type AbilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    pokemon?: boolean | Ability$pokemonArgs<ExtArgs>
    _count?: boolean | AbilityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ability"]>

  export type AbilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["ability"]>

  export type AbilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["ability"]>

  export type AbilitySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type AbilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["ability"]>
  export type AbilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | Ability$pokemonArgs<ExtArgs>
    _count?: boolean | AbilityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AbilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AbilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AbilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ability"
    objects: {
      pokemon: Prisma.$PokemonAbilityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
    }, ExtArgs["result"]["ability"]>
    composites: {}
  }

  type AbilityGetPayload<S extends boolean | null | undefined | AbilityDefaultArgs> = $Result.GetResult<Prisma.$AbilityPayload, S>

  type AbilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AbilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AbilityCountAggregateInputType | true
    }

  export interface AbilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ability'], meta: { name: 'Ability' } }
    /**
     * Find zero or one Ability that matches the filter.
     * @param {AbilityFindUniqueArgs} args - Arguments to find a Ability
     * @example
     * // Get one Ability
     * const ability = await prisma.ability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AbilityFindUniqueArgs>(args: SelectSubset<T, AbilityFindUniqueArgs<ExtArgs>>): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AbilityFindUniqueOrThrowArgs} args - Arguments to find a Ability
     * @example
     * // Get one Ability
     * const ability = await prisma.ability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AbilityFindUniqueOrThrowArgs>(args: SelectSubset<T, AbilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityFindFirstArgs} args - Arguments to find a Ability
     * @example
     * // Get one Ability
     * const ability = await prisma.ability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AbilityFindFirstArgs>(args?: SelectSubset<T, AbilityFindFirstArgs<ExtArgs>>): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityFindFirstOrThrowArgs} args - Arguments to find a Ability
     * @example
     * // Get one Ability
     * const ability = await prisma.ability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AbilityFindFirstOrThrowArgs>(args?: SelectSubset<T, AbilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Abilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Abilities
     * const abilities = await prisma.ability.findMany()
     * 
     * // Get first 10 Abilities
     * const abilities = await prisma.ability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const abilityWithIdOnly = await prisma.ability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AbilityFindManyArgs>(args?: SelectSubset<T, AbilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ability.
     * @param {AbilityCreateArgs} args - Arguments to create a Ability.
     * @example
     * // Create one Ability
     * const Ability = await prisma.ability.create({
     *   data: {
     *     // ... data to create a Ability
     *   }
     * })
     * 
     */
    create<T extends AbilityCreateArgs>(args: SelectSubset<T, AbilityCreateArgs<ExtArgs>>): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Abilities.
     * @param {AbilityCreateManyArgs} args - Arguments to create many Abilities.
     * @example
     * // Create many Abilities
     * const ability = await prisma.ability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AbilityCreateManyArgs>(args?: SelectSubset<T, AbilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Abilities and returns the data saved in the database.
     * @param {AbilityCreateManyAndReturnArgs} args - Arguments to create many Abilities.
     * @example
     * // Create many Abilities
     * const ability = await prisma.ability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Abilities and only return the `id`
     * const abilityWithIdOnly = await prisma.ability.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AbilityCreateManyAndReturnArgs>(args?: SelectSubset<T, AbilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ability.
     * @param {AbilityDeleteArgs} args - Arguments to delete one Ability.
     * @example
     * // Delete one Ability
     * const Ability = await prisma.ability.delete({
     *   where: {
     *     // ... filter to delete one Ability
     *   }
     * })
     * 
     */
    delete<T extends AbilityDeleteArgs>(args: SelectSubset<T, AbilityDeleteArgs<ExtArgs>>): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ability.
     * @param {AbilityUpdateArgs} args - Arguments to update one Ability.
     * @example
     * // Update one Ability
     * const ability = await prisma.ability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AbilityUpdateArgs>(args: SelectSubset<T, AbilityUpdateArgs<ExtArgs>>): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Abilities.
     * @param {AbilityDeleteManyArgs} args - Arguments to filter Abilities to delete.
     * @example
     * // Delete a few Abilities
     * const { count } = await prisma.ability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AbilityDeleteManyArgs>(args?: SelectSubset<T, AbilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Abilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Abilities
     * const ability = await prisma.ability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AbilityUpdateManyArgs>(args: SelectSubset<T, AbilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Abilities and returns the data updated in the database.
     * @param {AbilityUpdateManyAndReturnArgs} args - Arguments to update many Abilities.
     * @example
     * // Update many Abilities
     * const ability = await prisma.ability.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Abilities and only return the `id`
     * const abilityWithIdOnly = await prisma.ability.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AbilityUpdateManyAndReturnArgs>(args: SelectSubset<T, AbilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ability.
     * @param {AbilityUpsertArgs} args - Arguments to update or create a Ability.
     * @example
     * // Update or create a Ability
     * const ability = await prisma.ability.upsert({
     *   create: {
     *     // ... data to create a Ability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ability we want to update
     *   }
     * })
     */
    upsert<T extends AbilityUpsertArgs>(args: SelectSubset<T, AbilityUpsertArgs<ExtArgs>>): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Abilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityCountArgs} args - Arguments to filter Abilities to count.
     * @example
     * // Count the number of Abilities
     * const count = await prisma.ability.count({
     *   where: {
     *     // ... the filter for the Abilities we want to count
     *   }
     * })
    **/
    count<T extends AbilityCountArgs>(
      args?: Subset<T, AbilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AbilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AbilityAggregateArgs>(args: Subset<T, AbilityAggregateArgs>): Prisma.PrismaPromise<GetAbilityAggregateType<T>>

    /**
     * Group by Ability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AbilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AbilityGroupByArgs['orderBy'] }
        : { orderBy?: AbilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AbilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ability model
   */
  readonly fields: AbilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AbilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pokemon<T extends Ability$pokemonArgs<ExtArgs> = {}>(args?: Subset<T, Ability$pokemonArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonAbilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ability model
   */
  interface AbilityFieldRefs {
    readonly id: FieldRef<"Ability", 'Int'>
    readonly name: FieldRef<"Ability", 'String'>
    readonly description: FieldRef<"Ability", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ability findUnique
   */
  export type AbilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * Filter, which Ability to fetch.
     */
    where: AbilityWhereUniqueInput
  }

  /**
   * Ability findUniqueOrThrow
   */
  export type AbilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * Filter, which Ability to fetch.
     */
    where: AbilityWhereUniqueInput
  }

  /**
   * Ability findFirst
   */
  export type AbilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * Filter, which Ability to fetch.
     */
    where?: AbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abilities to fetch.
     */
    orderBy?: AbilityOrderByWithRelationInput | AbilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Abilities.
     */
    cursor?: AbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Abilities.
     */
    distinct?: AbilityScalarFieldEnum | AbilityScalarFieldEnum[]
  }

  /**
   * Ability findFirstOrThrow
   */
  export type AbilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * Filter, which Ability to fetch.
     */
    where?: AbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abilities to fetch.
     */
    orderBy?: AbilityOrderByWithRelationInput | AbilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Abilities.
     */
    cursor?: AbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Abilities.
     */
    distinct?: AbilityScalarFieldEnum | AbilityScalarFieldEnum[]
  }

  /**
   * Ability findMany
   */
  export type AbilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * Filter, which Abilities to fetch.
     */
    where?: AbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abilities to fetch.
     */
    orderBy?: AbilityOrderByWithRelationInput | AbilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Abilities.
     */
    cursor?: AbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abilities.
     */
    skip?: number
    distinct?: AbilityScalarFieldEnum | AbilityScalarFieldEnum[]
  }

  /**
   * Ability create
   */
  export type AbilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Ability.
     */
    data: XOR<AbilityCreateInput, AbilityUncheckedCreateInput>
  }

  /**
   * Ability createMany
   */
  export type AbilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Abilities.
     */
    data: AbilityCreateManyInput | AbilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ability createManyAndReturn
   */
  export type AbilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * The data used to create many Abilities.
     */
    data: AbilityCreateManyInput | AbilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ability update
   */
  export type AbilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Ability.
     */
    data: XOR<AbilityUpdateInput, AbilityUncheckedUpdateInput>
    /**
     * Choose, which Ability to update.
     */
    where: AbilityWhereUniqueInput
  }

  /**
   * Ability updateMany
   */
  export type AbilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Abilities.
     */
    data: XOR<AbilityUpdateManyMutationInput, AbilityUncheckedUpdateManyInput>
    /**
     * Filter which Abilities to update
     */
    where?: AbilityWhereInput
    /**
     * Limit how many Abilities to update.
     */
    limit?: number
  }

  /**
   * Ability updateManyAndReturn
   */
  export type AbilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * The data used to update Abilities.
     */
    data: XOR<AbilityUpdateManyMutationInput, AbilityUncheckedUpdateManyInput>
    /**
     * Filter which Abilities to update
     */
    where?: AbilityWhereInput
    /**
     * Limit how many Abilities to update.
     */
    limit?: number
  }

  /**
   * Ability upsert
   */
  export type AbilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Ability to update in case it exists.
     */
    where: AbilityWhereUniqueInput
    /**
     * In case the Ability found by the `where` argument doesn't exist, create a new Ability with this data.
     */
    create: XOR<AbilityCreateInput, AbilityUncheckedCreateInput>
    /**
     * In case the Ability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AbilityUpdateInput, AbilityUncheckedUpdateInput>
  }

  /**
   * Ability delete
   */
  export type AbilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
    /**
     * Filter which Ability to delete.
     */
    where: AbilityWhereUniqueInput
  }

  /**
   * Ability deleteMany
   */
  export type AbilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Abilities to delete
     */
    where?: AbilityWhereInput
    /**
     * Limit how many Abilities to delete.
     */
    limit?: number
  }

  /**
   * Ability.pokemon
   */
  export type Ability$pokemonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonAbility
     */
    select?: PokemonAbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonAbility
     */
    omit?: PokemonAbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonAbilityInclude<ExtArgs> | null
    where?: PokemonAbilityWhereInput
    orderBy?: PokemonAbilityOrderByWithRelationInput | PokemonAbilityOrderByWithRelationInput[]
    cursor?: PokemonAbilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokemonAbilityScalarFieldEnum | PokemonAbilityScalarFieldEnum[]
  }

  /**
   * Ability without action
   */
  export type AbilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ability
     */
    select?: AbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ability
     */
    omit?: AbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbilityInclude<ExtArgs> | null
  }


  /**
   * Model PokemonAbility
   */

  export type AggregatePokemonAbility = {
    _count: PokemonAbilityCountAggregateOutputType | null
    _avg: PokemonAbilityAvgAggregateOutputType | null
    _sum: PokemonAbilitySumAggregateOutputType | null
    _min: PokemonAbilityMinAggregateOutputType | null
    _max: PokemonAbilityMaxAggregateOutputType | null
  }

  export type PokemonAbilityAvgAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    ability_id: number | null
  }

  export type PokemonAbilitySumAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    ability_id: number | null
  }

  export type PokemonAbilityMinAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    ability_id: number | null
    is_hidden: boolean | null
  }

  export type PokemonAbilityMaxAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    ability_id: number | null
    is_hidden: boolean | null
  }

  export type PokemonAbilityCountAggregateOutputType = {
    id: number
    pokemon_id: number
    ability_id: number
    is_hidden: number
    _all: number
  }


  export type PokemonAbilityAvgAggregateInputType = {
    id?: true
    pokemon_id?: true
    ability_id?: true
  }

  export type PokemonAbilitySumAggregateInputType = {
    id?: true
    pokemon_id?: true
    ability_id?: true
  }

  export type PokemonAbilityMinAggregateInputType = {
    id?: true
    pokemon_id?: true
    ability_id?: true
    is_hidden?: true
  }

  export type PokemonAbilityMaxAggregateInputType = {
    id?: true
    pokemon_id?: true
    ability_id?: true
    is_hidden?: true
  }

  export type PokemonAbilityCountAggregateInputType = {
    id?: true
    pokemon_id?: true
    ability_id?: true
    is_hidden?: true
    _all?: true
  }

  export type PokemonAbilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PokemonAbility to aggregate.
     */
    where?: PokemonAbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonAbilities to fetch.
     */
    orderBy?: PokemonAbilityOrderByWithRelationInput | PokemonAbilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PokemonAbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonAbilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonAbilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PokemonAbilities
    **/
    _count?: true | PokemonAbilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PokemonAbilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PokemonAbilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PokemonAbilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PokemonAbilityMaxAggregateInputType
  }

  export type GetPokemonAbilityAggregateType<T extends PokemonAbilityAggregateArgs> = {
        [P in keyof T & keyof AggregatePokemonAbility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePokemonAbility[P]>
      : GetScalarType<T[P], AggregatePokemonAbility[P]>
  }




  export type PokemonAbilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonAbilityWhereInput
    orderBy?: PokemonAbilityOrderByWithAggregationInput | PokemonAbilityOrderByWithAggregationInput[]
    by: PokemonAbilityScalarFieldEnum[] | PokemonAbilityScalarFieldEnum
    having?: PokemonAbilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PokemonAbilityCountAggregateInputType | true
    _avg?: PokemonAbilityAvgAggregateInputType
    _sum?: PokemonAbilitySumAggregateInputType
    _min?: PokemonAbilityMinAggregateInputType
    _max?: PokemonAbilityMaxAggregateInputType
  }

  export type PokemonAbilityGroupByOutputType = {
    id: number
    pokemon_id: number
    ability_id: number
    is_hidden: boolean
    _count: PokemonAbilityCountAggregateOutputType | null
    _avg: PokemonAbilityAvgAggregateOutputType | null
    _sum: PokemonAbilitySumAggregateOutputType | null
    _min: PokemonAbilityMinAggregateOutputType | null
    _max: PokemonAbilityMaxAggregateOutputType | null
  }

  type GetPokemonAbilityGroupByPayload<T extends PokemonAbilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PokemonAbilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PokemonAbilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PokemonAbilityGroupByOutputType[P]>
            : GetScalarType<T[P], PokemonAbilityGroupByOutputType[P]>
        }
      >
    >


  export type PokemonAbilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pokemon_id?: boolean
    ability_id?: boolean
    is_hidden?: boolean
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    ability?: boolean | AbilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonAbility"]>

  export type PokemonAbilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pokemon_id?: boolean
    ability_id?: boolean
    is_hidden?: boolean
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    ability?: boolean | AbilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonAbility"]>

  export type PokemonAbilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pokemon_id?: boolean
    ability_id?: boolean
    is_hidden?: boolean
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    ability?: boolean | AbilityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonAbility"]>

  export type PokemonAbilitySelectScalar = {
    id?: boolean
    pokemon_id?: boolean
    ability_id?: boolean
    is_hidden?: boolean
  }

  export type PokemonAbilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pokemon_id" | "ability_id" | "is_hidden", ExtArgs["result"]["pokemonAbility"]>
  export type PokemonAbilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    ability?: boolean | AbilityDefaultArgs<ExtArgs>
  }
  export type PokemonAbilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    ability?: boolean | AbilityDefaultArgs<ExtArgs>
  }
  export type PokemonAbilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    ability?: boolean | AbilityDefaultArgs<ExtArgs>
  }

  export type $PokemonAbilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PokemonAbility"
    objects: {
      pokemon: Prisma.$PokemonPayload<ExtArgs>
      ability: Prisma.$AbilityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pokemon_id: number
      ability_id: number
      is_hidden: boolean
    }, ExtArgs["result"]["pokemonAbility"]>
    composites: {}
  }

  type PokemonAbilityGetPayload<S extends boolean | null | undefined | PokemonAbilityDefaultArgs> = $Result.GetResult<Prisma.$PokemonAbilityPayload, S>

  type PokemonAbilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PokemonAbilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PokemonAbilityCountAggregateInputType | true
    }

  export interface PokemonAbilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PokemonAbility'], meta: { name: 'PokemonAbility' } }
    /**
     * Find zero or one PokemonAbility that matches the filter.
     * @param {PokemonAbilityFindUniqueArgs} args - Arguments to find a PokemonAbility
     * @example
     * // Get one PokemonAbility
     * const pokemonAbility = await prisma.pokemonAbility.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PokemonAbilityFindUniqueArgs>(args: SelectSubset<T, PokemonAbilityFindUniqueArgs<ExtArgs>>): Prisma__PokemonAbilityClient<$Result.GetResult<Prisma.$PokemonAbilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PokemonAbility that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PokemonAbilityFindUniqueOrThrowArgs} args - Arguments to find a PokemonAbility
     * @example
     * // Get one PokemonAbility
     * const pokemonAbility = await prisma.pokemonAbility.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PokemonAbilityFindUniqueOrThrowArgs>(args: SelectSubset<T, PokemonAbilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PokemonAbilityClient<$Result.GetResult<Prisma.$PokemonAbilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PokemonAbility that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonAbilityFindFirstArgs} args - Arguments to find a PokemonAbility
     * @example
     * // Get one PokemonAbility
     * const pokemonAbility = await prisma.pokemonAbility.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PokemonAbilityFindFirstArgs>(args?: SelectSubset<T, PokemonAbilityFindFirstArgs<ExtArgs>>): Prisma__PokemonAbilityClient<$Result.GetResult<Prisma.$PokemonAbilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PokemonAbility that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonAbilityFindFirstOrThrowArgs} args - Arguments to find a PokemonAbility
     * @example
     * // Get one PokemonAbility
     * const pokemonAbility = await prisma.pokemonAbility.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PokemonAbilityFindFirstOrThrowArgs>(args?: SelectSubset<T, PokemonAbilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__PokemonAbilityClient<$Result.GetResult<Prisma.$PokemonAbilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PokemonAbilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonAbilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PokemonAbilities
     * const pokemonAbilities = await prisma.pokemonAbility.findMany()
     * 
     * // Get first 10 PokemonAbilities
     * const pokemonAbilities = await prisma.pokemonAbility.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pokemonAbilityWithIdOnly = await prisma.pokemonAbility.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PokemonAbilityFindManyArgs>(args?: SelectSubset<T, PokemonAbilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonAbilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PokemonAbility.
     * @param {PokemonAbilityCreateArgs} args - Arguments to create a PokemonAbility.
     * @example
     * // Create one PokemonAbility
     * const PokemonAbility = await prisma.pokemonAbility.create({
     *   data: {
     *     // ... data to create a PokemonAbility
     *   }
     * })
     * 
     */
    create<T extends PokemonAbilityCreateArgs>(args: SelectSubset<T, PokemonAbilityCreateArgs<ExtArgs>>): Prisma__PokemonAbilityClient<$Result.GetResult<Prisma.$PokemonAbilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PokemonAbilities.
     * @param {PokemonAbilityCreateManyArgs} args - Arguments to create many PokemonAbilities.
     * @example
     * // Create many PokemonAbilities
     * const pokemonAbility = await prisma.pokemonAbility.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PokemonAbilityCreateManyArgs>(args?: SelectSubset<T, PokemonAbilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PokemonAbilities and returns the data saved in the database.
     * @param {PokemonAbilityCreateManyAndReturnArgs} args - Arguments to create many PokemonAbilities.
     * @example
     * // Create many PokemonAbilities
     * const pokemonAbility = await prisma.pokemonAbility.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PokemonAbilities and only return the `id`
     * const pokemonAbilityWithIdOnly = await prisma.pokemonAbility.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PokemonAbilityCreateManyAndReturnArgs>(args?: SelectSubset<T, PokemonAbilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonAbilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PokemonAbility.
     * @param {PokemonAbilityDeleteArgs} args - Arguments to delete one PokemonAbility.
     * @example
     * // Delete one PokemonAbility
     * const PokemonAbility = await prisma.pokemonAbility.delete({
     *   where: {
     *     // ... filter to delete one PokemonAbility
     *   }
     * })
     * 
     */
    delete<T extends PokemonAbilityDeleteArgs>(args: SelectSubset<T, PokemonAbilityDeleteArgs<ExtArgs>>): Prisma__PokemonAbilityClient<$Result.GetResult<Prisma.$PokemonAbilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PokemonAbility.
     * @param {PokemonAbilityUpdateArgs} args - Arguments to update one PokemonAbility.
     * @example
     * // Update one PokemonAbility
     * const pokemonAbility = await prisma.pokemonAbility.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PokemonAbilityUpdateArgs>(args: SelectSubset<T, PokemonAbilityUpdateArgs<ExtArgs>>): Prisma__PokemonAbilityClient<$Result.GetResult<Prisma.$PokemonAbilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PokemonAbilities.
     * @param {PokemonAbilityDeleteManyArgs} args - Arguments to filter PokemonAbilities to delete.
     * @example
     * // Delete a few PokemonAbilities
     * const { count } = await prisma.pokemonAbility.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PokemonAbilityDeleteManyArgs>(args?: SelectSubset<T, PokemonAbilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PokemonAbilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonAbilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PokemonAbilities
     * const pokemonAbility = await prisma.pokemonAbility.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PokemonAbilityUpdateManyArgs>(args: SelectSubset<T, PokemonAbilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PokemonAbilities and returns the data updated in the database.
     * @param {PokemonAbilityUpdateManyAndReturnArgs} args - Arguments to update many PokemonAbilities.
     * @example
     * // Update many PokemonAbilities
     * const pokemonAbility = await prisma.pokemonAbility.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PokemonAbilities and only return the `id`
     * const pokemonAbilityWithIdOnly = await prisma.pokemonAbility.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PokemonAbilityUpdateManyAndReturnArgs>(args: SelectSubset<T, PokemonAbilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonAbilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PokemonAbility.
     * @param {PokemonAbilityUpsertArgs} args - Arguments to update or create a PokemonAbility.
     * @example
     * // Update or create a PokemonAbility
     * const pokemonAbility = await prisma.pokemonAbility.upsert({
     *   create: {
     *     // ... data to create a PokemonAbility
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PokemonAbility we want to update
     *   }
     * })
     */
    upsert<T extends PokemonAbilityUpsertArgs>(args: SelectSubset<T, PokemonAbilityUpsertArgs<ExtArgs>>): Prisma__PokemonAbilityClient<$Result.GetResult<Prisma.$PokemonAbilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PokemonAbilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonAbilityCountArgs} args - Arguments to filter PokemonAbilities to count.
     * @example
     * // Count the number of PokemonAbilities
     * const count = await prisma.pokemonAbility.count({
     *   where: {
     *     // ... the filter for the PokemonAbilities we want to count
     *   }
     * })
    **/
    count<T extends PokemonAbilityCountArgs>(
      args?: Subset<T, PokemonAbilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PokemonAbilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PokemonAbility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonAbilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PokemonAbilityAggregateArgs>(args: Subset<T, PokemonAbilityAggregateArgs>): Prisma.PrismaPromise<GetPokemonAbilityAggregateType<T>>

    /**
     * Group by PokemonAbility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonAbilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PokemonAbilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PokemonAbilityGroupByArgs['orderBy'] }
        : { orderBy?: PokemonAbilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PokemonAbilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPokemonAbilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PokemonAbility model
   */
  readonly fields: PokemonAbilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PokemonAbility.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PokemonAbilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pokemon<T extends PokemonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PokemonDefaultArgs<ExtArgs>>): Prisma__PokemonClient<$Result.GetResult<Prisma.$PokemonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ability<T extends AbilityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AbilityDefaultArgs<ExtArgs>>): Prisma__AbilityClient<$Result.GetResult<Prisma.$AbilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PokemonAbility model
   */
  interface PokemonAbilityFieldRefs {
    readonly id: FieldRef<"PokemonAbility", 'Int'>
    readonly pokemon_id: FieldRef<"PokemonAbility", 'Int'>
    readonly ability_id: FieldRef<"PokemonAbility", 'Int'>
    readonly is_hidden: FieldRef<"PokemonAbility", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PokemonAbility findUnique
   */
  export type PokemonAbilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonAbility
     */
    select?: PokemonAbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonAbility
     */
    omit?: PokemonAbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonAbilityInclude<ExtArgs> | null
    /**
     * Filter, which PokemonAbility to fetch.
     */
    where: PokemonAbilityWhereUniqueInput
  }

  /**
   * PokemonAbility findUniqueOrThrow
   */
  export type PokemonAbilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonAbility
     */
    select?: PokemonAbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonAbility
     */
    omit?: PokemonAbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonAbilityInclude<ExtArgs> | null
    /**
     * Filter, which PokemonAbility to fetch.
     */
    where: PokemonAbilityWhereUniqueInput
  }

  /**
   * PokemonAbility findFirst
   */
  export type PokemonAbilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonAbility
     */
    select?: PokemonAbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonAbility
     */
    omit?: PokemonAbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonAbilityInclude<ExtArgs> | null
    /**
     * Filter, which PokemonAbility to fetch.
     */
    where?: PokemonAbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonAbilities to fetch.
     */
    orderBy?: PokemonAbilityOrderByWithRelationInput | PokemonAbilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PokemonAbilities.
     */
    cursor?: PokemonAbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonAbilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonAbilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PokemonAbilities.
     */
    distinct?: PokemonAbilityScalarFieldEnum | PokemonAbilityScalarFieldEnum[]
  }

  /**
   * PokemonAbility findFirstOrThrow
   */
  export type PokemonAbilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonAbility
     */
    select?: PokemonAbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonAbility
     */
    omit?: PokemonAbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonAbilityInclude<ExtArgs> | null
    /**
     * Filter, which PokemonAbility to fetch.
     */
    where?: PokemonAbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonAbilities to fetch.
     */
    orderBy?: PokemonAbilityOrderByWithRelationInput | PokemonAbilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PokemonAbilities.
     */
    cursor?: PokemonAbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonAbilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonAbilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PokemonAbilities.
     */
    distinct?: PokemonAbilityScalarFieldEnum | PokemonAbilityScalarFieldEnum[]
  }

  /**
   * PokemonAbility findMany
   */
  export type PokemonAbilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonAbility
     */
    select?: PokemonAbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonAbility
     */
    omit?: PokemonAbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonAbilityInclude<ExtArgs> | null
    /**
     * Filter, which PokemonAbilities to fetch.
     */
    where?: PokemonAbilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonAbilities to fetch.
     */
    orderBy?: PokemonAbilityOrderByWithRelationInput | PokemonAbilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PokemonAbilities.
     */
    cursor?: PokemonAbilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonAbilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonAbilities.
     */
    skip?: number
    distinct?: PokemonAbilityScalarFieldEnum | PokemonAbilityScalarFieldEnum[]
  }

  /**
   * PokemonAbility create
   */
  export type PokemonAbilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonAbility
     */
    select?: PokemonAbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonAbility
     */
    omit?: PokemonAbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonAbilityInclude<ExtArgs> | null
    /**
     * The data needed to create a PokemonAbility.
     */
    data: XOR<PokemonAbilityCreateInput, PokemonAbilityUncheckedCreateInput>
  }

  /**
   * PokemonAbility createMany
   */
  export type PokemonAbilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PokemonAbilities.
     */
    data: PokemonAbilityCreateManyInput | PokemonAbilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PokemonAbility createManyAndReturn
   */
  export type PokemonAbilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonAbility
     */
    select?: PokemonAbilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonAbility
     */
    omit?: PokemonAbilityOmit<ExtArgs> | null
    /**
     * The data used to create many PokemonAbilities.
     */
    data: PokemonAbilityCreateManyInput | PokemonAbilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonAbilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PokemonAbility update
   */
  export type PokemonAbilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonAbility
     */
    select?: PokemonAbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonAbility
     */
    omit?: PokemonAbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonAbilityInclude<ExtArgs> | null
    /**
     * The data needed to update a PokemonAbility.
     */
    data: XOR<PokemonAbilityUpdateInput, PokemonAbilityUncheckedUpdateInput>
    /**
     * Choose, which PokemonAbility to update.
     */
    where: PokemonAbilityWhereUniqueInput
  }

  /**
   * PokemonAbility updateMany
   */
  export type PokemonAbilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PokemonAbilities.
     */
    data: XOR<PokemonAbilityUpdateManyMutationInput, PokemonAbilityUncheckedUpdateManyInput>
    /**
     * Filter which PokemonAbilities to update
     */
    where?: PokemonAbilityWhereInput
    /**
     * Limit how many PokemonAbilities to update.
     */
    limit?: number
  }

  /**
   * PokemonAbility updateManyAndReturn
   */
  export type PokemonAbilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonAbility
     */
    select?: PokemonAbilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonAbility
     */
    omit?: PokemonAbilityOmit<ExtArgs> | null
    /**
     * The data used to update PokemonAbilities.
     */
    data: XOR<PokemonAbilityUpdateManyMutationInput, PokemonAbilityUncheckedUpdateManyInput>
    /**
     * Filter which PokemonAbilities to update
     */
    where?: PokemonAbilityWhereInput
    /**
     * Limit how many PokemonAbilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonAbilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PokemonAbility upsert
   */
  export type PokemonAbilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonAbility
     */
    select?: PokemonAbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonAbility
     */
    omit?: PokemonAbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonAbilityInclude<ExtArgs> | null
    /**
     * The filter to search for the PokemonAbility to update in case it exists.
     */
    where: PokemonAbilityWhereUniqueInput
    /**
     * In case the PokemonAbility found by the `where` argument doesn't exist, create a new PokemonAbility with this data.
     */
    create: XOR<PokemonAbilityCreateInput, PokemonAbilityUncheckedCreateInput>
    /**
     * In case the PokemonAbility was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PokemonAbilityUpdateInput, PokemonAbilityUncheckedUpdateInput>
  }

  /**
   * PokemonAbility delete
   */
  export type PokemonAbilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonAbility
     */
    select?: PokemonAbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonAbility
     */
    omit?: PokemonAbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonAbilityInclude<ExtArgs> | null
    /**
     * Filter which PokemonAbility to delete.
     */
    where: PokemonAbilityWhereUniqueInput
  }

  /**
   * PokemonAbility deleteMany
   */
  export type PokemonAbilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PokemonAbilities to delete
     */
    where?: PokemonAbilityWhereInput
    /**
     * Limit how many PokemonAbilities to delete.
     */
    limit?: number
  }

  /**
   * PokemonAbility without action
   */
  export type PokemonAbilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonAbility
     */
    select?: PokemonAbilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonAbility
     */
    omit?: PokemonAbilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonAbilityInclude<ExtArgs> | null
  }


  /**
   * Model Nature
   */

  export type AggregateNature = {
    _count: NatureCountAggregateOutputType | null
    _avg: NatureAvgAggregateOutputType | null
    _sum: NatureSumAggregateOutputType | null
    _min: NatureMinAggregateOutputType | null
    _max: NatureMaxAggregateOutputType | null
  }

  export type NatureAvgAggregateOutputType = {
    id: number | null
    increased_stat_id: number | null
    decreased_stat_id: number | null
  }

  export type NatureSumAggregateOutputType = {
    id: number | null
    increased_stat_id: number | null
    decreased_stat_id: number | null
  }

  export type NatureMinAggregateOutputType = {
    id: number | null
    name: string | null
    increased_stat_id: number | null
    decreased_stat_id: number | null
  }

  export type NatureMaxAggregateOutputType = {
    id: number | null
    name: string | null
    increased_stat_id: number | null
    decreased_stat_id: number | null
  }

  export type NatureCountAggregateOutputType = {
    id: number
    name: number
    increased_stat_id: number
    decreased_stat_id: number
    _all: number
  }


  export type NatureAvgAggregateInputType = {
    id?: true
    increased_stat_id?: true
    decreased_stat_id?: true
  }

  export type NatureSumAggregateInputType = {
    id?: true
    increased_stat_id?: true
    decreased_stat_id?: true
  }

  export type NatureMinAggregateInputType = {
    id?: true
    name?: true
    increased_stat_id?: true
    decreased_stat_id?: true
  }

  export type NatureMaxAggregateInputType = {
    id?: true
    name?: true
    increased_stat_id?: true
    decreased_stat_id?: true
  }

  export type NatureCountAggregateInputType = {
    id?: true
    name?: true
    increased_stat_id?: true
    decreased_stat_id?: true
    _all?: true
  }

  export type NatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nature to aggregate.
     */
    where?: NatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Natures to fetch.
     */
    orderBy?: NatureOrderByWithRelationInput | NatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Natures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Natures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Natures
    **/
    _count?: true | NatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NatureMaxAggregateInputType
  }

  export type GetNatureAggregateType<T extends NatureAggregateArgs> = {
        [P in keyof T & keyof AggregateNature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNature[P]>
      : GetScalarType<T[P], AggregateNature[P]>
  }




  export type NatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NatureWhereInput
    orderBy?: NatureOrderByWithAggregationInput | NatureOrderByWithAggregationInput[]
    by: NatureScalarFieldEnum[] | NatureScalarFieldEnum
    having?: NatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NatureCountAggregateInputType | true
    _avg?: NatureAvgAggregateInputType
    _sum?: NatureSumAggregateInputType
    _min?: NatureMinAggregateInputType
    _max?: NatureMaxAggregateInputType
  }

  export type NatureGroupByOutputType = {
    id: number
    name: string
    increased_stat_id: number
    decreased_stat_id: number
    _count: NatureCountAggregateOutputType | null
    _avg: NatureAvgAggregateOutputType | null
    _sum: NatureSumAggregateOutputType | null
    _min: NatureMinAggregateOutputType | null
    _max: NatureMaxAggregateOutputType | null
  }

  type GetNatureGroupByPayload<T extends NatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NatureGroupByOutputType[P]>
            : GetScalarType<T[P], NatureGroupByOutputType[P]>
        }
      >
    >


  export type NatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    increased_stat_id?: boolean
    decreased_stat_id?: boolean
    stat_increased?: boolean | StatDefaultArgs<ExtArgs>
    stat_decreased?: boolean | StatDefaultArgs<ExtArgs>
    pokemon?: boolean | Nature$pokemonArgs<ExtArgs>
    _count?: boolean | NatureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nature"]>

  export type NatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    increased_stat_id?: boolean
    decreased_stat_id?: boolean
    stat_increased?: boolean | StatDefaultArgs<ExtArgs>
    stat_decreased?: boolean | StatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nature"]>

  export type NatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    increased_stat_id?: boolean
    decreased_stat_id?: boolean
    stat_increased?: boolean | StatDefaultArgs<ExtArgs>
    stat_decreased?: boolean | StatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nature"]>

  export type NatureSelectScalar = {
    id?: boolean
    name?: boolean
    increased_stat_id?: boolean
    decreased_stat_id?: boolean
  }

  export type NatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "increased_stat_id" | "decreased_stat_id", ExtArgs["result"]["nature"]>
  export type NatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stat_increased?: boolean | StatDefaultArgs<ExtArgs>
    stat_decreased?: boolean | StatDefaultArgs<ExtArgs>
    pokemon?: boolean | Nature$pokemonArgs<ExtArgs>
    _count?: boolean | NatureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stat_increased?: boolean | StatDefaultArgs<ExtArgs>
    stat_decreased?: boolean | StatDefaultArgs<ExtArgs>
  }
  export type NatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stat_increased?: boolean | StatDefaultArgs<ExtArgs>
    stat_decreased?: boolean | StatDefaultArgs<ExtArgs>
  }

  export type $NaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Nature"
    objects: {
      stat_increased: Prisma.$StatPayload<ExtArgs>
      stat_decreased: Prisma.$StatPayload<ExtArgs>
      pokemon: Prisma.$PokemonNaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      increased_stat_id: number
      decreased_stat_id: number
    }, ExtArgs["result"]["nature"]>
    composites: {}
  }

  type NatureGetPayload<S extends boolean | null | undefined | NatureDefaultArgs> = $Result.GetResult<Prisma.$NaturePayload, S>

  type NatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NatureCountAggregateInputType | true
    }

  export interface NatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Nature'], meta: { name: 'Nature' } }
    /**
     * Find zero or one Nature that matches the filter.
     * @param {NatureFindUniqueArgs} args - Arguments to find a Nature
     * @example
     * // Get one Nature
     * const nature = await prisma.nature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NatureFindUniqueArgs>(args: SelectSubset<T, NatureFindUniqueArgs<ExtArgs>>): Prisma__NatureClient<$Result.GetResult<Prisma.$NaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Nature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NatureFindUniqueOrThrowArgs} args - Arguments to find a Nature
     * @example
     * // Get one Nature
     * const nature = await prisma.nature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NatureFindUniqueOrThrowArgs>(args: SelectSubset<T, NatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NatureClient<$Result.GetResult<Prisma.$NaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Nature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NatureFindFirstArgs} args - Arguments to find a Nature
     * @example
     * // Get one Nature
     * const nature = await prisma.nature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NatureFindFirstArgs>(args?: SelectSubset<T, NatureFindFirstArgs<ExtArgs>>): Prisma__NatureClient<$Result.GetResult<Prisma.$NaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Nature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NatureFindFirstOrThrowArgs} args - Arguments to find a Nature
     * @example
     * // Get one Nature
     * const nature = await prisma.nature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NatureFindFirstOrThrowArgs>(args?: SelectSubset<T, NatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__NatureClient<$Result.GetResult<Prisma.$NaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Natures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Natures
     * const natures = await prisma.nature.findMany()
     * 
     * // Get first 10 Natures
     * const natures = await prisma.nature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const natureWithIdOnly = await prisma.nature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NatureFindManyArgs>(args?: SelectSubset<T, NatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Nature.
     * @param {NatureCreateArgs} args - Arguments to create a Nature.
     * @example
     * // Create one Nature
     * const Nature = await prisma.nature.create({
     *   data: {
     *     // ... data to create a Nature
     *   }
     * })
     * 
     */
    create<T extends NatureCreateArgs>(args: SelectSubset<T, NatureCreateArgs<ExtArgs>>): Prisma__NatureClient<$Result.GetResult<Prisma.$NaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Natures.
     * @param {NatureCreateManyArgs} args - Arguments to create many Natures.
     * @example
     * // Create many Natures
     * const nature = await prisma.nature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NatureCreateManyArgs>(args?: SelectSubset<T, NatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Natures and returns the data saved in the database.
     * @param {NatureCreateManyAndReturnArgs} args - Arguments to create many Natures.
     * @example
     * // Create many Natures
     * const nature = await prisma.nature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Natures and only return the `id`
     * const natureWithIdOnly = await prisma.nature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NatureCreateManyAndReturnArgs>(args?: SelectSubset<T, NatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Nature.
     * @param {NatureDeleteArgs} args - Arguments to delete one Nature.
     * @example
     * // Delete one Nature
     * const Nature = await prisma.nature.delete({
     *   where: {
     *     // ... filter to delete one Nature
     *   }
     * })
     * 
     */
    delete<T extends NatureDeleteArgs>(args: SelectSubset<T, NatureDeleteArgs<ExtArgs>>): Prisma__NatureClient<$Result.GetResult<Prisma.$NaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Nature.
     * @param {NatureUpdateArgs} args - Arguments to update one Nature.
     * @example
     * // Update one Nature
     * const nature = await prisma.nature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NatureUpdateArgs>(args: SelectSubset<T, NatureUpdateArgs<ExtArgs>>): Prisma__NatureClient<$Result.GetResult<Prisma.$NaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Natures.
     * @param {NatureDeleteManyArgs} args - Arguments to filter Natures to delete.
     * @example
     * // Delete a few Natures
     * const { count } = await prisma.nature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NatureDeleteManyArgs>(args?: SelectSubset<T, NatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Natures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Natures
     * const nature = await prisma.nature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NatureUpdateManyArgs>(args: SelectSubset<T, NatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Natures and returns the data updated in the database.
     * @param {NatureUpdateManyAndReturnArgs} args - Arguments to update many Natures.
     * @example
     * // Update many Natures
     * const nature = await prisma.nature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Natures and only return the `id`
     * const natureWithIdOnly = await prisma.nature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NatureUpdateManyAndReturnArgs>(args: SelectSubset<T, NatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Nature.
     * @param {NatureUpsertArgs} args - Arguments to update or create a Nature.
     * @example
     * // Update or create a Nature
     * const nature = await prisma.nature.upsert({
     *   create: {
     *     // ... data to create a Nature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nature we want to update
     *   }
     * })
     */
    upsert<T extends NatureUpsertArgs>(args: SelectSubset<T, NatureUpsertArgs<ExtArgs>>): Prisma__NatureClient<$Result.GetResult<Prisma.$NaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Natures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NatureCountArgs} args - Arguments to filter Natures to count.
     * @example
     * // Count the number of Natures
     * const count = await prisma.nature.count({
     *   where: {
     *     // ... the filter for the Natures we want to count
     *   }
     * })
    **/
    count<T extends NatureCountArgs>(
      args?: Subset<T, NatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Nature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NatureAggregateArgs>(args: Subset<T, NatureAggregateArgs>): Prisma.PrismaPromise<GetNatureAggregateType<T>>

    /**
     * Group by Nature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NatureGroupByArgs['orderBy'] }
        : { orderBy?: NatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Nature model
   */
  readonly fields: NatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Nature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stat_increased<T extends StatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StatDefaultArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stat_decreased<T extends StatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StatDefaultArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemon<T extends Nature$pokemonArgs<ExtArgs> = {}>(args?: Subset<T, Nature$pokemonArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonNaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Nature model
   */
  interface NatureFieldRefs {
    readonly id: FieldRef<"Nature", 'Int'>
    readonly name: FieldRef<"Nature", 'String'>
    readonly increased_stat_id: FieldRef<"Nature", 'Int'>
    readonly decreased_stat_id: FieldRef<"Nature", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Nature findUnique
   */
  export type NatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nature
     */
    select?: NatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nature
     */
    omit?: NatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureInclude<ExtArgs> | null
    /**
     * Filter, which Nature to fetch.
     */
    where: NatureWhereUniqueInput
  }

  /**
   * Nature findUniqueOrThrow
   */
  export type NatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nature
     */
    select?: NatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nature
     */
    omit?: NatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureInclude<ExtArgs> | null
    /**
     * Filter, which Nature to fetch.
     */
    where: NatureWhereUniqueInput
  }

  /**
   * Nature findFirst
   */
  export type NatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nature
     */
    select?: NatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nature
     */
    omit?: NatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureInclude<ExtArgs> | null
    /**
     * Filter, which Nature to fetch.
     */
    where?: NatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Natures to fetch.
     */
    orderBy?: NatureOrderByWithRelationInput | NatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Natures.
     */
    cursor?: NatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Natures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Natures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Natures.
     */
    distinct?: NatureScalarFieldEnum | NatureScalarFieldEnum[]
  }

  /**
   * Nature findFirstOrThrow
   */
  export type NatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nature
     */
    select?: NatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nature
     */
    omit?: NatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureInclude<ExtArgs> | null
    /**
     * Filter, which Nature to fetch.
     */
    where?: NatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Natures to fetch.
     */
    orderBy?: NatureOrderByWithRelationInput | NatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Natures.
     */
    cursor?: NatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Natures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Natures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Natures.
     */
    distinct?: NatureScalarFieldEnum | NatureScalarFieldEnum[]
  }

  /**
   * Nature findMany
   */
  export type NatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nature
     */
    select?: NatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nature
     */
    omit?: NatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureInclude<ExtArgs> | null
    /**
     * Filter, which Natures to fetch.
     */
    where?: NatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Natures to fetch.
     */
    orderBy?: NatureOrderByWithRelationInput | NatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Natures.
     */
    cursor?: NatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Natures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Natures.
     */
    skip?: number
    distinct?: NatureScalarFieldEnum | NatureScalarFieldEnum[]
  }

  /**
   * Nature create
   */
  export type NatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nature
     */
    select?: NatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nature
     */
    omit?: NatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureInclude<ExtArgs> | null
    /**
     * The data needed to create a Nature.
     */
    data: XOR<NatureCreateInput, NatureUncheckedCreateInput>
  }

  /**
   * Nature createMany
   */
  export type NatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Natures.
     */
    data: NatureCreateManyInput | NatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Nature createManyAndReturn
   */
  export type NatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nature
     */
    select?: NatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Nature
     */
    omit?: NatureOmit<ExtArgs> | null
    /**
     * The data used to create many Natures.
     */
    data: NatureCreateManyInput | NatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Nature update
   */
  export type NatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nature
     */
    select?: NatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nature
     */
    omit?: NatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureInclude<ExtArgs> | null
    /**
     * The data needed to update a Nature.
     */
    data: XOR<NatureUpdateInput, NatureUncheckedUpdateInput>
    /**
     * Choose, which Nature to update.
     */
    where: NatureWhereUniqueInput
  }

  /**
   * Nature updateMany
   */
  export type NatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Natures.
     */
    data: XOR<NatureUpdateManyMutationInput, NatureUncheckedUpdateManyInput>
    /**
     * Filter which Natures to update
     */
    where?: NatureWhereInput
    /**
     * Limit how many Natures to update.
     */
    limit?: number
  }

  /**
   * Nature updateManyAndReturn
   */
  export type NatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nature
     */
    select?: NatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Nature
     */
    omit?: NatureOmit<ExtArgs> | null
    /**
     * The data used to update Natures.
     */
    data: XOR<NatureUpdateManyMutationInput, NatureUncheckedUpdateManyInput>
    /**
     * Filter which Natures to update
     */
    where?: NatureWhereInput
    /**
     * Limit how many Natures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Nature upsert
   */
  export type NatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nature
     */
    select?: NatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nature
     */
    omit?: NatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureInclude<ExtArgs> | null
    /**
     * The filter to search for the Nature to update in case it exists.
     */
    where: NatureWhereUniqueInput
    /**
     * In case the Nature found by the `where` argument doesn't exist, create a new Nature with this data.
     */
    create: XOR<NatureCreateInput, NatureUncheckedCreateInput>
    /**
     * In case the Nature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NatureUpdateInput, NatureUncheckedUpdateInput>
  }

  /**
   * Nature delete
   */
  export type NatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nature
     */
    select?: NatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nature
     */
    omit?: NatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureInclude<ExtArgs> | null
    /**
     * Filter which Nature to delete.
     */
    where: NatureWhereUniqueInput
  }

  /**
   * Nature deleteMany
   */
  export type NatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Natures to delete
     */
    where?: NatureWhereInput
    /**
     * Limit how many Natures to delete.
     */
    limit?: number
  }

  /**
   * Nature.pokemon
   */
  export type Nature$pokemonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonNature
     */
    select?: PokemonNatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonNature
     */
    omit?: PokemonNatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonNatureInclude<ExtArgs> | null
    where?: PokemonNatureWhereInput
    orderBy?: PokemonNatureOrderByWithRelationInput | PokemonNatureOrderByWithRelationInput[]
    cursor?: PokemonNatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokemonNatureScalarFieldEnum | PokemonNatureScalarFieldEnum[]
  }

  /**
   * Nature without action
   */
  export type NatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nature
     */
    select?: NatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nature
     */
    omit?: NatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureInclude<ExtArgs> | null
  }


  /**
   * Model PokemonNature
   */

  export type AggregatePokemonNature = {
    _count: PokemonNatureCountAggregateOutputType | null
    _avg: PokemonNatureAvgAggregateOutputType | null
    _sum: PokemonNatureSumAggregateOutputType | null
    _min: PokemonNatureMinAggregateOutputType | null
    _max: PokemonNatureMaxAggregateOutputType | null
  }

  export type PokemonNatureAvgAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    nature_id: number | null
  }

  export type PokemonNatureSumAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    nature_id: number | null
  }

  export type PokemonNatureMinAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    nature_id: number | null
  }

  export type PokemonNatureMaxAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    nature_id: number | null
  }

  export type PokemonNatureCountAggregateOutputType = {
    id: number
    pokemon_id: number
    nature_id: number
    _all: number
  }


  export type PokemonNatureAvgAggregateInputType = {
    id?: true
    pokemon_id?: true
    nature_id?: true
  }

  export type PokemonNatureSumAggregateInputType = {
    id?: true
    pokemon_id?: true
    nature_id?: true
  }

  export type PokemonNatureMinAggregateInputType = {
    id?: true
    pokemon_id?: true
    nature_id?: true
  }

  export type PokemonNatureMaxAggregateInputType = {
    id?: true
    pokemon_id?: true
    nature_id?: true
  }

  export type PokemonNatureCountAggregateInputType = {
    id?: true
    pokemon_id?: true
    nature_id?: true
    _all?: true
  }

  export type PokemonNatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PokemonNature to aggregate.
     */
    where?: PokemonNatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonNatures to fetch.
     */
    orderBy?: PokemonNatureOrderByWithRelationInput | PokemonNatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PokemonNatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonNatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonNatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PokemonNatures
    **/
    _count?: true | PokemonNatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PokemonNatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PokemonNatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PokemonNatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PokemonNatureMaxAggregateInputType
  }

  export type GetPokemonNatureAggregateType<T extends PokemonNatureAggregateArgs> = {
        [P in keyof T & keyof AggregatePokemonNature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePokemonNature[P]>
      : GetScalarType<T[P], AggregatePokemonNature[P]>
  }




  export type PokemonNatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonNatureWhereInput
    orderBy?: PokemonNatureOrderByWithAggregationInput | PokemonNatureOrderByWithAggregationInput[]
    by: PokemonNatureScalarFieldEnum[] | PokemonNatureScalarFieldEnum
    having?: PokemonNatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PokemonNatureCountAggregateInputType | true
    _avg?: PokemonNatureAvgAggregateInputType
    _sum?: PokemonNatureSumAggregateInputType
    _min?: PokemonNatureMinAggregateInputType
    _max?: PokemonNatureMaxAggregateInputType
  }

  export type PokemonNatureGroupByOutputType = {
    id: number
    pokemon_id: number
    nature_id: number
    _count: PokemonNatureCountAggregateOutputType | null
    _avg: PokemonNatureAvgAggregateOutputType | null
    _sum: PokemonNatureSumAggregateOutputType | null
    _min: PokemonNatureMinAggregateOutputType | null
    _max: PokemonNatureMaxAggregateOutputType | null
  }

  type GetPokemonNatureGroupByPayload<T extends PokemonNatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PokemonNatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PokemonNatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PokemonNatureGroupByOutputType[P]>
            : GetScalarType<T[P], PokemonNatureGroupByOutputType[P]>
        }
      >
    >


  export type PokemonNatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pokemon_id?: boolean
    nature_id?: boolean
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    nature?: boolean | NatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonNature"]>

  export type PokemonNatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pokemon_id?: boolean
    nature_id?: boolean
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    nature?: boolean | NatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonNature"]>

  export type PokemonNatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pokemon_id?: boolean
    nature_id?: boolean
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    nature?: boolean | NatureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonNature"]>

  export type PokemonNatureSelectScalar = {
    id?: boolean
    pokemon_id?: boolean
    nature_id?: boolean
  }

  export type PokemonNatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pokemon_id" | "nature_id", ExtArgs["result"]["pokemonNature"]>
  export type PokemonNatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    nature?: boolean | NatureDefaultArgs<ExtArgs>
  }
  export type PokemonNatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    nature?: boolean | NatureDefaultArgs<ExtArgs>
  }
  export type PokemonNatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    nature?: boolean | NatureDefaultArgs<ExtArgs>
  }

  export type $PokemonNaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PokemonNature"
    objects: {
      pokemon: Prisma.$PokemonPayload<ExtArgs>
      nature: Prisma.$NaturePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pokemon_id: number
      nature_id: number
    }, ExtArgs["result"]["pokemonNature"]>
    composites: {}
  }

  type PokemonNatureGetPayload<S extends boolean | null | undefined | PokemonNatureDefaultArgs> = $Result.GetResult<Prisma.$PokemonNaturePayload, S>

  type PokemonNatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PokemonNatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PokemonNatureCountAggregateInputType | true
    }

  export interface PokemonNatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PokemonNature'], meta: { name: 'PokemonNature' } }
    /**
     * Find zero or one PokemonNature that matches the filter.
     * @param {PokemonNatureFindUniqueArgs} args - Arguments to find a PokemonNature
     * @example
     * // Get one PokemonNature
     * const pokemonNature = await prisma.pokemonNature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PokemonNatureFindUniqueArgs>(args: SelectSubset<T, PokemonNatureFindUniqueArgs<ExtArgs>>): Prisma__PokemonNatureClient<$Result.GetResult<Prisma.$PokemonNaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PokemonNature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PokemonNatureFindUniqueOrThrowArgs} args - Arguments to find a PokemonNature
     * @example
     * // Get one PokemonNature
     * const pokemonNature = await prisma.pokemonNature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PokemonNatureFindUniqueOrThrowArgs>(args: SelectSubset<T, PokemonNatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PokemonNatureClient<$Result.GetResult<Prisma.$PokemonNaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PokemonNature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonNatureFindFirstArgs} args - Arguments to find a PokemonNature
     * @example
     * // Get one PokemonNature
     * const pokemonNature = await prisma.pokemonNature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PokemonNatureFindFirstArgs>(args?: SelectSubset<T, PokemonNatureFindFirstArgs<ExtArgs>>): Prisma__PokemonNatureClient<$Result.GetResult<Prisma.$PokemonNaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PokemonNature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonNatureFindFirstOrThrowArgs} args - Arguments to find a PokemonNature
     * @example
     * // Get one PokemonNature
     * const pokemonNature = await prisma.pokemonNature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PokemonNatureFindFirstOrThrowArgs>(args?: SelectSubset<T, PokemonNatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__PokemonNatureClient<$Result.GetResult<Prisma.$PokemonNaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PokemonNatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonNatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PokemonNatures
     * const pokemonNatures = await prisma.pokemonNature.findMany()
     * 
     * // Get first 10 PokemonNatures
     * const pokemonNatures = await prisma.pokemonNature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pokemonNatureWithIdOnly = await prisma.pokemonNature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PokemonNatureFindManyArgs>(args?: SelectSubset<T, PokemonNatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonNaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PokemonNature.
     * @param {PokemonNatureCreateArgs} args - Arguments to create a PokemonNature.
     * @example
     * // Create one PokemonNature
     * const PokemonNature = await prisma.pokemonNature.create({
     *   data: {
     *     // ... data to create a PokemonNature
     *   }
     * })
     * 
     */
    create<T extends PokemonNatureCreateArgs>(args: SelectSubset<T, PokemonNatureCreateArgs<ExtArgs>>): Prisma__PokemonNatureClient<$Result.GetResult<Prisma.$PokemonNaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PokemonNatures.
     * @param {PokemonNatureCreateManyArgs} args - Arguments to create many PokemonNatures.
     * @example
     * // Create many PokemonNatures
     * const pokemonNature = await prisma.pokemonNature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PokemonNatureCreateManyArgs>(args?: SelectSubset<T, PokemonNatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PokemonNatures and returns the data saved in the database.
     * @param {PokemonNatureCreateManyAndReturnArgs} args - Arguments to create many PokemonNatures.
     * @example
     * // Create many PokemonNatures
     * const pokemonNature = await prisma.pokemonNature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PokemonNatures and only return the `id`
     * const pokemonNatureWithIdOnly = await prisma.pokemonNature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PokemonNatureCreateManyAndReturnArgs>(args?: SelectSubset<T, PokemonNatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonNaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PokemonNature.
     * @param {PokemonNatureDeleteArgs} args - Arguments to delete one PokemonNature.
     * @example
     * // Delete one PokemonNature
     * const PokemonNature = await prisma.pokemonNature.delete({
     *   where: {
     *     // ... filter to delete one PokemonNature
     *   }
     * })
     * 
     */
    delete<T extends PokemonNatureDeleteArgs>(args: SelectSubset<T, PokemonNatureDeleteArgs<ExtArgs>>): Prisma__PokemonNatureClient<$Result.GetResult<Prisma.$PokemonNaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PokemonNature.
     * @param {PokemonNatureUpdateArgs} args - Arguments to update one PokemonNature.
     * @example
     * // Update one PokemonNature
     * const pokemonNature = await prisma.pokemonNature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PokemonNatureUpdateArgs>(args: SelectSubset<T, PokemonNatureUpdateArgs<ExtArgs>>): Prisma__PokemonNatureClient<$Result.GetResult<Prisma.$PokemonNaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PokemonNatures.
     * @param {PokemonNatureDeleteManyArgs} args - Arguments to filter PokemonNatures to delete.
     * @example
     * // Delete a few PokemonNatures
     * const { count } = await prisma.pokemonNature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PokemonNatureDeleteManyArgs>(args?: SelectSubset<T, PokemonNatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PokemonNatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonNatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PokemonNatures
     * const pokemonNature = await prisma.pokemonNature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PokemonNatureUpdateManyArgs>(args: SelectSubset<T, PokemonNatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PokemonNatures and returns the data updated in the database.
     * @param {PokemonNatureUpdateManyAndReturnArgs} args - Arguments to update many PokemonNatures.
     * @example
     * // Update many PokemonNatures
     * const pokemonNature = await prisma.pokemonNature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PokemonNatures and only return the `id`
     * const pokemonNatureWithIdOnly = await prisma.pokemonNature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PokemonNatureUpdateManyAndReturnArgs>(args: SelectSubset<T, PokemonNatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonNaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PokemonNature.
     * @param {PokemonNatureUpsertArgs} args - Arguments to update or create a PokemonNature.
     * @example
     * // Update or create a PokemonNature
     * const pokemonNature = await prisma.pokemonNature.upsert({
     *   create: {
     *     // ... data to create a PokemonNature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PokemonNature we want to update
     *   }
     * })
     */
    upsert<T extends PokemonNatureUpsertArgs>(args: SelectSubset<T, PokemonNatureUpsertArgs<ExtArgs>>): Prisma__PokemonNatureClient<$Result.GetResult<Prisma.$PokemonNaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PokemonNatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonNatureCountArgs} args - Arguments to filter PokemonNatures to count.
     * @example
     * // Count the number of PokemonNatures
     * const count = await prisma.pokemonNature.count({
     *   where: {
     *     // ... the filter for the PokemonNatures we want to count
     *   }
     * })
    **/
    count<T extends PokemonNatureCountArgs>(
      args?: Subset<T, PokemonNatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PokemonNatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PokemonNature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonNatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PokemonNatureAggregateArgs>(args: Subset<T, PokemonNatureAggregateArgs>): Prisma.PrismaPromise<GetPokemonNatureAggregateType<T>>

    /**
     * Group by PokemonNature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonNatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PokemonNatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PokemonNatureGroupByArgs['orderBy'] }
        : { orderBy?: PokemonNatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PokemonNatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPokemonNatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PokemonNature model
   */
  readonly fields: PokemonNatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PokemonNature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PokemonNatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pokemon<T extends PokemonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PokemonDefaultArgs<ExtArgs>>): Prisma__PokemonClient<$Result.GetResult<Prisma.$PokemonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    nature<T extends NatureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NatureDefaultArgs<ExtArgs>>): Prisma__NatureClient<$Result.GetResult<Prisma.$NaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PokemonNature model
   */
  interface PokemonNatureFieldRefs {
    readonly id: FieldRef<"PokemonNature", 'Int'>
    readonly pokemon_id: FieldRef<"PokemonNature", 'Int'>
    readonly nature_id: FieldRef<"PokemonNature", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PokemonNature findUnique
   */
  export type PokemonNatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonNature
     */
    select?: PokemonNatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonNature
     */
    omit?: PokemonNatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonNatureInclude<ExtArgs> | null
    /**
     * Filter, which PokemonNature to fetch.
     */
    where: PokemonNatureWhereUniqueInput
  }

  /**
   * PokemonNature findUniqueOrThrow
   */
  export type PokemonNatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonNature
     */
    select?: PokemonNatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonNature
     */
    omit?: PokemonNatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonNatureInclude<ExtArgs> | null
    /**
     * Filter, which PokemonNature to fetch.
     */
    where: PokemonNatureWhereUniqueInput
  }

  /**
   * PokemonNature findFirst
   */
  export type PokemonNatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonNature
     */
    select?: PokemonNatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonNature
     */
    omit?: PokemonNatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonNatureInclude<ExtArgs> | null
    /**
     * Filter, which PokemonNature to fetch.
     */
    where?: PokemonNatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonNatures to fetch.
     */
    orderBy?: PokemonNatureOrderByWithRelationInput | PokemonNatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PokemonNatures.
     */
    cursor?: PokemonNatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonNatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonNatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PokemonNatures.
     */
    distinct?: PokemonNatureScalarFieldEnum | PokemonNatureScalarFieldEnum[]
  }

  /**
   * PokemonNature findFirstOrThrow
   */
  export type PokemonNatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonNature
     */
    select?: PokemonNatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonNature
     */
    omit?: PokemonNatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonNatureInclude<ExtArgs> | null
    /**
     * Filter, which PokemonNature to fetch.
     */
    where?: PokemonNatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonNatures to fetch.
     */
    orderBy?: PokemonNatureOrderByWithRelationInput | PokemonNatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PokemonNatures.
     */
    cursor?: PokemonNatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonNatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonNatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PokemonNatures.
     */
    distinct?: PokemonNatureScalarFieldEnum | PokemonNatureScalarFieldEnum[]
  }

  /**
   * PokemonNature findMany
   */
  export type PokemonNatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonNature
     */
    select?: PokemonNatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonNature
     */
    omit?: PokemonNatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonNatureInclude<ExtArgs> | null
    /**
     * Filter, which PokemonNatures to fetch.
     */
    where?: PokemonNatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonNatures to fetch.
     */
    orderBy?: PokemonNatureOrderByWithRelationInput | PokemonNatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PokemonNatures.
     */
    cursor?: PokemonNatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonNatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonNatures.
     */
    skip?: number
    distinct?: PokemonNatureScalarFieldEnum | PokemonNatureScalarFieldEnum[]
  }

  /**
   * PokemonNature create
   */
  export type PokemonNatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonNature
     */
    select?: PokemonNatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonNature
     */
    omit?: PokemonNatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonNatureInclude<ExtArgs> | null
    /**
     * The data needed to create a PokemonNature.
     */
    data: XOR<PokemonNatureCreateInput, PokemonNatureUncheckedCreateInput>
  }

  /**
   * PokemonNature createMany
   */
  export type PokemonNatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PokemonNatures.
     */
    data: PokemonNatureCreateManyInput | PokemonNatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PokemonNature createManyAndReturn
   */
  export type PokemonNatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonNature
     */
    select?: PokemonNatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonNature
     */
    omit?: PokemonNatureOmit<ExtArgs> | null
    /**
     * The data used to create many PokemonNatures.
     */
    data: PokemonNatureCreateManyInput | PokemonNatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonNatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PokemonNature update
   */
  export type PokemonNatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonNature
     */
    select?: PokemonNatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonNature
     */
    omit?: PokemonNatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonNatureInclude<ExtArgs> | null
    /**
     * The data needed to update a PokemonNature.
     */
    data: XOR<PokemonNatureUpdateInput, PokemonNatureUncheckedUpdateInput>
    /**
     * Choose, which PokemonNature to update.
     */
    where: PokemonNatureWhereUniqueInput
  }

  /**
   * PokemonNature updateMany
   */
  export type PokemonNatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PokemonNatures.
     */
    data: XOR<PokemonNatureUpdateManyMutationInput, PokemonNatureUncheckedUpdateManyInput>
    /**
     * Filter which PokemonNatures to update
     */
    where?: PokemonNatureWhereInput
    /**
     * Limit how many PokemonNatures to update.
     */
    limit?: number
  }

  /**
   * PokemonNature updateManyAndReturn
   */
  export type PokemonNatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonNature
     */
    select?: PokemonNatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonNature
     */
    omit?: PokemonNatureOmit<ExtArgs> | null
    /**
     * The data used to update PokemonNatures.
     */
    data: XOR<PokemonNatureUpdateManyMutationInput, PokemonNatureUncheckedUpdateManyInput>
    /**
     * Filter which PokemonNatures to update
     */
    where?: PokemonNatureWhereInput
    /**
     * Limit how many PokemonNatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonNatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PokemonNature upsert
   */
  export type PokemonNatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonNature
     */
    select?: PokemonNatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonNature
     */
    omit?: PokemonNatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonNatureInclude<ExtArgs> | null
    /**
     * The filter to search for the PokemonNature to update in case it exists.
     */
    where: PokemonNatureWhereUniqueInput
    /**
     * In case the PokemonNature found by the `where` argument doesn't exist, create a new PokemonNature with this data.
     */
    create: XOR<PokemonNatureCreateInput, PokemonNatureUncheckedCreateInput>
    /**
     * In case the PokemonNature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PokemonNatureUpdateInput, PokemonNatureUncheckedUpdateInput>
  }

  /**
   * PokemonNature delete
   */
  export type PokemonNatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonNature
     */
    select?: PokemonNatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonNature
     */
    omit?: PokemonNatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonNatureInclude<ExtArgs> | null
    /**
     * Filter which PokemonNature to delete.
     */
    where: PokemonNatureWhereUniqueInput
  }

  /**
   * PokemonNature deleteMany
   */
  export type PokemonNatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PokemonNatures to delete
     */
    where?: PokemonNatureWhereInput
    /**
     * Limit how many PokemonNatures to delete.
     */
    limit?: number
  }

  /**
   * PokemonNature without action
   */
  export type PokemonNatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonNature
     */
    select?: PokemonNatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonNature
     */
    omit?: PokemonNatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonNatureInclude<ExtArgs> | null
  }


  /**
   * Model Stat
   */

  export type AggregateStat = {
    _count: StatCountAggregateOutputType | null
    _avg: StatAvgAggregateOutputType | null
    _sum: StatSumAggregateOutputType | null
    _min: StatMinAggregateOutputType | null
    _max: StatMaxAggregateOutputType | null
  }

  export type StatAvgAggregateOutputType = {
    id: number | null
  }

  export type StatSumAggregateOutputType = {
    id: number | null
  }

  export type StatMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type StatMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type StatCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type StatAvgAggregateInputType = {
    id?: true
  }

  export type StatSumAggregateInputType = {
    id?: true
  }

  export type StatMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type StatMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type StatCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type StatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stat to aggregate.
     */
    where?: StatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stats to fetch.
     */
    orderBy?: StatOrderByWithRelationInput | StatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stats
    **/
    _count?: true | StatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatMaxAggregateInputType
  }

  export type GetStatAggregateType<T extends StatAggregateArgs> = {
        [P in keyof T & keyof AggregateStat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStat[P]>
      : GetScalarType<T[P], AggregateStat[P]>
  }




  export type StatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatWhereInput
    orderBy?: StatOrderByWithAggregationInput | StatOrderByWithAggregationInput[]
    by: StatScalarFieldEnum[] | StatScalarFieldEnum
    having?: StatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatCountAggregateInputType | true
    _avg?: StatAvgAggregateInputType
    _sum?: StatSumAggregateInputType
    _min?: StatMinAggregateInputType
    _max?: StatMaxAggregateInputType
  }

  export type StatGroupByOutputType = {
    id: number
    name: string
    _count: StatCountAggregateOutputType | null
    _avg: StatAvgAggregateOutputType | null
    _sum: StatSumAggregateOutputType | null
    _min: StatMinAggregateOutputType | null
    _max: StatMaxAggregateOutputType | null
  }

  type GetStatGroupByPayload<T extends StatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatGroupByOutputType[P]>
            : GetScalarType<T[P], StatGroupByOutputType[P]>
        }
      >
    >


  export type StatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    natures_increase?: boolean | Stat$natures_increaseArgs<ExtArgs>
    natures_decrease?: boolean | Stat$natures_decreaseArgs<ExtArgs>
    pokemon_stats?: boolean | Stat$pokemon_statsArgs<ExtArgs>
    _count?: boolean | StatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stat"]>

  export type StatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["stat"]>

  export type StatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["stat"]>

  export type StatSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type StatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["stat"]>
  export type StatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    natures_increase?: boolean | Stat$natures_increaseArgs<ExtArgs>
    natures_decrease?: boolean | Stat$natures_decreaseArgs<ExtArgs>
    pokemon_stats?: boolean | Stat$pokemon_statsArgs<ExtArgs>
    _count?: boolean | StatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stat"
    objects: {
      natures_increase: Prisma.$NaturePayload<ExtArgs>[]
      natures_decrease: Prisma.$NaturePayload<ExtArgs>[]
      pokemon_stats: Prisma.$PokemonStatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["stat"]>
    composites: {}
  }

  type StatGetPayload<S extends boolean | null | undefined | StatDefaultArgs> = $Result.GetResult<Prisma.$StatPayload, S>

  type StatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StatCountAggregateInputType | true
    }

  export interface StatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stat'], meta: { name: 'Stat' } }
    /**
     * Find zero or one Stat that matches the filter.
     * @param {StatFindUniqueArgs} args - Arguments to find a Stat
     * @example
     * // Get one Stat
     * const stat = await prisma.stat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatFindUniqueArgs>(args: SelectSubset<T, StatFindUniqueArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StatFindUniqueOrThrowArgs} args - Arguments to find a Stat
     * @example
     * // Get one Stat
     * const stat = await prisma.stat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatFindUniqueOrThrowArgs>(args: SelectSubset<T, StatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatFindFirstArgs} args - Arguments to find a Stat
     * @example
     * // Get one Stat
     * const stat = await prisma.stat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatFindFirstArgs>(args?: SelectSubset<T, StatFindFirstArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatFindFirstOrThrowArgs} args - Arguments to find a Stat
     * @example
     * // Get one Stat
     * const stat = await prisma.stat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatFindFirstOrThrowArgs>(args?: SelectSubset<T, StatFindFirstOrThrowArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stats
     * const stats = await prisma.stat.findMany()
     * 
     * // Get first 10 Stats
     * const stats = await prisma.stat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statWithIdOnly = await prisma.stat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StatFindManyArgs>(args?: SelectSubset<T, StatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stat.
     * @param {StatCreateArgs} args - Arguments to create a Stat.
     * @example
     * // Create one Stat
     * const Stat = await prisma.stat.create({
     *   data: {
     *     // ... data to create a Stat
     *   }
     * })
     * 
     */
    create<T extends StatCreateArgs>(args: SelectSubset<T, StatCreateArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stats.
     * @param {StatCreateManyArgs} args - Arguments to create many Stats.
     * @example
     * // Create many Stats
     * const stat = await prisma.stat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StatCreateManyArgs>(args?: SelectSubset<T, StatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stats and returns the data saved in the database.
     * @param {StatCreateManyAndReturnArgs} args - Arguments to create many Stats.
     * @example
     * // Create many Stats
     * const stat = await prisma.stat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stats and only return the `id`
     * const statWithIdOnly = await prisma.stat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StatCreateManyAndReturnArgs>(args?: SelectSubset<T, StatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Stat.
     * @param {StatDeleteArgs} args - Arguments to delete one Stat.
     * @example
     * // Delete one Stat
     * const Stat = await prisma.stat.delete({
     *   where: {
     *     // ... filter to delete one Stat
     *   }
     * })
     * 
     */
    delete<T extends StatDeleteArgs>(args: SelectSubset<T, StatDeleteArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stat.
     * @param {StatUpdateArgs} args - Arguments to update one Stat.
     * @example
     * // Update one Stat
     * const stat = await prisma.stat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StatUpdateArgs>(args: SelectSubset<T, StatUpdateArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stats.
     * @param {StatDeleteManyArgs} args - Arguments to filter Stats to delete.
     * @example
     * // Delete a few Stats
     * const { count } = await prisma.stat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StatDeleteManyArgs>(args?: SelectSubset<T, StatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stats
     * const stat = await prisma.stat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StatUpdateManyArgs>(args: SelectSubset<T, StatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stats and returns the data updated in the database.
     * @param {StatUpdateManyAndReturnArgs} args - Arguments to update many Stats.
     * @example
     * // Update many Stats
     * const stat = await prisma.stat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stats and only return the `id`
     * const statWithIdOnly = await prisma.stat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StatUpdateManyAndReturnArgs>(args: SelectSubset<T, StatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Stat.
     * @param {StatUpsertArgs} args - Arguments to update or create a Stat.
     * @example
     * // Update or create a Stat
     * const stat = await prisma.stat.upsert({
     *   create: {
     *     // ... data to create a Stat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stat we want to update
     *   }
     * })
     */
    upsert<T extends StatUpsertArgs>(args: SelectSubset<T, StatUpsertArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatCountArgs} args - Arguments to filter Stats to count.
     * @example
     * // Count the number of Stats
     * const count = await prisma.stat.count({
     *   where: {
     *     // ... the filter for the Stats we want to count
     *   }
     * })
    **/
    count<T extends StatCountArgs>(
      args?: Subset<T, StatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatAggregateArgs>(args: Subset<T, StatAggregateArgs>): Prisma.PrismaPromise<GetStatAggregateType<T>>

    /**
     * Group by Stat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatGroupByArgs['orderBy'] }
        : { orderBy?: StatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stat model
   */
  readonly fields: StatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    natures_increase<T extends Stat$natures_increaseArgs<ExtArgs> = {}>(args?: Subset<T, Stat$natures_increaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    natures_decrease<T extends Stat$natures_decreaseArgs<ExtArgs> = {}>(args?: Subset<T, Stat$natures_decreaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pokemon_stats<T extends Stat$pokemon_statsArgs<ExtArgs> = {}>(args?: Subset<T, Stat$pokemon_statsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonStatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stat model
   */
  interface StatFieldRefs {
    readonly id: FieldRef<"Stat", 'Int'>
    readonly name: FieldRef<"Stat", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Stat findUnique
   */
  export type StatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * Filter, which Stat to fetch.
     */
    where: StatWhereUniqueInput
  }

  /**
   * Stat findUniqueOrThrow
   */
  export type StatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * Filter, which Stat to fetch.
     */
    where: StatWhereUniqueInput
  }

  /**
   * Stat findFirst
   */
  export type StatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * Filter, which Stat to fetch.
     */
    where?: StatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stats to fetch.
     */
    orderBy?: StatOrderByWithRelationInput | StatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stats.
     */
    cursor?: StatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stats.
     */
    distinct?: StatScalarFieldEnum | StatScalarFieldEnum[]
  }

  /**
   * Stat findFirstOrThrow
   */
  export type StatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * Filter, which Stat to fetch.
     */
    where?: StatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stats to fetch.
     */
    orderBy?: StatOrderByWithRelationInput | StatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stats.
     */
    cursor?: StatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stats.
     */
    distinct?: StatScalarFieldEnum | StatScalarFieldEnum[]
  }

  /**
   * Stat findMany
   */
  export type StatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * Filter, which Stats to fetch.
     */
    where?: StatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stats to fetch.
     */
    orderBy?: StatOrderByWithRelationInput | StatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stats.
     */
    cursor?: StatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stats.
     */
    skip?: number
    distinct?: StatScalarFieldEnum | StatScalarFieldEnum[]
  }

  /**
   * Stat create
   */
  export type StatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * The data needed to create a Stat.
     */
    data: XOR<StatCreateInput, StatUncheckedCreateInput>
  }

  /**
   * Stat createMany
   */
  export type StatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stats.
     */
    data: StatCreateManyInput | StatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stat createManyAndReturn
   */
  export type StatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * The data used to create many Stats.
     */
    data: StatCreateManyInput | StatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stat update
   */
  export type StatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * The data needed to update a Stat.
     */
    data: XOR<StatUpdateInput, StatUncheckedUpdateInput>
    /**
     * Choose, which Stat to update.
     */
    where: StatWhereUniqueInput
  }

  /**
   * Stat updateMany
   */
  export type StatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stats.
     */
    data: XOR<StatUpdateManyMutationInput, StatUncheckedUpdateManyInput>
    /**
     * Filter which Stats to update
     */
    where?: StatWhereInput
    /**
     * Limit how many Stats to update.
     */
    limit?: number
  }

  /**
   * Stat updateManyAndReturn
   */
  export type StatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * The data used to update Stats.
     */
    data: XOR<StatUpdateManyMutationInput, StatUncheckedUpdateManyInput>
    /**
     * Filter which Stats to update
     */
    where?: StatWhereInput
    /**
     * Limit how many Stats to update.
     */
    limit?: number
  }

  /**
   * Stat upsert
   */
  export type StatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * The filter to search for the Stat to update in case it exists.
     */
    where: StatWhereUniqueInput
    /**
     * In case the Stat found by the `where` argument doesn't exist, create a new Stat with this data.
     */
    create: XOR<StatCreateInput, StatUncheckedCreateInput>
    /**
     * In case the Stat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatUpdateInput, StatUncheckedUpdateInput>
  }

  /**
   * Stat delete
   */
  export type StatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
    /**
     * Filter which Stat to delete.
     */
    where: StatWhereUniqueInput
  }

  /**
   * Stat deleteMany
   */
  export type StatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stats to delete
     */
    where?: StatWhereInput
    /**
     * Limit how many Stats to delete.
     */
    limit?: number
  }

  /**
   * Stat.natures_increase
   */
  export type Stat$natures_increaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nature
     */
    select?: NatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nature
     */
    omit?: NatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureInclude<ExtArgs> | null
    where?: NatureWhereInput
    orderBy?: NatureOrderByWithRelationInput | NatureOrderByWithRelationInput[]
    cursor?: NatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NatureScalarFieldEnum | NatureScalarFieldEnum[]
  }

  /**
   * Stat.natures_decrease
   */
  export type Stat$natures_decreaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nature
     */
    select?: NatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Nature
     */
    omit?: NatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NatureInclude<ExtArgs> | null
    where?: NatureWhereInput
    orderBy?: NatureOrderByWithRelationInput | NatureOrderByWithRelationInput[]
    cursor?: NatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NatureScalarFieldEnum | NatureScalarFieldEnum[]
  }

  /**
   * Stat.pokemon_stats
   */
  export type Stat$pokemon_statsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonStat
     */
    select?: PokemonStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonStat
     */
    omit?: PokemonStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonStatInclude<ExtArgs> | null
    where?: PokemonStatWhereInput
    orderBy?: PokemonStatOrderByWithRelationInput | PokemonStatOrderByWithRelationInput[]
    cursor?: PokemonStatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokemonStatScalarFieldEnum | PokemonStatScalarFieldEnum[]
  }

  /**
   * Stat without action
   */
  export type StatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stat
     */
    select?: StatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stat
     */
    omit?: StatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatInclude<ExtArgs> | null
  }


  /**
   * Model PokemonStat
   */

  export type AggregatePokemonStat = {
    _count: PokemonStatCountAggregateOutputType | null
    _avg: PokemonStatAvgAggregateOutputType | null
    _sum: PokemonStatSumAggregateOutputType | null
    _min: PokemonStatMinAggregateOutputType | null
    _max: PokemonStatMaxAggregateOutputType | null
  }

  export type PokemonStatAvgAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    stat_id: number | null
    base_stat: number | null
  }

  export type PokemonStatSumAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    stat_id: number | null
    base_stat: number | null
  }

  export type PokemonStatMinAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    stat_id: number | null
    base_stat: number | null
  }

  export type PokemonStatMaxAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    stat_id: number | null
    base_stat: number | null
  }

  export type PokemonStatCountAggregateOutputType = {
    id: number
    pokemon_id: number
    stat_id: number
    base_stat: number
    _all: number
  }


  export type PokemonStatAvgAggregateInputType = {
    id?: true
    pokemon_id?: true
    stat_id?: true
    base_stat?: true
  }

  export type PokemonStatSumAggregateInputType = {
    id?: true
    pokemon_id?: true
    stat_id?: true
    base_stat?: true
  }

  export type PokemonStatMinAggregateInputType = {
    id?: true
    pokemon_id?: true
    stat_id?: true
    base_stat?: true
  }

  export type PokemonStatMaxAggregateInputType = {
    id?: true
    pokemon_id?: true
    stat_id?: true
    base_stat?: true
  }

  export type PokemonStatCountAggregateInputType = {
    id?: true
    pokemon_id?: true
    stat_id?: true
    base_stat?: true
    _all?: true
  }

  export type PokemonStatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PokemonStat to aggregate.
     */
    where?: PokemonStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonStats to fetch.
     */
    orderBy?: PokemonStatOrderByWithRelationInput | PokemonStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PokemonStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PokemonStats
    **/
    _count?: true | PokemonStatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PokemonStatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PokemonStatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PokemonStatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PokemonStatMaxAggregateInputType
  }

  export type GetPokemonStatAggregateType<T extends PokemonStatAggregateArgs> = {
        [P in keyof T & keyof AggregatePokemonStat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePokemonStat[P]>
      : GetScalarType<T[P], AggregatePokemonStat[P]>
  }




  export type PokemonStatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonStatWhereInput
    orderBy?: PokemonStatOrderByWithAggregationInput | PokemonStatOrderByWithAggregationInput[]
    by: PokemonStatScalarFieldEnum[] | PokemonStatScalarFieldEnum
    having?: PokemonStatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PokemonStatCountAggregateInputType | true
    _avg?: PokemonStatAvgAggregateInputType
    _sum?: PokemonStatSumAggregateInputType
    _min?: PokemonStatMinAggregateInputType
    _max?: PokemonStatMaxAggregateInputType
  }

  export type PokemonStatGroupByOutputType = {
    id: number
    pokemon_id: number
    stat_id: number
    base_stat: number
    _count: PokemonStatCountAggregateOutputType | null
    _avg: PokemonStatAvgAggregateOutputType | null
    _sum: PokemonStatSumAggregateOutputType | null
    _min: PokemonStatMinAggregateOutputType | null
    _max: PokemonStatMaxAggregateOutputType | null
  }

  type GetPokemonStatGroupByPayload<T extends PokemonStatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PokemonStatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PokemonStatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PokemonStatGroupByOutputType[P]>
            : GetScalarType<T[P], PokemonStatGroupByOutputType[P]>
        }
      >
    >


  export type PokemonStatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pokemon_id?: boolean
    stat_id?: boolean
    base_stat?: boolean
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    stat?: boolean | StatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonStat"]>

  export type PokemonStatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pokemon_id?: boolean
    stat_id?: boolean
    base_stat?: boolean
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    stat?: boolean | StatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonStat"]>

  export type PokemonStatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pokemon_id?: boolean
    stat_id?: boolean
    base_stat?: boolean
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    stat?: boolean | StatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonStat"]>

  export type PokemonStatSelectScalar = {
    id?: boolean
    pokemon_id?: boolean
    stat_id?: boolean
    base_stat?: boolean
  }

  export type PokemonStatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pokemon_id" | "stat_id" | "base_stat", ExtArgs["result"]["pokemonStat"]>
  export type PokemonStatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    stat?: boolean | StatDefaultArgs<ExtArgs>
  }
  export type PokemonStatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    stat?: boolean | StatDefaultArgs<ExtArgs>
  }
  export type PokemonStatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    stat?: boolean | StatDefaultArgs<ExtArgs>
  }

  export type $PokemonStatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PokemonStat"
    objects: {
      pokemon: Prisma.$PokemonPayload<ExtArgs>
      stat: Prisma.$StatPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pokemon_id: number
      stat_id: number
      base_stat: number
    }, ExtArgs["result"]["pokemonStat"]>
    composites: {}
  }

  type PokemonStatGetPayload<S extends boolean | null | undefined | PokemonStatDefaultArgs> = $Result.GetResult<Prisma.$PokemonStatPayload, S>

  type PokemonStatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PokemonStatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PokemonStatCountAggregateInputType | true
    }

  export interface PokemonStatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PokemonStat'], meta: { name: 'PokemonStat' } }
    /**
     * Find zero or one PokemonStat that matches the filter.
     * @param {PokemonStatFindUniqueArgs} args - Arguments to find a PokemonStat
     * @example
     * // Get one PokemonStat
     * const pokemonStat = await prisma.pokemonStat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PokemonStatFindUniqueArgs>(args: SelectSubset<T, PokemonStatFindUniqueArgs<ExtArgs>>): Prisma__PokemonStatClient<$Result.GetResult<Prisma.$PokemonStatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PokemonStat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PokemonStatFindUniqueOrThrowArgs} args - Arguments to find a PokemonStat
     * @example
     * // Get one PokemonStat
     * const pokemonStat = await prisma.pokemonStat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PokemonStatFindUniqueOrThrowArgs>(args: SelectSubset<T, PokemonStatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PokemonStatClient<$Result.GetResult<Prisma.$PokemonStatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PokemonStat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonStatFindFirstArgs} args - Arguments to find a PokemonStat
     * @example
     * // Get one PokemonStat
     * const pokemonStat = await prisma.pokemonStat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PokemonStatFindFirstArgs>(args?: SelectSubset<T, PokemonStatFindFirstArgs<ExtArgs>>): Prisma__PokemonStatClient<$Result.GetResult<Prisma.$PokemonStatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PokemonStat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonStatFindFirstOrThrowArgs} args - Arguments to find a PokemonStat
     * @example
     * // Get one PokemonStat
     * const pokemonStat = await prisma.pokemonStat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PokemonStatFindFirstOrThrowArgs>(args?: SelectSubset<T, PokemonStatFindFirstOrThrowArgs<ExtArgs>>): Prisma__PokemonStatClient<$Result.GetResult<Prisma.$PokemonStatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PokemonStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonStatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PokemonStats
     * const pokemonStats = await prisma.pokemonStat.findMany()
     * 
     * // Get first 10 PokemonStats
     * const pokemonStats = await prisma.pokemonStat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pokemonStatWithIdOnly = await prisma.pokemonStat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PokemonStatFindManyArgs>(args?: SelectSubset<T, PokemonStatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonStatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PokemonStat.
     * @param {PokemonStatCreateArgs} args - Arguments to create a PokemonStat.
     * @example
     * // Create one PokemonStat
     * const PokemonStat = await prisma.pokemonStat.create({
     *   data: {
     *     // ... data to create a PokemonStat
     *   }
     * })
     * 
     */
    create<T extends PokemonStatCreateArgs>(args: SelectSubset<T, PokemonStatCreateArgs<ExtArgs>>): Prisma__PokemonStatClient<$Result.GetResult<Prisma.$PokemonStatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PokemonStats.
     * @param {PokemonStatCreateManyArgs} args - Arguments to create many PokemonStats.
     * @example
     * // Create many PokemonStats
     * const pokemonStat = await prisma.pokemonStat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PokemonStatCreateManyArgs>(args?: SelectSubset<T, PokemonStatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PokemonStats and returns the data saved in the database.
     * @param {PokemonStatCreateManyAndReturnArgs} args - Arguments to create many PokemonStats.
     * @example
     * // Create many PokemonStats
     * const pokemonStat = await prisma.pokemonStat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PokemonStats and only return the `id`
     * const pokemonStatWithIdOnly = await prisma.pokemonStat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PokemonStatCreateManyAndReturnArgs>(args?: SelectSubset<T, PokemonStatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonStatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PokemonStat.
     * @param {PokemonStatDeleteArgs} args - Arguments to delete one PokemonStat.
     * @example
     * // Delete one PokemonStat
     * const PokemonStat = await prisma.pokemonStat.delete({
     *   where: {
     *     // ... filter to delete one PokemonStat
     *   }
     * })
     * 
     */
    delete<T extends PokemonStatDeleteArgs>(args: SelectSubset<T, PokemonStatDeleteArgs<ExtArgs>>): Prisma__PokemonStatClient<$Result.GetResult<Prisma.$PokemonStatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PokemonStat.
     * @param {PokemonStatUpdateArgs} args - Arguments to update one PokemonStat.
     * @example
     * // Update one PokemonStat
     * const pokemonStat = await prisma.pokemonStat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PokemonStatUpdateArgs>(args: SelectSubset<T, PokemonStatUpdateArgs<ExtArgs>>): Prisma__PokemonStatClient<$Result.GetResult<Prisma.$PokemonStatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PokemonStats.
     * @param {PokemonStatDeleteManyArgs} args - Arguments to filter PokemonStats to delete.
     * @example
     * // Delete a few PokemonStats
     * const { count } = await prisma.pokemonStat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PokemonStatDeleteManyArgs>(args?: SelectSubset<T, PokemonStatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PokemonStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonStatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PokemonStats
     * const pokemonStat = await prisma.pokemonStat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PokemonStatUpdateManyArgs>(args: SelectSubset<T, PokemonStatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PokemonStats and returns the data updated in the database.
     * @param {PokemonStatUpdateManyAndReturnArgs} args - Arguments to update many PokemonStats.
     * @example
     * // Update many PokemonStats
     * const pokemonStat = await prisma.pokemonStat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PokemonStats and only return the `id`
     * const pokemonStatWithIdOnly = await prisma.pokemonStat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PokemonStatUpdateManyAndReturnArgs>(args: SelectSubset<T, PokemonStatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonStatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PokemonStat.
     * @param {PokemonStatUpsertArgs} args - Arguments to update or create a PokemonStat.
     * @example
     * // Update or create a PokemonStat
     * const pokemonStat = await prisma.pokemonStat.upsert({
     *   create: {
     *     // ... data to create a PokemonStat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PokemonStat we want to update
     *   }
     * })
     */
    upsert<T extends PokemonStatUpsertArgs>(args: SelectSubset<T, PokemonStatUpsertArgs<ExtArgs>>): Prisma__PokemonStatClient<$Result.GetResult<Prisma.$PokemonStatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PokemonStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonStatCountArgs} args - Arguments to filter PokemonStats to count.
     * @example
     * // Count the number of PokemonStats
     * const count = await prisma.pokemonStat.count({
     *   where: {
     *     // ... the filter for the PokemonStats we want to count
     *   }
     * })
    **/
    count<T extends PokemonStatCountArgs>(
      args?: Subset<T, PokemonStatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PokemonStatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PokemonStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonStatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PokemonStatAggregateArgs>(args: Subset<T, PokemonStatAggregateArgs>): Prisma.PrismaPromise<GetPokemonStatAggregateType<T>>

    /**
     * Group by PokemonStat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonStatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PokemonStatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PokemonStatGroupByArgs['orderBy'] }
        : { orderBy?: PokemonStatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PokemonStatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPokemonStatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PokemonStat model
   */
  readonly fields: PokemonStatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PokemonStat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PokemonStatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pokemon<T extends PokemonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PokemonDefaultArgs<ExtArgs>>): Prisma__PokemonClient<$Result.GetResult<Prisma.$PokemonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stat<T extends StatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StatDefaultArgs<ExtArgs>>): Prisma__StatClient<$Result.GetResult<Prisma.$StatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PokemonStat model
   */
  interface PokemonStatFieldRefs {
    readonly id: FieldRef<"PokemonStat", 'Int'>
    readonly pokemon_id: FieldRef<"PokemonStat", 'Int'>
    readonly stat_id: FieldRef<"PokemonStat", 'Int'>
    readonly base_stat: FieldRef<"PokemonStat", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PokemonStat findUnique
   */
  export type PokemonStatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonStat
     */
    select?: PokemonStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonStat
     */
    omit?: PokemonStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonStatInclude<ExtArgs> | null
    /**
     * Filter, which PokemonStat to fetch.
     */
    where: PokemonStatWhereUniqueInput
  }

  /**
   * PokemonStat findUniqueOrThrow
   */
  export type PokemonStatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonStat
     */
    select?: PokemonStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonStat
     */
    omit?: PokemonStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonStatInclude<ExtArgs> | null
    /**
     * Filter, which PokemonStat to fetch.
     */
    where: PokemonStatWhereUniqueInput
  }

  /**
   * PokemonStat findFirst
   */
  export type PokemonStatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonStat
     */
    select?: PokemonStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonStat
     */
    omit?: PokemonStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonStatInclude<ExtArgs> | null
    /**
     * Filter, which PokemonStat to fetch.
     */
    where?: PokemonStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonStats to fetch.
     */
    orderBy?: PokemonStatOrderByWithRelationInput | PokemonStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PokemonStats.
     */
    cursor?: PokemonStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PokemonStats.
     */
    distinct?: PokemonStatScalarFieldEnum | PokemonStatScalarFieldEnum[]
  }

  /**
   * PokemonStat findFirstOrThrow
   */
  export type PokemonStatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonStat
     */
    select?: PokemonStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonStat
     */
    omit?: PokemonStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonStatInclude<ExtArgs> | null
    /**
     * Filter, which PokemonStat to fetch.
     */
    where?: PokemonStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonStats to fetch.
     */
    orderBy?: PokemonStatOrderByWithRelationInput | PokemonStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PokemonStats.
     */
    cursor?: PokemonStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PokemonStats.
     */
    distinct?: PokemonStatScalarFieldEnum | PokemonStatScalarFieldEnum[]
  }

  /**
   * PokemonStat findMany
   */
  export type PokemonStatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonStat
     */
    select?: PokemonStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonStat
     */
    omit?: PokemonStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonStatInclude<ExtArgs> | null
    /**
     * Filter, which PokemonStats to fetch.
     */
    where?: PokemonStatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonStats to fetch.
     */
    orderBy?: PokemonStatOrderByWithRelationInput | PokemonStatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PokemonStats.
     */
    cursor?: PokemonStatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonStats.
     */
    skip?: number
    distinct?: PokemonStatScalarFieldEnum | PokemonStatScalarFieldEnum[]
  }

  /**
   * PokemonStat create
   */
  export type PokemonStatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonStat
     */
    select?: PokemonStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonStat
     */
    omit?: PokemonStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonStatInclude<ExtArgs> | null
    /**
     * The data needed to create a PokemonStat.
     */
    data: XOR<PokemonStatCreateInput, PokemonStatUncheckedCreateInput>
  }

  /**
   * PokemonStat createMany
   */
  export type PokemonStatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PokemonStats.
     */
    data: PokemonStatCreateManyInput | PokemonStatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PokemonStat createManyAndReturn
   */
  export type PokemonStatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonStat
     */
    select?: PokemonStatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonStat
     */
    omit?: PokemonStatOmit<ExtArgs> | null
    /**
     * The data used to create many PokemonStats.
     */
    data: PokemonStatCreateManyInput | PokemonStatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonStatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PokemonStat update
   */
  export type PokemonStatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonStat
     */
    select?: PokemonStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonStat
     */
    omit?: PokemonStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonStatInclude<ExtArgs> | null
    /**
     * The data needed to update a PokemonStat.
     */
    data: XOR<PokemonStatUpdateInput, PokemonStatUncheckedUpdateInput>
    /**
     * Choose, which PokemonStat to update.
     */
    where: PokemonStatWhereUniqueInput
  }

  /**
   * PokemonStat updateMany
   */
  export type PokemonStatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PokemonStats.
     */
    data: XOR<PokemonStatUpdateManyMutationInput, PokemonStatUncheckedUpdateManyInput>
    /**
     * Filter which PokemonStats to update
     */
    where?: PokemonStatWhereInput
    /**
     * Limit how many PokemonStats to update.
     */
    limit?: number
  }

  /**
   * PokemonStat updateManyAndReturn
   */
  export type PokemonStatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonStat
     */
    select?: PokemonStatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonStat
     */
    omit?: PokemonStatOmit<ExtArgs> | null
    /**
     * The data used to update PokemonStats.
     */
    data: XOR<PokemonStatUpdateManyMutationInput, PokemonStatUncheckedUpdateManyInput>
    /**
     * Filter which PokemonStats to update
     */
    where?: PokemonStatWhereInput
    /**
     * Limit how many PokemonStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonStatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PokemonStat upsert
   */
  export type PokemonStatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonStat
     */
    select?: PokemonStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonStat
     */
    omit?: PokemonStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonStatInclude<ExtArgs> | null
    /**
     * The filter to search for the PokemonStat to update in case it exists.
     */
    where: PokemonStatWhereUniqueInput
    /**
     * In case the PokemonStat found by the `where` argument doesn't exist, create a new PokemonStat with this data.
     */
    create: XOR<PokemonStatCreateInput, PokemonStatUncheckedCreateInput>
    /**
     * In case the PokemonStat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PokemonStatUpdateInput, PokemonStatUncheckedUpdateInput>
  }

  /**
   * PokemonStat delete
   */
  export type PokemonStatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonStat
     */
    select?: PokemonStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonStat
     */
    omit?: PokemonStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonStatInclude<ExtArgs> | null
    /**
     * Filter which PokemonStat to delete.
     */
    where: PokemonStatWhereUniqueInput
  }

  /**
   * PokemonStat deleteMany
   */
  export type PokemonStatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PokemonStats to delete
     */
    where?: PokemonStatWhereInput
    /**
     * Limit how many PokemonStats to delete.
     */
    limit?: number
  }

  /**
   * PokemonStat without action
   */
  export type PokemonStatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonStat
     */
    select?: PokemonStatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonStat
     */
    omit?: PokemonStatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonStatInclude<ExtArgs> | null
  }


  /**
   * Model Type
   */

  export type AggregateType = {
    _count: TypeCountAggregateOutputType | null
    _avg: TypeAvgAggregateOutputType | null
    _sum: TypeSumAggregateOutputType | null
    _min: TypeMinAggregateOutputType | null
    _max: TypeMaxAggregateOutputType | null
  }

  export type TypeAvgAggregateOutputType = {
    id: number | null
    generation_id: number | null
  }

  export type TypeSumAggregateOutputType = {
    id: number | null
    generation_id: number | null
  }

  export type TypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    generation_id: number | null
  }

  export type TypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    generation_id: number | null
  }

  export type TypeCountAggregateOutputType = {
    id: number
    name: number
    generation_id: number
    _all: number
  }


  export type TypeAvgAggregateInputType = {
    id?: true
    generation_id?: true
  }

  export type TypeSumAggregateInputType = {
    id?: true
    generation_id?: true
  }

  export type TypeMinAggregateInputType = {
    id?: true
    name?: true
    generation_id?: true
  }

  export type TypeMaxAggregateInputType = {
    id?: true
    name?: true
    generation_id?: true
  }

  export type TypeCountAggregateInputType = {
    id?: true
    name?: true
    generation_id?: true
    _all?: true
  }

  export type TypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Type to aggregate.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: TypeOrderByWithRelationInput | TypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Types
    **/
    _count?: true | TypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypeMaxAggregateInputType
  }

  export type GetTypeAggregateType<T extends TypeAggregateArgs> = {
        [P in keyof T & keyof AggregateType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateType[P]>
      : GetScalarType<T[P], AggregateType[P]>
  }




  export type TypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TypeWhereInput
    orderBy?: TypeOrderByWithAggregationInput | TypeOrderByWithAggregationInput[]
    by: TypeScalarFieldEnum[] | TypeScalarFieldEnum
    having?: TypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypeCountAggregateInputType | true
    _avg?: TypeAvgAggregateInputType
    _sum?: TypeSumAggregateInputType
    _min?: TypeMinAggregateInputType
    _max?: TypeMaxAggregateInputType
  }

  export type TypeGroupByOutputType = {
    id: number
    name: string
    generation_id: number
    _count: TypeCountAggregateOutputType | null
    _avg: TypeAvgAggregateOutputType | null
    _sum: TypeSumAggregateOutputType | null
    _min: TypeMinAggregateOutputType | null
    _max: TypeMaxAggregateOutputType | null
  }

  type GetTypeGroupByPayload<T extends TypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypeGroupByOutputType[P]>
            : GetScalarType<T[P], TypeGroupByOutputType[P]>
        }
      >
    >


  export type TypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    generation_id?: boolean
    generation?: boolean | GenerationDefaultArgs<ExtArgs>
    pokemon?: boolean | Type$pokemonArgs<ExtArgs>
    attacking?: boolean | Type$attackingArgs<ExtArgs>
    defending?: boolean | Type$defendingArgs<ExtArgs>
    move?: boolean | Type$moveArgs<ExtArgs>
    _count?: boolean | TypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["type"]>

  export type TypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    generation_id?: boolean
    generation?: boolean | GenerationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["type"]>

  export type TypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    generation_id?: boolean
    generation?: boolean | GenerationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["type"]>

  export type TypeSelectScalar = {
    id?: boolean
    name?: boolean
    generation_id?: boolean
  }

  export type TypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "generation_id", ExtArgs["result"]["type"]>
  export type TypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generation?: boolean | GenerationDefaultArgs<ExtArgs>
    pokemon?: boolean | Type$pokemonArgs<ExtArgs>
    attacking?: boolean | Type$attackingArgs<ExtArgs>
    defending?: boolean | Type$defendingArgs<ExtArgs>
    move?: boolean | Type$moveArgs<ExtArgs>
    _count?: boolean | TypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generation?: boolean | GenerationDefaultArgs<ExtArgs>
  }
  export type TypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generation?: boolean | GenerationDefaultArgs<ExtArgs>
  }

  export type $TypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Type"
    objects: {
      generation: Prisma.$GenerationPayload<ExtArgs>
      pokemon: Prisma.$PokemonTypePayload<ExtArgs>[]
      attacking: Prisma.$TypeEffectivenessPayload<ExtArgs>[]
      defending: Prisma.$TypeEffectivenessPayload<ExtArgs>[]
      move: Prisma.$MovePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      generation_id: number
    }, ExtArgs["result"]["type"]>
    composites: {}
  }

  type TypeGetPayload<S extends boolean | null | undefined | TypeDefaultArgs> = $Result.GetResult<Prisma.$TypePayload, S>

  type TypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TypeCountAggregateInputType | true
    }

  export interface TypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Type'], meta: { name: 'Type' } }
    /**
     * Find zero or one Type that matches the filter.
     * @param {TypeFindUniqueArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TypeFindUniqueArgs>(args: SelectSubset<T, TypeFindUniqueArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TypeFindUniqueOrThrowArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TypeFindUniqueOrThrowArgs>(args: SelectSubset<T, TypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFindFirstArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TypeFindFirstArgs>(args?: SelectSubset<T, TypeFindFirstArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFindFirstOrThrowArgs} args - Arguments to find a Type
     * @example
     * // Get one Type
     * const type = await prisma.type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TypeFindFirstOrThrowArgs>(args?: SelectSubset<T, TypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Types
     * const types = await prisma.type.findMany()
     * 
     * // Get first 10 Types
     * const types = await prisma.type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typeWithIdOnly = await prisma.type.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TypeFindManyArgs>(args?: SelectSubset<T, TypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Type.
     * @param {TypeCreateArgs} args - Arguments to create a Type.
     * @example
     * // Create one Type
     * const Type = await prisma.type.create({
     *   data: {
     *     // ... data to create a Type
     *   }
     * })
     * 
     */
    create<T extends TypeCreateArgs>(args: SelectSubset<T, TypeCreateArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Types.
     * @param {TypeCreateManyArgs} args - Arguments to create many Types.
     * @example
     * // Create many Types
     * const type = await prisma.type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TypeCreateManyArgs>(args?: SelectSubset<T, TypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Types and returns the data saved in the database.
     * @param {TypeCreateManyAndReturnArgs} args - Arguments to create many Types.
     * @example
     * // Create many Types
     * const type = await prisma.type.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Types and only return the `id`
     * const typeWithIdOnly = await prisma.type.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TypeCreateManyAndReturnArgs>(args?: SelectSubset<T, TypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Type.
     * @param {TypeDeleteArgs} args - Arguments to delete one Type.
     * @example
     * // Delete one Type
     * const Type = await prisma.type.delete({
     *   where: {
     *     // ... filter to delete one Type
     *   }
     * })
     * 
     */
    delete<T extends TypeDeleteArgs>(args: SelectSubset<T, TypeDeleteArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Type.
     * @param {TypeUpdateArgs} args - Arguments to update one Type.
     * @example
     * // Update one Type
     * const type = await prisma.type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TypeUpdateArgs>(args: SelectSubset<T, TypeUpdateArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Types.
     * @param {TypeDeleteManyArgs} args - Arguments to filter Types to delete.
     * @example
     * // Delete a few Types
     * const { count } = await prisma.type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TypeDeleteManyArgs>(args?: SelectSubset<T, TypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Types
     * const type = await prisma.type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TypeUpdateManyArgs>(args: SelectSubset<T, TypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Types and returns the data updated in the database.
     * @param {TypeUpdateManyAndReturnArgs} args - Arguments to update many Types.
     * @example
     * // Update many Types
     * const type = await prisma.type.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Types and only return the `id`
     * const typeWithIdOnly = await prisma.type.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TypeUpdateManyAndReturnArgs>(args: SelectSubset<T, TypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Type.
     * @param {TypeUpsertArgs} args - Arguments to update or create a Type.
     * @example
     * // Update or create a Type
     * const type = await prisma.type.upsert({
     *   create: {
     *     // ... data to create a Type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Type we want to update
     *   }
     * })
     */
    upsert<T extends TypeUpsertArgs>(args: SelectSubset<T, TypeUpsertArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeCountArgs} args - Arguments to filter Types to count.
     * @example
     * // Count the number of Types
     * const count = await prisma.type.count({
     *   where: {
     *     // ... the filter for the Types we want to count
     *   }
     * })
    **/
    count<T extends TypeCountArgs>(
      args?: Subset<T, TypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypeAggregateArgs>(args: Subset<T, TypeAggregateArgs>): Prisma.PrismaPromise<GetTypeAggregateType<T>>

    /**
     * Group by Type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypeGroupByArgs['orderBy'] }
        : { orderBy?: TypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Type model
   */
  readonly fields: TypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    generation<T extends GenerationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenerationDefaultArgs<ExtArgs>>): Prisma__GenerationClient<$Result.GetResult<Prisma.$GenerationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemon<T extends Type$pokemonArgs<ExtArgs> = {}>(args?: Subset<T, Type$pokemonArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attacking<T extends Type$attackingArgs<ExtArgs> = {}>(args?: Subset<T, Type$attackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypeEffectivenessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    defending<T extends Type$defendingArgs<ExtArgs> = {}>(args?: Subset<T, Type$defendingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypeEffectivenessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    move<T extends Type$moveArgs<ExtArgs> = {}>(args?: Subset<T, Type$moveArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Type model
   */
  interface TypeFieldRefs {
    readonly id: FieldRef<"Type", 'Int'>
    readonly name: FieldRef<"Type", 'String'>
    readonly generation_id: FieldRef<"Type", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Type findUnique
   */
  export type TypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Type to fetch.
     */
    where: TypeWhereUniqueInput
  }

  /**
   * Type findUniqueOrThrow
   */
  export type TypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Type to fetch.
     */
    where: TypeWhereUniqueInput
  }

  /**
   * Type findFirst
   */
  export type TypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Type to fetch.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: TypeOrderByWithRelationInput | TypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Types.
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Types.
     */
    distinct?: TypeScalarFieldEnum | TypeScalarFieldEnum[]
  }

  /**
   * Type findFirstOrThrow
   */
  export type TypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Type to fetch.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: TypeOrderByWithRelationInput | TypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Types.
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Types.
     */
    distinct?: TypeScalarFieldEnum | TypeScalarFieldEnum[]
  }

  /**
   * Type findMany
   */
  export type TypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter, which Types to fetch.
     */
    where?: TypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Types to fetch.
     */
    orderBy?: TypeOrderByWithRelationInput | TypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Types.
     */
    cursor?: TypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Types.
     */
    skip?: number
    distinct?: TypeScalarFieldEnum | TypeScalarFieldEnum[]
  }

  /**
   * Type create
   */
  export type TypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * The data needed to create a Type.
     */
    data: XOR<TypeCreateInput, TypeUncheckedCreateInput>
  }

  /**
   * Type createMany
   */
  export type TypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Types.
     */
    data: TypeCreateManyInput | TypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Type createManyAndReturn
   */
  export type TypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * The data used to create many Types.
     */
    data: TypeCreateManyInput | TypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Type update
   */
  export type TypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * The data needed to update a Type.
     */
    data: XOR<TypeUpdateInput, TypeUncheckedUpdateInput>
    /**
     * Choose, which Type to update.
     */
    where: TypeWhereUniqueInput
  }

  /**
   * Type updateMany
   */
  export type TypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Types.
     */
    data: XOR<TypeUpdateManyMutationInput, TypeUncheckedUpdateManyInput>
    /**
     * Filter which Types to update
     */
    where?: TypeWhereInput
    /**
     * Limit how many Types to update.
     */
    limit?: number
  }

  /**
   * Type updateManyAndReturn
   */
  export type TypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * The data used to update Types.
     */
    data: XOR<TypeUpdateManyMutationInput, TypeUncheckedUpdateManyInput>
    /**
     * Filter which Types to update
     */
    where?: TypeWhereInput
    /**
     * Limit how many Types to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Type upsert
   */
  export type TypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * The filter to search for the Type to update in case it exists.
     */
    where: TypeWhereUniqueInput
    /**
     * In case the Type found by the `where` argument doesn't exist, create a new Type with this data.
     */
    create: XOR<TypeCreateInput, TypeUncheckedCreateInput>
    /**
     * In case the Type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypeUpdateInput, TypeUncheckedUpdateInput>
  }

  /**
   * Type delete
   */
  export type TypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    /**
     * Filter which Type to delete.
     */
    where: TypeWhereUniqueInput
  }

  /**
   * Type deleteMany
   */
  export type TypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Types to delete
     */
    where?: TypeWhereInput
    /**
     * Limit how many Types to delete.
     */
    limit?: number
  }

  /**
   * Type.pokemon
   */
  export type Type$pokemonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonType
     */
    select?: PokemonTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonType
     */
    omit?: PokemonTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonTypeInclude<ExtArgs> | null
    where?: PokemonTypeWhereInput
    orderBy?: PokemonTypeOrderByWithRelationInput | PokemonTypeOrderByWithRelationInput[]
    cursor?: PokemonTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokemonTypeScalarFieldEnum | PokemonTypeScalarFieldEnum[]
  }

  /**
   * Type.attacking
   */
  export type Type$attackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeEffectiveness
     */
    select?: TypeEffectivenessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypeEffectiveness
     */
    omit?: TypeEffectivenessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeEffectivenessInclude<ExtArgs> | null
    where?: TypeEffectivenessWhereInput
    orderBy?: TypeEffectivenessOrderByWithRelationInput | TypeEffectivenessOrderByWithRelationInput[]
    cursor?: TypeEffectivenessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TypeEffectivenessScalarFieldEnum | TypeEffectivenessScalarFieldEnum[]
  }

  /**
   * Type.defending
   */
  export type Type$defendingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeEffectiveness
     */
    select?: TypeEffectivenessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypeEffectiveness
     */
    omit?: TypeEffectivenessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeEffectivenessInclude<ExtArgs> | null
    where?: TypeEffectivenessWhereInput
    orderBy?: TypeEffectivenessOrderByWithRelationInput | TypeEffectivenessOrderByWithRelationInput[]
    cursor?: TypeEffectivenessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TypeEffectivenessScalarFieldEnum | TypeEffectivenessScalarFieldEnum[]
  }

  /**
   * Type.move
   */
  export type Type$moveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    where?: MoveWhereInput
    orderBy?: MoveOrderByWithRelationInput | MoveOrderByWithRelationInput[]
    cursor?: MoveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MoveScalarFieldEnum | MoveScalarFieldEnum[]
  }

  /**
   * Type without action
   */
  export type TypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
  }


  /**
   * Model TypeEffectiveness
   */

  export type AggregateTypeEffectiveness = {
    _count: TypeEffectivenessCountAggregateOutputType | null
    _avg: TypeEffectivenessAvgAggregateOutputType | null
    _sum: TypeEffectivenessSumAggregateOutputType | null
    _min: TypeEffectivenessMinAggregateOutputType | null
    _max: TypeEffectivenessMaxAggregateOutputType | null
  }

  export type TypeEffectivenessAvgAggregateOutputType = {
    id: number | null
    type_id: number | null
    target_type_id: number | null
    damage_factor: number | null
  }

  export type TypeEffectivenessSumAggregateOutputType = {
    id: number | null
    type_id: number | null
    target_type_id: number | null
    damage_factor: number | null
  }

  export type TypeEffectivenessMinAggregateOutputType = {
    id: number | null
    type_id: number | null
    target_type_id: number | null
    damage_factor: number | null
  }

  export type TypeEffectivenessMaxAggregateOutputType = {
    id: number | null
    type_id: number | null
    target_type_id: number | null
    damage_factor: number | null
  }

  export type TypeEffectivenessCountAggregateOutputType = {
    id: number
    type_id: number
    target_type_id: number
    damage_factor: number
    _all: number
  }


  export type TypeEffectivenessAvgAggregateInputType = {
    id?: true
    type_id?: true
    target_type_id?: true
    damage_factor?: true
  }

  export type TypeEffectivenessSumAggregateInputType = {
    id?: true
    type_id?: true
    target_type_id?: true
    damage_factor?: true
  }

  export type TypeEffectivenessMinAggregateInputType = {
    id?: true
    type_id?: true
    target_type_id?: true
    damage_factor?: true
  }

  export type TypeEffectivenessMaxAggregateInputType = {
    id?: true
    type_id?: true
    target_type_id?: true
    damage_factor?: true
  }

  export type TypeEffectivenessCountAggregateInputType = {
    id?: true
    type_id?: true
    target_type_id?: true
    damage_factor?: true
    _all?: true
  }

  export type TypeEffectivenessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypeEffectiveness to aggregate.
     */
    where?: TypeEffectivenessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeEffectivenesses to fetch.
     */
    orderBy?: TypeEffectivenessOrderByWithRelationInput | TypeEffectivenessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypeEffectivenessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeEffectivenesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeEffectivenesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TypeEffectivenesses
    **/
    _count?: true | TypeEffectivenessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TypeEffectivenessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TypeEffectivenessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypeEffectivenessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypeEffectivenessMaxAggregateInputType
  }

  export type GetTypeEffectivenessAggregateType<T extends TypeEffectivenessAggregateArgs> = {
        [P in keyof T & keyof AggregateTypeEffectiveness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypeEffectiveness[P]>
      : GetScalarType<T[P], AggregateTypeEffectiveness[P]>
  }




  export type TypeEffectivenessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TypeEffectivenessWhereInput
    orderBy?: TypeEffectivenessOrderByWithAggregationInput | TypeEffectivenessOrderByWithAggregationInput[]
    by: TypeEffectivenessScalarFieldEnum[] | TypeEffectivenessScalarFieldEnum
    having?: TypeEffectivenessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypeEffectivenessCountAggregateInputType | true
    _avg?: TypeEffectivenessAvgAggregateInputType
    _sum?: TypeEffectivenessSumAggregateInputType
    _min?: TypeEffectivenessMinAggregateInputType
    _max?: TypeEffectivenessMaxAggregateInputType
  }

  export type TypeEffectivenessGroupByOutputType = {
    id: number
    type_id: number
    target_type_id: number
    damage_factor: number
    _count: TypeEffectivenessCountAggregateOutputType | null
    _avg: TypeEffectivenessAvgAggregateOutputType | null
    _sum: TypeEffectivenessSumAggregateOutputType | null
    _min: TypeEffectivenessMinAggregateOutputType | null
    _max: TypeEffectivenessMaxAggregateOutputType | null
  }

  type GetTypeEffectivenessGroupByPayload<T extends TypeEffectivenessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TypeEffectivenessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypeEffectivenessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypeEffectivenessGroupByOutputType[P]>
            : GetScalarType<T[P], TypeEffectivenessGroupByOutputType[P]>
        }
      >
    >


  export type TypeEffectivenessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type_id?: boolean
    target_type_id?: boolean
    damage_factor?: boolean
    attacker?: boolean | TypeDefaultArgs<ExtArgs>
    defender?: boolean | TypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["typeEffectiveness"]>

  export type TypeEffectivenessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type_id?: boolean
    target_type_id?: boolean
    damage_factor?: boolean
    attacker?: boolean | TypeDefaultArgs<ExtArgs>
    defender?: boolean | TypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["typeEffectiveness"]>

  export type TypeEffectivenessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type_id?: boolean
    target_type_id?: boolean
    damage_factor?: boolean
    attacker?: boolean | TypeDefaultArgs<ExtArgs>
    defender?: boolean | TypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["typeEffectiveness"]>

  export type TypeEffectivenessSelectScalar = {
    id?: boolean
    type_id?: boolean
    target_type_id?: boolean
    damage_factor?: boolean
  }

  export type TypeEffectivenessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type_id" | "target_type_id" | "damage_factor", ExtArgs["result"]["typeEffectiveness"]>
  export type TypeEffectivenessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attacker?: boolean | TypeDefaultArgs<ExtArgs>
    defender?: boolean | TypeDefaultArgs<ExtArgs>
  }
  export type TypeEffectivenessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attacker?: boolean | TypeDefaultArgs<ExtArgs>
    defender?: boolean | TypeDefaultArgs<ExtArgs>
  }
  export type TypeEffectivenessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attacker?: boolean | TypeDefaultArgs<ExtArgs>
    defender?: boolean | TypeDefaultArgs<ExtArgs>
  }

  export type $TypeEffectivenessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TypeEffectiveness"
    objects: {
      attacker: Prisma.$TypePayload<ExtArgs>
      defender: Prisma.$TypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type_id: number
      target_type_id: number
      damage_factor: number
    }, ExtArgs["result"]["typeEffectiveness"]>
    composites: {}
  }

  type TypeEffectivenessGetPayload<S extends boolean | null | undefined | TypeEffectivenessDefaultArgs> = $Result.GetResult<Prisma.$TypeEffectivenessPayload, S>

  type TypeEffectivenessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TypeEffectivenessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TypeEffectivenessCountAggregateInputType | true
    }

  export interface TypeEffectivenessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TypeEffectiveness'], meta: { name: 'TypeEffectiveness' } }
    /**
     * Find zero or one TypeEffectiveness that matches the filter.
     * @param {TypeEffectivenessFindUniqueArgs} args - Arguments to find a TypeEffectiveness
     * @example
     * // Get one TypeEffectiveness
     * const typeEffectiveness = await prisma.typeEffectiveness.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TypeEffectivenessFindUniqueArgs>(args: SelectSubset<T, TypeEffectivenessFindUniqueArgs<ExtArgs>>): Prisma__TypeEffectivenessClient<$Result.GetResult<Prisma.$TypeEffectivenessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TypeEffectiveness that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TypeEffectivenessFindUniqueOrThrowArgs} args - Arguments to find a TypeEffectiveness
     * @example
     * // Get one TypeEffectiveness
     * const typeEffectiveness = await prisma.typeEffectiveness.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TypeEffectivenessFindUniqueOrThrowArgs>(args: SelectSubset<T, TypeEffectivenessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TypeEffectivenessClient<$Result.GetResult<Prisma.$TypeEffectivenessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TypeEffectiveness that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeEffectivenessFindFirstArgs} args - Arguments to find a TypeEffectiveness
     * @example
     * // Get one TypeEffectiveness
     * const typeEffectiveness = await prisma.typeEffectiveness.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TypeEffectivenessFindFirstArgs>(args?: SelectSubset<T, TypeEffectivenessFindFirstArgs<ExtArgs>>): Prisma__TypeEffectivenessClient<$Result.GetResult<Prisma.$TypeEffectivenessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TypeEffectiveness that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeEffectivenessFindFirstOrThrowArgs} args - Arguments to find a TypeEffectiveness
     * @example
     * // Get one TypeEffectiveness
     * const typeEffectiveness = await prisma.typeEffectiveness.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TypeEffectivenessFindFirstOrThrowArgs>(args?: SelectSubset<T, TypeEffectivenessFindFirstOrThrowArgs<ExtArgs>>): Prisma__TypeEffectivenessClient<$Result.GetResult<Prisma.$TypeEffectivenessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TypeEffectivenesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeEffectivenessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TypeEffectivenesses
     * const typeEffectivenesses = await prisma.typeEffectiveness.findMany()
     * 
     * // Get first 10 TypeEffectivenesses
     * const typeEffectivenesses = await prisma.typeEffectiveness.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const typeEffectivenessWithIdOnly = await prisma.typeEffectiveness.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TypeEffectivenessFindManyArgs>(args?: SelectSubset<T, TypeEffectivenessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypeEffectivenessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TypeEffectiveness.
     * @param {TypeEffectivenessCreateArgs} args - Arguments to create a TypeEffectiveness.
     * @example
     * // Create one TypeEffectiveness
     * const TypeEffectiveness = await prisma.typeEffectiveness.create({
     *   data: {
     *     // ... data to create a TypeEffectiveness
     *   }
     * })
     * 
     */
    create<T extends TypeEffectivenessCreateArgs>(args: SelectSubset<T, TypeEffectivenessCreateArgs<ExtArgs>>): Prisma__TypeEffectivenessClient<$Result.GetResult<Prisma.$TypeEffectivenessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TypeEffectivenesses.
     * @param {TypeEffectivenessCreateManyArgs} args - Arguments to create many TypeEffectivenesses.
     * @example
     * // Create many TypeEffectivenesses
     * const typeEffectiveness = await prisma.typeEffectiveness.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TypeEffectivenessCreateManyArgs>(args?: SelectSubset<T, TypeEffectivenessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TypeEffectivenesses and returns the data saved in the database.
     * @param {TypeEffectivenessCreateManyAndReturnArgs} args - Arguments to create many TypeEffectivenesses.
     * @example
     * // Create many TypeEffectivenesses
     * const typeEffectiveness = await prisma.typeEffectiveness.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TypeEffectivenesses and only return the `id`
     * const typeEffectivenessWithIdOnly = await prisma.typeEffectiveness.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TypeEffectivenessCreateManyAndReturnArgs>(args?: SelectSubset<T, TypeEffectivenessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypeEffectivenessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TypeEffectiveness.
     * @param {TypeEffectivenessDeleteArgs} args - Arguments to delete one TypeEffectiveness.
     * @example
     * // Delete one TypeEffectiveness
     * const TypeEffectiveness = await prisma.typeEffectiveness.delete({
     *   where: {
     *     // ... filter to delete one TypeEffectiveness
     *   }
     * })
     * 
     */
    delete<T extends TypeEffectivenessDeleteArgs>(args: SelectSubset<T, TypeEffectivenessDeleteArgs<ExtArgs>>): Prisma__TypeEffectivenessClient<$Result.GetResult<Prisma.$TypeEffectivenessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TypeEffectiveness.
     * @param {TypeEffectivenessUpdateArgs} args - Arguments to update one TypeEffectiveness.
     * @example
     * // Update one TypeEffectiveness
     * const typeEffectiveness = await prisma.typeEffectiveness.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TypeEffectivenessUpdateArgs>(args: SelectSubset<T, TypeEffectivenessUpdateArgs<ExtArgs>>): Prisma__TypeEffectivenessClient<$Result.GetResult<Prisma.$TypeEffectivenessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TypeEffectivenesses.
     * @param {TypeEffectivenessDeleteManyArgs} args - Arguments to filter TypeEffectivenesses to delete.
     * @example
     * // Delete a few TypeEffectivenesses
     * const { count } = await prisma.typeEffectiveness.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TypeEffectivenessDeleteManyArgs>(args?: SelectSubset<T, TypeEffectivenessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TypeEffectivenesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeEffectivenessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TypeEffectivenesses
     * const typeEffectiveness = await prisma.typeEffectiveness.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TypeEffectivenessUpdateManyArgs>(args: SelectSubset<T, TypeEffectivenessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TypeEffectivenesses and returns the data updated in the database.
     * @param {TypeEffectivenessUpdateManyAndReturnArgs} args - Arguments to update many TypeEffectivenesses.
     * @example
     * // Update many TypeEffectivenesses
     * const typeEffectiveness = await prisma.typeEffectiveness.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TypeEffectivenesses and only return the `id`
     * const typeEffectivenessWithIdOnly = await prisma.typeEffectiveness.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TypeEffectivenessUpdateManyAndReturnArgs>(args: SelectSubset<T, TypeEffectivenessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypeEffectivenessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TypeEffectiveness.
     * @param {TypeEffectivenessUpsertArgs} args - Arguments to update or create a TypeEffectiveness.
     * @example
     * // Update or create a TypeEffectiveness
     * const typeEffectiveness = await prisma.typeEffectiveness.upsert({
     *   create: {
     *     // ... data to create a TypeEffectiveness
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TypeEffectiveness we want to update
     *   }
     * })
     */
    upsert<T extends TypeEffectivenessUpsertArgs>(args: SelectSubset<T, TypeEffectivenessUpsertArgs<ExtArgs>>): Prisma__TypeEffectivenessClient<$Result.GetResult<Prisma.$TypeEffectivenessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TypeEffectivenesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeEffectivenessCountArgs} args - Arguments to filter TypeEffectivenesses to count.
     * @example
     * // Count the number of TypeEffectivenesses
     * const count = await prisma.typeEffectiveness.count({
     *   where: {
     *     // ... the filter for the TypeEffectivenesses we want to count
     *   }
     * })
    **/
    count<T extends TypeEffectivenessCountArgs>(
      args?: Subset<T, TypeEffectivenessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypeEffectivenessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TypeEffectiveness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeEffectivenessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypeEffectivenessAggregateArgs>(args: Subset<T, TypeEffectivenessAggregateArgs>): Prisma.PrismaPromise<GetTypeEffectivenessAggregateType<T>>

    /**
     * Group by TypeEffectiveness.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeEffectivenessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypeEffectivenessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypeEffectivenessGroupByArgs['orderBy'] }
        : { orderBy?: TypeEffectivenessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypeEffectivenessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypeEffectivenessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TypeEffectiveness model
   */
  readonly fields: TypeEffectivenessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TypeEffectiveness.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TypeEffectivenessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attacker<T extends TypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TypeDefaultArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    defender<T extends TypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TypeDefaultArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TypeEffectiveness model
   */
  interface TypeEffectivenessFieldRefs {
    readonly id: FieldRef<"TypeEffectiveness", 'Int'>
    readonly type_id: FieldRef<"TypeEffectiveness", 'Int'>
    readonly target_type_id: FieldRef<"TypeEffectiveness", 'Int'>
    readonly damage_factor: FieldRef<"TypeEffectiveness", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TypeEffectiveness findUnique
   */
  export type TypeEffectivenessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeEffectiveness
     */
    select?: TypeEffectivenessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypeEffectiveness
     */
    omit?: TypeEffectivenessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeEffectivenessInclude<ExtArgs> | null
    /**
     * Filter, which TypeEffectiveness to fetch.
     */
    where: TypeEffectivenessWhereUniqueInput
  }

  /**
   * TypeEffectiveness findUniqueOrThrow
   */
  export type TypeEffectivenessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeEffectiveness
     */
    select?: TypeEffectivenessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypeEffectiveness
     */
    omit?: TypeEffectivenessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeEffectivenessInclude<ExtArgs> | null
    /**
     * Filter, which TypeEffectiveness to fetch.
     */
    where: TypeEffectivenessWhereUniqueInput
  }

  /**
   * TypeEffectiveness findFirst
   */
  export type TypeEffectivenessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeEffectiveness
     */
    select?: TypeEffectivenessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypeEffectiveness
     */
    omit?: TypeEffectivenessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeEffectivenessInclude<ExtArgs> | null
    /**
     * Filter, which TypeEffectiveness to fetch.
     */
    where?: TypeEffectivenessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeEffectivenesses to fetch.
     */
    orderBy?: TypeEffectivenessOrderByWithRelationInput | TypeEffectivenessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypeEffectivenesses.
     */
    cursor?: TypeEffectivenessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeEffectivenesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeEffectivenesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypeEffectivenesses.
     */
    distinct?: TypeEffectivenessScalarFieldEnum | TypeEffectivenessScalarFieldEnum[]
  }

  /**
   * TypeEffectiveness findFirstOrThrow
   */
  export type TypeEffectivenessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeEffectiveness
     */
    select?: TypeEffectivenessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypeEffectiveness
     */
    omit?: TypeEffectivenessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeEffectivenessInclude<ExtArgs> | null
    /**
     * Filter, which TypeEffectiveness to fetch.
     */
    where?: TypeEffectivenessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeEffectivenesses to fetch.
     */
    orderBy?: TypeEffectivenessOrderByWithRelationInput | TypeEffectivenessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypeEffectivenesses.
     */
    cursor?: TypeEffectivenessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeEffectivenesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeEffectivenesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypeEffectivenesses.
     */
    distinct?: TypeEffectivenessScalarFieldEnum | TypeEffectivenessScalarFieldEnum[]
  }

  /**
   * TypeEffectiveness findMany
   */
  export type TypeEffectivenessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeEffectiveness
     */
    select?: TypeEffectivenessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypeEffectiveness
     */
    omit?: TypeEffectivenessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeEffectivenessInclude<ExtArgs> | null
    /**
     * Filter, which TypeEffectivenesses to fetch.
     */
    where?: TypeEffectivenessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeEffectivenesses to fetch.
     */
    orderBy?: TypeEffectivenessOrderByWithRelationInput | TypeEffectivenessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TypeEffectivenesses.
     */
    cursor?: TypeEffectivenessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeEffectivenesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeEffectivenesses.
     */
    skip?: number
    distinct?: TypeEffectivenessScalarFieldEnum | TypeEffectivenessScalarFieldEnum[]
  }

  /**
   * TypeEffectiveness create
   */
  export type TypeEffectivenessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeEffectiveness
     */
    select?: TypeEffectivenessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypeEffectiveness
     */
    omit?: TypeEffectivenessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeEffectivenessInclude<ExtArgs> | null
    /**
     * The data needed to create a TypeEffectiveness.
     */
    data: XOR<TypeEffectivenessCreateInput, TypeEffectivenessUncheckedCreateInput>
  }

  /**
   * TypeEffectiveness createMany
   */
  export type TypeEffectivenessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TypeEffectivenesses.
     */
    data: TypeEffectivenessCreateManyInput | TypeEffectivenessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TypeEffectiveness createManyAndReturn
   */
  export type TypeEffectivenessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeEffectiveness
     */
    select?: TypeEffectivenessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TypeEffectiveness
     */
    omit?: TypeEffectivenessOmit<ExtArgs> | null
    /**
     * The data used to create many TypeEffectivenesses.
     */
    data: TypeEffectivenessCreateManyInput | TypeEffectivenessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeEffectivenessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TypeEffectiveness update
   */
  export type TypeEffectivenessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeEffectiveness
     */
    select?: TypeEffectivenessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypeEffectiveness
     */
    omit?: TypeEffectivenessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeEffectivenessInclude<ExtArgs> | null
    /**
     * The data needed to update a TypeEffectiveness.
     */
    data: XOR<TypeEffectivenessUpdateInput, TypeEffectivenessUncheckedUpdateInput>
    /**
     * Choose, which TypeEffectiveness to update.
     */
    where: TypeEffectivenessWhereUniqueInput
  }

  /**
   * TypeEffectiveness updateMany
   */
  export type TypeEffectivenessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TypeEffectivenesses.
     */
    data: XOR<TypeEffectivenessUpdateManyMutationInput, TypeEffectivenessUncheckedUpdateManyInput>
    /**
     * Filter which TypeEffectivenesses to update
     */
    where?: TypeEffectivenessWhereInput
    /**
     * Limit how many TypeEffectivenesses to update.
     */
    limit?: number
  }

  /**
   * TypeEffectiveness updateManyAndReturn
   */
  export type TypeEffectivenessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeEffectiveness
     */
    select?: TypeEffectivenessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TypeEffectiveness
     */
    omit?: TypeEffectivenessOmit<ExtArgs> | null
    /**
     * The data used to update TypeEffectivenesses.
     */
    data: XOR<TypeEffectivenessUpdateManyMutationInput, TypeEffectivenessUncheckedUpdateManyInput>
    /**
     * Filter which TypeEffectivenesses to update
     */
    where?: TypeEffectivenessWhereInput
    /**
     * Limit how many TypeEffectivenesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeEffectivenessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TypeEffectiveness upsert
   */
  export type TypeEffectivenessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeEffectiveness
     */
    select?: TypeEffectivenessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypeEffectiveness
     */
    omit?: TypeEffectivenessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeEffectivenessInclude<ExtArgs> | null
    /**
     * The filter to search for the TypeEffectiveness to update in case it exists.
     */
    where: TypeEffectivenessWhereUniqueInput
    /**
     * In case the TypeEffectiveness found by the `where` argument doesn't exist, create a new TypeEffectiveness with this data.
     */
    create: XOR<TypeEffectivenessCreateInput, TypeEffectivenessUncheckedCreateInput>
    /**
     * In case the TypeEffectiveness was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypeEffectivenessUpdateInput, TypeEffectivenessUncheckedUpdateInput>
  }

  /**
   * TypeEffectiveness delete
   */
  export type TypeEffectivenessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeEffectiveness
     */
    select?: TypeEffectivenessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypeEffectiveness
     */
    omit?: TypeEffectivenessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeEffectivenessInclude<ExtArgs> | null
    /**
     * Filter which TypeEffectiveness to delete.
     */
    where: TypeEffectivenessWhereUniqueInput
  }

  /**
   * TypeEffectiveness deleteMany
   */
  export type TypeEffectivenessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypeEffectivenesses to delete
     */
    where?: TypeEffectivenessWhereInput
    /**
     * Limit how many TypeEffectivenesses to delete.
     */
    limit?: number
  }

  /**
   * TypeEffectiveness without action
   */
  export type TypeEffectivenessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeEffectiveness
     */
    select?: TypeEffectivenessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TypeEffectiveness
     */
    omit?: TypeEffectivenessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeEffectivenessInclude<ExtArgs> | null
  }


  /**
   * Model PokemonType
   */

  export type AggregatePokemonType = {
    _count: PokemonTypeCountAggregateOutputType | null
    _avg: PokemonTypeAvgAggregateOutputType | null
    _sum: PokemonTypeSumAggregateOutputType | null
    _min: PokemonTypeMinAggregateOutputType | null
    _max: PokemonTypeMaxAggregateOutputType | null
  }

  export type PokemonTypeAvgAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    type_id: number | null
  }

  export type PokemonTypeSumAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    type_id: number | null
  }

  export type PokemonTypeMinAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    type_id: number | null
  }

  export type PokemonTypeMaxAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    type_id: number | null
  }

  export type PokemonTypeCountAggregateOutputType = {
    id: number
    pokemon_id: number
    type_id: number
    _all: number
  }


  export type PokemonTypeAvgAggregateInputType = {
    id?: true
    pokemon_id?: true
    type_id?: true
  }

  export type PokemonTypeSumAggregateInputType = {
    id?: true
    pokemon_id?: true
    type_id?: true
  }

  export type PokemonTypeMinAggregateInputType = {
    id?: true
    pokemon_id?: true
    type_id?: true
  }

  export type PokemonTypeMaxAggregateInputType = {
    id?: true
    pokemon_id?: true
    type_id?: true
  }

  export type PokemonTypeCountAggregateInputType = {
    id?: true
    pokemon_id?: true
    type_id?: true
    _all?: true
  }

  export type PokemonTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PokemonType to aggregate.
     */
    where?: PokemonTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonTypes to fetch.
     */
    orderBy?: PokemonTypeOrderByWithRelationInput | PokemonTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PokemonTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PokemonTypes
    **/
    _count?: true | PokemonTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PokemonTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PokemonTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PokemonTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PokemonTypeMaxAggregateInputType
  }

  export type GetPokemonTypeAggregateType<T extends PokemonTypeAggregateArgs> = {
        [P in keyof T & keyof AggregatePokemonType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePokemonType[P]>
      : GetScalarType<T[P], AggregatePokemonType[P]>
  }




  export type PokemonTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonTypeWhereInput
    orderBy?: PokemonTypeOrderByWithAggregationInput | PokemonTypeOrderByWithAggregationInput[]
    by: PokemonTypeScalarFieldEnum[] | PokemonTypeScalarFieldEnum
    having?: PokemonTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PokemonTypeCountAggregateInputType | true
    _avg?: PokemonTypeAvgAggregateInputType
    _sum?: PokemonTypeSumAggregateInputType
    _min?: PokemonTypeMinAggregateInputType
    _max?: PokemonTypeMaxAggregateInputType
  }

  export type PokemonTypeGroupByOutputType = {
    id: number
    pokemon_id: number
    type_id: number
    _count: PokemonTypeCountAggregateOutputType | null
    _avg: PokemonTypeAvgAggregateOutputType | null
    _sum: PokemonTypeSumAggregateOutputType | null
    _min: PokemonTypeMinAggregateOutputType | null
    _max: PokemonTypeMaxAggregateOutputType | null
  }

  type GetPokemonTypeGroupByPayload<T extends PokemonTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PokemonTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PokemonTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PokemonTypeGroupByOutputType[P]>
            : GetScalarType<T[P], PokemonTypeGroupByOutputType[P]>
        }
      >
    >


  export type PokemonTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pokemon_id?: boolean
    type_id?: boolean
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    type?: boolean | TypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonType"]>

  export type PokemonTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pokemon_id?: boolean
    type_id?: boolean
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    type?: boolean | TypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonType"]>

  export type PokemonTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pokemon_id?: boolean
    type_id?: boolean
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    type?: boolean | TypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonType"]>

  export type PokemonTypeSelectScalar = {
    id?: boolean
    pokemon_id?: boolean
    type_id?: boolean
  }

  export type PokemonTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pokemon_id" | "type_id", ExtArgs["result"]["pokemonType"]>
  export type PokemonTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    type?: boolean | TypeDefaultArgs<ExtArgs>
  }
  export type PokemonTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    type?: boolean | TypeDefaultArgs<ExtArgs>
  }
  export type PokemonTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    type?: boolean | TypeDefaultArgs<ExtArgs>
  }

  export type $PokemonTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PokemonType"
    objects: {
      pokemon: Prisma.$PokemonPayload<ExtArgs>
      type: Prisma.$TypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pokemon_id: number
      type_id: number
    }, ExtArgs["result"]["pokemonType"]>
    composites: {}
  }

  type PokemonTypeGetPayload<S extends boolean | null | undefined | PokemonTypeDefaultArgs> = $Result.GetResult<Prisma.$PokemonTypePayload, S>

  type PokemonTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PokemonTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PokemonTypeCountAggregateInputType | true
    }

  export interface PokemonTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PokemonType'], meta: { name: 'PokemonType' } }
    /**
     * Find zero or one PokemonType that matches the filter.
     * @param {PokemonTypeFindUniqueArgs} args - Arguments to find a PokemonType
     * @example
     * // Get one PokemonType
     * const pokemonType = await prisma.pokemonType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PokemonTypeFindUniqueArgs>(args: SelectSubset<T, PokemonTypeFindUniqueArgs<ExtArgs>>): Prisma__PokemonTypeClient<$Result.GetResult<Prisma.$PokemonTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PokemonType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PokemonTypeFindUniqueOrThrowArgs} args - Arguments to find a PokemonType
     * @example
     * // Get one PokemonType
     * const pokemonType = await prisma.pokemonType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PokemonTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, PokemonTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PokemonTypeClient<$Result.GetResult<Prisma.$PokemonTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PokemonType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonTypeFindFirstArgs} args - Arguments to find a PokemonType
     * @example
     * // Get one PokemonType
     * const pokemonType = await prisma.pokemonType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PokemonTypeFindFirstArgs>(args?: SelectSubset<T, PokemonTypeFindFirstArgs<ExtArgs>>): Prisma__PokemonTypeClient<$Result.GetResult<Prisma.$PokemonTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PokemonType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonTypeFindFirstOrThrowArgs} args - Arguments to find a PokemonType
     * @example
     * // Get one PokemonType
     * const pokemonType = await prisma.pokemonType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PokemonTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, PokemonTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PokemonTypeClient<$Result.GetResult<Prisma.$PokemonTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PokemonTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PokemonTypes
     * const pokemonTypes = await prisma.pokemonType.findMany()
     * 
     * // Get first 10 PokemonTypes
     * const pokemonTypes = await prisma.pokemonType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pokemonTypeWithIdOnly = await prisma.pokemonType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PokemonTypeFindManyArgs>(args?: SelectSubset<T, PokemonTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PokemonType.
     * @param {PokemonTypeCreateArgs} args - Arguments to create a PokemonType.
     * @example
     * // Create one PokemonType
     * const PokemonType = await prisma.pokemonType.create({
     *   data: {
     *     // ... data to create a PokemonType
     *   }
     * })
     * 
     */
    create<T extends PokemonTypeCreateArgs>(args: SelectSubset<T, PokemonTypeCreateArgs<ExtArgs>>): Prisma__PokemonTypeClient<$Result.GetResult<Prisma.$PokemonTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PokemonTypes.
     * @param {PokemonTypeCreateManyArgs} args - Arguments to create many PokemonTypes.
     * @example
     * // Create many PokemonTypes
     * const pokemonType = await prisma.pokemonType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PokemonTypeCreateManyArgs>(args?: SelectSubset<T, PokemonTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PokemonTypes and returns the data saved in the database.
     * @param {PokemonTypeCreateManyAndReturnArgs} args - Arguments to create many PokemonTypes.
     * @example
     * // Create many PokemonTypes
     * const pokemonType = await prisma.pokemonType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PokemonTypes and only return the `id`
     * const pokemonTypeWithIdOnly = await prisma.pokemonType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PokemonTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, PokemonTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PokemonType.
     * @param {PokemonTypeDeleteArgs} args - Arguments to delete one PokemonType.
     * @example
     * // Delete one PokemonType
     * const PokemonType = await prisma.pokemonType.delete({
     *   where: {
     *     // ... filter to delete one PokemonType
     *   }
     * })
     * 
     */
    delete<T extends PokemonTypeDeleteArgs>(args: SelectSubset<T, PokemonTypeDeleteArgs<ExtArgs>>): Prisma__PokemonTypeClient<$Result.GetResult<Prisma.$PokemonTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PokemonType.
     * @param {PokemonTypeUpdateArgs} args - Arguments to update one PokemonType.
     * @example
     * // Update one PokemonType
     * const pokemonType = await prisma.pokemonType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PokemonTypeUpdateArgs>(args: SelectSubset<T, PokemonTypeUpdateArgs<ExtArgs>>): Prisma__PokemonTypeClient<$Result.GetResult<Prisma.$PokemonTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PokemonTypes.
     * @param {PokemonTypeDeleteManyArgs} args - Arguments to filter PokemonTypes to delete.
     * @example
     * // Delete a few PokemonTypes
     * const { count } = await prisma.pokemonType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PokemonTypeDeleteManyArgs>(args?: SelectSubset<T, PokemonTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PokemonTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PokemonTypes
     * const pokemonType = await prisma.pokemonType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PokemonTypeUpdateManyArgs>(args: SelectSubset<T, PokemonTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PokemonTypes and returns the data updated in the database.
     * @param {PokemonTypeUpdateManyAndReturnArgs} args - Arguments to update many PokemonTypes.
     * @example
     * // Update many PokemonTypes
     * const pokemonType = await prisma.pokemonType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PokemonTypes and only return the `id`
     * const pokemonTypeWithIdOnly = await prisma.pokemonType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PokemonTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, PokemonTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PokemonType.
     * @param {PokemonTypeUpsertArgs} args - Arguments to update or create a PokemonType.
     * @example
     * // Update or create a PokemonType
     * const pokemonType = await prisma.pokemonType.upsert({
     *   create: {
     *     // ... data to create a PokemonType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PokemonType we want to update
     *   }
     * })
     */
    upsert<T extends PokemonTypeUpsertArgs>(args: SelectSubset<T, PokemonTypeUpsertArgs<ExtArgs>>): Prisma__PokemonTypeClient<$Result.GetResult<Prisma.$PokemonTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PokemonTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonTypeCountArgs} args - Arguments to filter PokemonTypes to count.
     * @example
     * // Count the number of PokemonTypes
     * const count = await prisma.pokemonType.count({
     *   where: {
     *     // ... the filter for the PokemonTypes we want to count
     *   }
     * })
    **/
    count<T extends PokemonTypeCountArgs>(
      args?: Subset<T, PokemonTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PokemonTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PokemonType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PokemonTypeAggregateArgs>(args: Subset<T, PokemonTypeAggregateArgs>): Prisma.PrismaPromise<GetPokemonTypeAggregateType<T>>

    /**
     * Group by PokemonType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PokemonTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PokemonTypeGroupByArgs['orderBy'] }
        : { orderBy?: PokemonTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PokemonTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPokemonTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PokemonType model
   */
  readonly fields: PokemonTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PokemonType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PokemonTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pokemon<T extends PokemonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PokemonDefaultArgs<ExtArgs>>): Prisma__PokemonClient<$Result.GetResult<Prisma.$PokemonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    type<T extends TypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TypeDefaultArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PokemonType model
   */
  interface PokemonTypeFieldRefs {
    readonly id: FieldRef<"PokemonType", 'Int'>
    readonly pokemon_id: FieldRef<"PokemonType", 'Int'>
    readonly type_id: FieldRef<"PokemonType", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PokemonType findUnique
   */
  export type PokemonTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonType
     */
    select?: PokemonTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonType
     */
    omit?: PokemonTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonTypeInclude<ExtArgs> | null
    /**
     * Filter, which PokemonType to fetch.
     */
    where: PokemonTypeWhereUniqueInput
  }

  /**
   * PokemonType findUniqueOrThrow
   */
  export type PokemonTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonType
     */
    select?: PokemonTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonType
     */
    omit?: PokemonTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonTypeInclude<ExtArgs> | null
    /**
     * Filter, which PokemonType to fetch.
     */
    where: PokemonTypeWhereUniqueInput
  }

  /**
   * PokemonType findFirst
   */
  export type PokemonTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonType
     */
    select?: PokemonTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonType
     */
    omit?: PokemonTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonTypeInclude<ExtArgs> | null
    /**
     * Filter, which PokemonType to fetch.
     */
    where?: PokemonTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonTypes to fetch.
     */
    orderBy?: PokemonTypeOrderByWithRelationInput | PokemonTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PokemonTypes.
     */
    cursor?: PokemonTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PokemonTypes.
     */
    distinct?: PokemonTypeScalarFieldEnum | PokemonTypeScalarFieldEnum[]
  }

  /**
   * PokemonType findFirstOrThrow
   */
  export type PokemonTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonType
     */
    select?: PokemonTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonType
     */
    omit?: PokemonTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonTypeInclude<ExtArgs> | null
    /**
     * Filter, which PokemonType to fetch.
     */
    where?: PokemonTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonTypes to fetch.
     */
    orderBy?: PokemonTypeOrderByWithRelationInput | PokemonTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PokemonTypes.
     */
    cursor?: PokemonTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PokemonTypes.
     */
    distinct?: PokemonTypeScalarFieldEnum | PokemonTypeScalarFieldEnum[]
  }

  /**
   * PokemonType findMany
   */
  export type PokemonTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonType
     */
    select?: PokemonTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonType
     */
    omit?: PokemonTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonTypeInclude<ExtArgs> | null
    /**
     * Filter, which PokemonTypes to fetch.
     */
    where?: PokemonTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonTypes to fetch.
     */
    orderBy?: PokemonTypeOrderByWithRelationInput | PokemonTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PokemonTypes.
     */
    cursor?: PokemonTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonTypes.
     */
    skip?: number
    distinct?: PokemonTypeScalarFieldEnum | PokemonTypeScalarFieldEnum[]
  }

  /**
   * PokemonType create
   */
  export type PokemonTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonType
     */
    select?: PokemonTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonType
     */
    omit?: PokemonTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a PokemonType.
     */
    data: XOR<PokemonTypeCreateInput, PokemonTypeUncheckedCreateInput>
  }

  /**
   * PokemonType createMany
   */
  export type PokemonTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PokemonTypes.
     */
    data: PokemonTypeCreateManyInput | PokemonTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PokemonType createManyAndReturn
   */
  export type PokemonTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonType
     */
    select?: PokemonTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonType
     */
    omit?: PokemonTypeOmit<ExtArgs> | null
    /**
     * The data used to create many PokemonTypes.
     */
    data: PokemonTypeCreateManyInput | PokemonTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PokemonType update
   */
  export type PokemonTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonType
     */
    select?: PokemonTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonType
     */
    omit?: PokemonTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a PokemonType.
     */
    data: XOR<PokemonTypeUpdateInput, PokemonTypeUncheckedUpdateInput>
    /**
     * Choose, which PokemonType to update.
     */
    where: PokemonTypeWhereUniqueInput
  }

  /**
   * PokemonType updateMany
   */
  export type PokemonTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PokemonTypes.
     */
    data: XOR<PokemonTypeUpdateManyMutationInput, PokemonTypeUncheckedUpdateManyInput>
    /**
     * Filter which PokemonTypes to update
     */
    where?: PokemonTypeWhereInput
    /**
     * Limit how many PokemonTypes to update.
     */
    limit?: number
  }

  /**
   * PokemonType updateManyAndReturn
   */
  export type PokemonTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonType
     */
    select?: PokemonTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonType
     */
    omit?: PokemonTypeOmit<ExtArgs> | null
    /**
     * The data used to update PokemonTypes.
     */
    data: XOR<PokemonTypeUpdateManyMutationInput, PokemonTypeUncheckedUpdateManyInput>
    /**
     * Filter which PokemonTypes to update
     */
    where?: PokemonTypeWhereInput
    /**
     * Limit how many PokemonTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PokemonType upsert
   */
  export type PokemonTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonType
     */
    select?: PokemonTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonType
     */
    omit?: PokemonTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the PokemonType to update in case it exists.
     */
    where: PokemonTypeWhereUniqueInput
    /**
     * In case the PokemonType found by the `where` argument doesn't exist, create a new PokemonType with this data.
     */
    create: XOR<PokemonTypeCreateInput, PokemonTypeUncheckedCreateInput>
    /**
     * In case the PokemonType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PokemonTypeUpdateInput, PokemonTypeUncheckedUpdateInput>
  }

  /**
   * PokemonType delete
   */
  export type PokemonTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonType
     */
    select?: PokemonTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonType
     */
    omit?: PokemonTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonTypeInclude<ExtArgs> | null
    /**
     * Filter which PokemonType to delete.
     */
    where: PokemonTypeWhereUniqueInput
  }

  /**
   * PokemonType deleteMany
   */
  export type PokemonTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PokemonTypes to delete
     */
    where?: PokemonTypeWhereInput
    /**
     * Limit how many PokemonTypes to delete.
     */
    limit?: number
  }

  /**
   * PokemonType without action
   */
  export type PokemonTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonType
     */
    select?: PokemonTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonType
     */
    omit?: PokemonTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonTypeInclude<ExtArgs> | null
  }


  /**
   * Model EggGroup
   */

  export type AggregateEggGroup = {
    _count: EggGroupCountAggregateOutputType | null
    _avg: EggGroupAvgAggregateOutputType | null
    _sum: EggGroupSumAggregateOutputType | null
    _min: EggGroupMinAggregateOutputType | null
    _max: EggGroupMaxAggregateOutputType | null
  }

  export type EggGroupAvgAggregateOutputType = {
    id: number | null
  }

  export type EggGroupSumAggregateOutputType = {
    id: number | null
  }

  export type EggGroupMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type EggGroupMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type EggGroupCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type EggGroupAvgAggregateInputType = {
    id?: true
  }

  export type EggGroupSumAggregateInputType = {
    id?: true
  }

  export type EggGroupMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type EggGroupMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type EggGroupCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type EggGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EggGroup to aggregate.
     */
    where?: EggGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EggGroups to fetch.
     */
    orderBy?: EggGroupOrderByWithRelationInput | EggGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EggGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EggGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EggGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EggGroups
    **/
    _count?: true | EggGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EggGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EggGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EggGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EggGroupMaxAggregateInputType
  }

  export type GetEggGroupAggregateType<T extends EggGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateEggGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEggGroup[P]>
      : GetScalarType<T[P], AggregateEggGroup[P]>
  }




  export type EggGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EggGroupWhereInput
    orderBy?: EggGroupOrderByWithAggregationInput | EggGroupOrderByWithAggregationInput[]
    by: EggGroupScalarFieldEnum[] | EggGroupScalarFieldEnum
    having?: EggGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EggGroupCountAggregateInputType | true
    _avg?: EggGroupAvgAggregateInputType
    _sum?: EggGroupSumAggregateInputType
    _min?: EggGroupMinAggregateInputType
    _max?: EggGroupMaxAggregateInputType
  }

  export type EggGroupGroupByOutputType = {
    id: number
    name: string
    _count: EggGroupCountAggregateOutputType | null
    _avg: EggGroupAvgAggregateOutputType | null
    _sum: EggGroupSumAggregateOutputType | null
    _min: EggGroupMinAggregateOutputType | null
    _max: EggGroupMaxAggregateOutputType | null
  }

  type GetEggGroupGroupByPayload<T extends EggGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EggGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EggGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EggGroupGroupByOutputType[P]>
            : GetScalarType<T[P], EggGroupGroupByOutputType[P]>
        }
      >
    >


  export type EggGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    pokemon_egg_group?: boolean | EggGroup$pokemon_egg_groupArgs<ExtArgs>
    _count?: boolean | EggGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eggGroup"]>

  export type EggGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["eggGroup"]>

  export type EggGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["eggGroup"]>

  export type EggGroupSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type EggGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["eggGroup"]>
  export type EggGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon_egg_group?: boolean | EggGroup$pokemon_egg_groupArgs<ExtArgs>
    _count?: boolean | EggGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EggGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EggGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EggGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EggGroup"
    objects: {
      pokemon_egg_group: Prisma.$PokemonEggGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["eggGroup"]>
    composites: {}
  }

  type EggGroupGetPayload<S extends boolean | null | undefined | EggGroupDefaultArgs> = $Result.GetResult<Prisma.$EggGroupPayload, S>

  type EggGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EggGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EggGroupCountAggregateInputType | true
    }

  export interface EggGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EggGroup'], meta: { name: 'EggGroup' } }
    /**
     * Find zero or one EggGroup that matches the filter.
     * @param {EggGroupFindUniqueArgs} args - Arguments to find a EggGroup
     * @example
     * // Get one EggGroup
     * const eggGroup = await prisma.eggGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EggGroupFindUniqueArgs>(args: SelectSubset<T, EggGroupFindUniqueArgs<ExtArgs>>): Prisma__EggGroupClient<$Result.GetResult<Prisma.$EggGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EggGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EggGroupFindUniqueOrThrowArgs} args - Arguments to find a EggGroup
     * @example
     * // Get one EggGroup
     * const eggGroup = await prisma.eggGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EggGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, EggGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EggGroupClient<$Result.GetResult<Prisma.$EggGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EggGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggGroupFindFirstArgs} args - Arguments to find a EggGroup
     * @example
     * // Get one EggGroup
     * const eggGroup = await prisma.eggGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EggGroupFindFirstArgs>(args?: SelectSubset<T, EggGroupFindFirstArgs<ExtArgs>>): Prisma__EggGroupClient<$Result.GetResult<Prisma.$EggGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EggGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggGroupFindFirstOrThrowArgs} args - Arguments to find a EggGroup
     * @example
     * // Get one EggGroup
     * const eggGroup = await prisma.eggGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EggGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, EggGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__EggGroupClient<$Result.GetResult<Prisma.$EggGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EggGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EggGroups
     * const eggGroups = await prisma.eggGroup.findMany()
     * 
     * // Get first 10 EggGroups
     * const eggGroups = await prisma.eggGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eggGroupWithIdOnly = await prisma.eggGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EggGroupFindManyArgs>(args?: SelectSubset<T, EggGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EggGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EggGroup.
     * @param {EggGroupCreateArgs} args - Arguments to create a EggGroup.
     * @example
     * // Create one EggGroup
     * const EggGroup = await prisma.eggGroup.create({
     *   data: {
     *     // ... data to create a EggGroup
     *   }
     * })
     * 
     */
    create<T extends EggGroupCreateArgs>(args: SelectSubset<T, EggGroupCreateArgs<ExtArgs>>): Prisma__EggGroupClient<$Result.GetResult<Prisma.$EggGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EggGroups.
     * @param {EggGroupCreateManyArgs} args - Arguments to create many EggGroups.
     * @example
     * // Create many EggGroups
     * const eggGroup = await prisma.eggGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EggGroupCreateManyArgs>(args?: SelectSubset<T, EggGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EggGroups and returns the data saved in the database.
     * @param {EggGroupCreateManyAndReturnArgs} args - Arguments to create many EggGroups.
     * @example
     * // Create many EggGroups
     * const eggGroup = await prisma.eggGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EggGroups and only return the `id`
     * const eggGroupWithIdOnly = await prisma.eggGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EggGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, EggGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EggGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EggGroup.
     * @param {EggGroupDeleteArgs} args - Arguments to delete one EggGroup.
     * @example
     * // Delete one EggGroup
     * const EggGroup = await prisma.eggGroup.delete({
     *   where: {
     *     // ... filter to delete one EggGroup
     *   }
     * })
     * 
     */
    delete<T extends EggGroupDeleteArgs>(args: SelectSubset<T, EggGroupDeleteArgs<ExtArgs>>): Prisma__EggGroupClient<$Result.GetResult<Prisma.$EggGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EggGroup.
     * @param {EggGroupUpdateArgs} args - Arguments to update one EggGroup.
     * @example
     * // Update one EggGroup
     * const eggGroup = await prisma.eggGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EggGroupUpdateArgs>(args: SelectSubset<T, EggGroupUpdateArgs<ExtArgs>>): Prisma__EggGroupClient<$Result.GetResult<Prisma.$EggGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EggGroups.
     * @param {EggGroupDeleteManyArgs} args - Arguments to filter EggGroups to delete.
     * @example
     * // Delete a few EggGroups
     * const { count } = await prisma.eggGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EggGroupDeleteManyArgs>(args?: SelectSubset<T, EggGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EggGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EggGroups
     * const eggGroup = await prisma.eggGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EggGroupUpdateManyArgs>(args: SelectSubset<T, EggGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EggGroups and returns the data updated in the database.
     * @param {EggGroupUpdateManyAndReturnArgs} args - Arguments to update many EggGroups.
     * @example
     * // Update many EggGroups
     * const eggGroup = await prisma.eggGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EggGroups and only return the `id`
     * const eggGroupWithIdOnly = await prisma.eggGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EggGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, EggGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EggGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EggGroup.
     * @param {EggGroupUpsertArgs} args - Arguments to update or create a EggGroup.
     * @example
     * // Update or create a EggGroup
     * const eggGroup = await prisma.eggGroup.upsert({
     *   create: {
     *     // ... data to create a EggGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EggGroup we want to update
     *   }
     * })
     */
    upsert<T extends EggGroupUpsertArgs>(args: SelectSubset<T, EggGroupUpsertArgs<ExtArgs>>): Prisma__EggGroupClient<$Result.GetResult<Prisma.$EggGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EggGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggGroupCountArgs} args - Arguments to filter EggGroups to count.
     * @example
     * // Count the number of EggGroups
     * const count = await prisma.eggGroup.count({
     *   where: {
     *     // ... the filter for the EggGroups we want to count
     *   }
     * })
    **/
    count<T extends EggGroupCountArgs>(
      args?: Subset<T, EggGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EggGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EggGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EggGroupAggregateArgs>(args: Subset<T, EggGroupAggregateArgs>): Prisma.PrismaPromise<GetEggGroupAggregateType<T>>

    /**
     * Group by EggGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EggGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EggGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EggGroupGroupByArgs['orderBy'] }
        : { orderBy?: EggGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EggGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEggGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EggGroup model
   */
  readonly fields: EggGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EggGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EggGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pokemon_egg_group<T extends EggGroup$pokemon_egg_groupArgs<ExtArgs> = {}>(args?: Subset<T, EggGroup$pokemon_egg_groupArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonEggGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EggGroup model
   */
  interface EggGroupFieldRefs {
    readonly id: FieldRef<"EggGroup", 'Int'>
    readonly name: FieldRef<"EggGroup", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EggGroup findUnique
   */
  export type EggGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggGroup
     */
    select?: EggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggGroup
     */
    omit?: EggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggGroupInclude<ExtArgs> | null
    /**
     * Filter, which EggGroup to fetch.
     */
    where: EggGroupWhereUniqueInput
  }

  /**
   * EggGroup findUniqueOrThrow
   */
  export type EggGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggGroup
     */
    select?: EggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggGroup
     */
    omit?: EggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggGroupInclude<ExtArgs> | null
    /**
     * Filter, which EggGroup to fetch.
     */
    where: EggGroupWhereUniqueInput
  }

  /**
   * EggGroup findFirst
   */
  export type EggGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggGroup
     */
    select?: EggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggGroup
     */
    omit?: EggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggGroupInclude<ExtArgs> | null
    /**
     * Filter, which EggGroup to fetch.
     */
    where?: EggGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EggGroups to fetch.
     */
    orderBy?: EggGroupOrderByWithRelationInput | EggGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EggGroups.
     */
    cursor?: EggGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EggGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EggGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EggGroups.
     */
    distinct?: EggGroupScalarFieldEnum | EggGroupScalarFieldEnum[]
  }

  /**
   * EggGroup findFirstOrThrow
   */
  export type EggGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggGroup
     */
    select?: EggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggGroup
     */
    omit?: EggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggGroupInclude<ExtArgs> | null
    /**
     * Filter, which EggGroup to fetch.
     */
    where?: EggGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EggGroups to fetch.
     */
    orderBy?: EggGroupOrderByWithRelationInput | EggGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EggGroups.
     */
    cursor?: EggGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EggGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EggGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EggGroups.
     */
    distinct?: EggGroupScalarFieldEnum | EggGroupScalarFieldEnum[]
  }

  /**
   * EggGroup findMany
   */
  export type EggGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggGroup
     */
    select?: EggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggGroup
     */
    omit?: EggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggGroupInclude<ExtArgs> | null
    /**
     * Filter, which EggGroups to fetch.
     */
    where?: EggGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EggGroups to fetch.
     */
    orderBy?: EggGroupOrderByWithRelationInput | EggGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EggGroups.
     */
    cursor?: EggGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EggGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EggGroups.
     */
    skip?: number
    distinct?: EggGroupScalarFieldEnum | EggGroupScalarFieldEnum[]
  }

  /**
   * EggGroup create
   */
  export type EggGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggGroup
     */
    select?: EggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggGroup
     */
    omit?: EggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a EggGroup.
     */
    data: XOR<EggGroupCreateInput, EggGroupUncheckedCreateInput>
  }

  /**
   * EggGroup createMany
   */
  export type EggGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EggGroups.
     */
    data: EggGroupCreateManyInput | EggGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EggGroup createManyAndReturn
   */
  export type EggGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggGroup
     */
    select?: EggGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EggGroup
     */
    omit?: EggGroupOmit<ExtArgs> | null
    /**
     * The data used to create many EggGroups.
     */
    data: EggGroupCreateManyInput | EggGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EggGroup update
   */
  export type EggGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggGroup
     */
    select?: EggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggGroup
     */
    omit?: EggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a EggGroup.
     */
    data: XOR<EggGroupUpdateInput, EggGroupUncheckedUpdateInput>
    /**
     * Choose, which EggGroup to update.
     */
    where: EggGroupWhereUniqueInput
  }

  /**
   * EggGroup updateMany
   */
  export type EggGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EggGroups.
     */
    data: XOR<EggGroupUpdateManyMutationInput, EggGroupUncheckedUpdateManyInput>
    /**
     * Filter which EggGroups to update
     */
    where?: EggGroupWhereInput
    /**
     * Limit how many EggGroups to update.
     */
    limit?: number
  }

  /**
   * EggGroup updateManyAndReturn
   */
  export type EggGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggGroup
     */
    select?: EggGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EggGroup
     */
    omit?: EggGroupOmit<ExtArgs> | null
    /**
     * The data used to update EggGroups.
     */
    data: XOR<EggGroupUpdateManyMutationInput, EggGroupUncheckedUpdateManyInput>
    /**
     * Filter which EggGroups to update
     */
    where?: EggGroupWhereInput
    /**
     * Limit how many EggGroups to update.
     */
    limit?: number
  }

  /**
   * EggGroup upsert
   */
  export type EggGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggGroup
     */
    select?: EggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggGroup
     */
    omit?: EggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the EggGroup to update in case it exists.
     */
    where: EggGroupWhereUniqueInput
    /**
     * In case the EggGroup found by the `where` argument doesn't exist, create a new EggGroup with this data.
     */
    create: XOR<EggGroupCreateInput, EggGroupUncheckedCreateInput>
    /**
     * In case the EggGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EggGroupUpdateInput, EggGroupUncheckedUpdateInput>
  }

  /**
   * EggGroup delete
   */
  export type EggGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggGroup
     */
    select?: EggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggGroup
     */
    omit?: EggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggGroupInclude<ExtArgs> | null
    /**
     * Filter which EggGroup to delete.
     */
    where: EggGroupWhereUniqueInput
  }

  /**
   * EggGroup deleteMany
   */
  export type EggGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EggGroups to delete
     */
    where?: EggGroupWhereInput
    /**
     * Limit how many EggGroups to delete.
     */
    limit?: number
  }

  /**
   * EggGroup.pokemon_egg_group
   */
  export type EggGroup$pokemon_egg_groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonEggGroup
     */
    select?: PokemonEggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonEggGroup
     */
    omit?: PokemonEggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonEggGroupInclude<ExtArgs> | null
    where?: PokemonEggGroupWhereInput
    orderBy?: PokemonEggGroupOrderByWithRelationInput | PokemonEggGroupOrderByWithRelationInput[]
    cursor?: PokemonEggGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokemonEggGroupScalarFieldEnum | PokemonEggGroupScalarFieldEnum[]
  }

  /**
   * EggGroup without action
   */
  export type EggGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EggGroup
     */
    select?: EggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EggGroup
     */
    omit?: EggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EggGroupInclude<ExtArgs> | null
  }


  /**
   * Model PokemonEggGroup
   */

  export type AggregatePokemonEggGroup = {
    _count: PokemonEggGroupCountAggregateOutputType | null
    _avg: PokemonEggGroupAvgAggregateOutputType | null
    _sum: PokemonEggGroupSumAggregateOutputType | null
    _min: PokemonEggGroupMinAggregateOutputType | null
    _max: PokemonEggGroupMaxAggregateOutputType | null
  }

  export type PokemonEggGroupAvgAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    egg_group_id: number | null
  }

  export type PokemonEggGroupSumAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    egg_group_id: number | null
  }

  export type PokemonEggGroupMinAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    egg_group_id: number | null
  }

  export type PokemonEggGroupMaxAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    egg_group_id: number | null
  }

  export type PokemonEggGroupCountAggregateOutputType = {
    id: number
    pokemon_id: number
    egg_group_id: number
    _all: number
  }


  export type PokemonEggGroupAvgAggregateInputType = {
    id?: true
    pokemon_id?: true
    egg_group_id?: true
  }

  export type PokemonEggGroupSumAggregateInputType = {
    id?: true
    pokemon_id?: true
    egg_group_id?: true
  }

  export type PokemonEggGroupMinAggregateInputType = {
    id?: true
    pokemon_id?: true
    egg_group_id?: true
  }

  export type PokemonEggGroupMaxAggregateInputType = {
    id?: true
    pokemon_id?: true
    egg_group_id?: true
  }

  export type PokemonEggGroupCountAggregateInputType = {
    id?: true
    pokemon_id?: true
    egg_group_id?: true
    _all?: true
  }

  export type PokemonEggGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PokemonEggGroup to aggregate.
     */
    where?: PokemonEggGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonEggGroups to fetch.
     */
    orderBy?: PokemonEggGroupOrderByWithRelationInput | PokemonEggGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PokemonEggGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonEggGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonEggGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PokemonEggGroups
    **/
    _count?: true | PokemonEggGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PokemonEggGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PokemonEggGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PokemonEggGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PokemonEggGroupMaxAggregateInputType
  }

  export type GetPokemonEggGroupAggregateType<T extends PokemonEggGroupAggregateArgs> = {
        [P in keyof T & keyof AggregatePokemonEggGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePokemonEggGroup[P]>
      : GetScalarType<T[P], AggregatePokemonEggGroup[P]>
  }




  export type PokemonEggGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonEggGroupWhereInput
    orderBy?: PokemonEggGroupOrderByWithAggregationInput | PokemonEggGroupOrderByWithAggregationInput[]
    by: PokemonEggGroupScalarFieldEnum[] | PokemonEggGroupScalarFieldEnum
    having?: PokemonEggGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PokemonEggGroupCountAggregateInputType | true
    _avg?: PokemonEggGroupAvgAggregateInputType
    _sum?: PokemonEggGroupSumAggregateInputType
    _min?: PokemonEggGroupMinAggregateInputType
    _max?: PokemonEggGroupMaxAggregateInputType
  }

  export type PokemonEggGroupGroupByOutputType = {
    id: number
    pokemon_id: number
    egg_group_id: number
    _count: PokemonEggGroupCountAggregateOutputType | null
    _avg: PokemonEggGroupAvgAggregateOutputType | null
    _sum: PokemonEggGroupSumAggregateOutputType | null
    _min: PokemonEggGroupMinAggregateOutputType | null
    _max: PokemonEggGroupMaxAggregateOutputType | null
  }

  type GetPokemonEggGroupGroupByPayload<T extends PokemonEggGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PokemonEggGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PokemonEggGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PokemonEggGroupGroupByOutputType[P]>
            : GetScalarType<T[P], PokemonEggGroupGroupByOutputType[P]>
        }
      >
    >


  export type PokemonEggGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pokemon_id?: boolean
    egg_group_id?: boolean
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    egg_group?: boolean | EggGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonEggGroup"]>

  export type PokemonEggGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pokemon_id?: boolean
    egg_group_id?: boolean
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    egg_group?: boolean | EggGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonEggGroup"]>

  export type PokemonEggGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pokemon_id?: boolean
    egg_group_id?: boolean
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    egg_group?: boolean | EggGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonEggGroup"]>

  export type PokemonEggGroupSelectScalar = {
    id?: boolean
    pokemon_id?: boolean
    egg_group_id?: boolean
  }

  export type PokemonEggGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pokemon_id" | "egg_group_id", ExtArgs["result"]["pokemonEggGroup"]>
  export type PokemonEggGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    egg_group?: boolean | EggGroupDefaultArgs<ExtArgs>
  }
  export type PokemonEggGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    egg_group?: boolean | EggGroupDefaultArgs<ExtArgs>
  }
  export type PokemonEggGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    egg_group?: boolean | EggGroupDefaultArgs<ExtArgs>
  }

  export type $PokemonEggGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PokemonEggGroup"
    objects: {
      pokemon: Prisma.$PokemonPayload<ExtArgs>
      egg_group: Prisma.$EggGroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pokemon_id: number
      egg_group_id: number
    }, ExtArgs["result"]["pokemonEggGroup"]>
    composites: {}
  }

  type PokemonEggGroupGetPayload<S extends boolean | null | undefined | PokemonEggGroupDefaultArgs> = $Result.GetResult<Prisma.$PokemonEggGroupPayload, S>

  type PokemonEggGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PokemonEggGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PokemonEggGroupCountAggregateInputType | true
    }

  export interface PokemonEggGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PokemonEggGroup'], meta: { name: 'PokemonEggGroup' } }
    /**
     * Find zero or one PokemonEggGroup that matches the filter.
     * @param {PokemonEggGroupFindUniqueArgs} args - Arguments to find a PokemonEggGroup
     * @example
     * // Get one PokemonEggGroup
     * const pokemonEggGroup = await prisma.pokemonEggGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PokemonEggGroupFindUniqueArgs>(args: SelectSubset<T, PokemonEggGroupFindUniqueArgs<ExtArgs>>): Prisma__PokemonEggGroupClient<$Result.GetResult<Prisma.$PokemonEggGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PokemonEggGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PokemonEggGroupFindUniqueOrThrowArgs} args - Arguments to find a PokemonEggGroup
     * @example
     * // Get one PokemonEggGroup
     * const pokemonEggGroup = await prisma.pokemonEggGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PokemonEggGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, PokemonEggGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PokemonEggGroupClient<$Result.GetResult<Prisma.$PokemonEggGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PokemonEggGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonEggGroupFindFirstArgs} args - Arguments to find a PokemonEggGroup
     * @example
     * // Get one PokemonEggGroup
     * const pokemonEggGroup = await prisma.pokemonEggGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PokemonEggGroupFindFirstArgs>(args?: SelectSubset<T, PokemonEggGroupFindFirstArgs<ExtArgs>>): Prisma__PokemonEggGroupClient<$Result.GetResult<Prisma.$PokemonEggGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PokemonEggGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonEggGroupFindFirstOrThrowArgs} args - Arguments to find a PokemonEggGroup
     * @example
     * // Get one PokemonEggGroup
     * const pokemonEggGroup = await prisma.pokemonEggGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PokemonEggGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, PokemonEggGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__PokemonEggGroupClient<$Result.GetResult<Prisma.$PokemonEggGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PokemonEggGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonEggGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PokemonEggGroups
     * const pokemonEggGroups = await prisma.pokemonEggGroup.findMany()
     * 
     * // Get first 10 PokemonEggGroups
     * const pokemonEggGroups = await prisma.pokemonEggGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pokemonEggGroupWithIdOnly = await prisma.pokemonEggGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PokemonEggGroupFindManyArgs>(args?: SelectSubset<T, PokemonEggGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonEggGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PokemonEggGroup.
     * @param {PokemonEggGroupCreateArgs} args - Arguments to create a PokemonEggGroup.
     * @example
     * // Create one PokemonEggGroup
     * const PokemonEggGroup = await prisma.pokemonEggGroup.create({
     *   data: {
     *     // ... data to create a PokemonEggGroup
     *   }
     * })
     * 
     */
    create<T extends PokemonEggGroupCreateArgs>(args: SelectSubset<T, PokemonEggGroupCreateArgs<ExtArgs>>): Prisma__PokemonEggGroupClient<$Result.GetResult<Prisma.$PokemonEggGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PokemonEggGroups.
     * @param {PokemonEggGroupCreateManyArgs} args - Arguments to create many PokemonEggGroups.
     * @example
     * // Create many PokemonEggGroups
     * const pokemonEggGroup = await prisma.pokemonEggGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PokemonEggGroupCreateManyArgs>(args?: SelectSubset<T, PokemonEggGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PokemonEggGroups and returns the data saved in the database.
     * @param {PokemonEggGroupCreateManyAndReturnArgs} args - Arguments to create many PokemonEggGroups.
     * @example
     * // Create many PokemonEggGroups
     * const pokemonEggGroup = await prisma.pokemonEggGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PokemonEggGroups and only return the `id`
     * const pokemonEggGroupWithIdOnly = await prisma.pokemonEggGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PokemonEggGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, PokemonEggGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonEggGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PokemonEggGroup.
     * @param {PokemonEggGroupDeleteArgs} args - Arguments to delete one PokemonEggGroup.
     * @example
     * // Delete one PokemonEggGroup
     * const PokemonEggGroup = await prisma.pokemonEggGroup.delete({
     *   where: {
     *     // ... filter to delete one PokemonEggGroup
     *   }
     * })
     * 
     */
    delete<T extends PokemonEggGroupDeleteArgs>(args: SelectSubset<T, PokemonEggGroupDeleteArgs<ExtArgs>>): Prisma__PokemonEggGroupClient<$Result.GetResult<Prisma.$PokemonEggGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PokemonEggGroup.
     * @param {PokemonEggGroupUpdateArgs} args - Arguments to update one PokemonEggGroup.
     * @example
     * // Update one PokemonEggGroup
     * const pokemonEggGroup = await prisma.pokemonEggGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PokemonEggGroupUpdateArgs>(args: SelectSubset<T, PokemonEggGroupUpdateArgs<ExtArgs>>): Prisma__PokemonEggGroupClient<$Result.GetResult<Prisma.$PokemonEggGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PokemonEggGroups.
     * @param {PokemonEggGroupDeleteManyArgs} args - Arguments to filter PokemonEggGroups to delete.
     * @example
     * // Delete a few PokemonEggGroups
     * const { count } = await prisma.pokemonEggGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PokemonEggGroupDeleteManyArgs>(args?: SelectSubset<T, PokemonEggGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PokemonEggGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonEggGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PokemonEggGroups
     * const pokemonEggGroup = await prisma.pokemonEggGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PokemonEggGroupUpdateManyArgs>(args: SelectSubset<T, PokemonEggGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PokemonEggGroups and returns the data updated in the database.
     * @param {PokemonEggGroupUpdateManyAndReturnArgs} args - Arguments to update many PokemonEggGroups.
     * @example
     * // Update many PokemonEggGroups
     * const pokemonEggGroup = await prisma.pokemonEggGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PokemonEggGroups and only return the `id`
     * const pokemonEggGroupWithIdOnly = await prisma.pokemonEggGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PokemonEggGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, PokemonEggGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonEggGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PokemonEggGroup.
     * @param {PokemonEggGroupUpsertArgs} args - Arguments to update or create a PokemonEggGroup.
     * @example
     * // Update or create a PokemonEggGroup
     * const pokemonEggGroup = await prisma.pokemonEggGroup.upsert({
     *   create: {
     *     // ... data to create a PokemonEggGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PokemonEggGroup we want to update
     *   }
     * })
     */
    upsert<T extends PokemonEggGroupUpsertArgs>(args: SelectSubset<T, PokemonEggGroupUpsertArgs<ExtArgs>>): Prisma__PokemonEggGroupClient<$Result.GetResult<Prisma.$PokemonEggGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PokemonEggGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonEggGroupCountArgs} args - Arguments to filter PokemonEggGroups to count.
     * @example
     * // Count the number of PokemonEggGroups
     * const count = await prisma.pokemonEggGroup.count({
     *   where: {
     *     // ... the filter for the PokemonEggGroups we want to count
     *   }
     * })
    **/
    count<T extends PokemonEggGroupCountArgs>(
      args?: Subset<T, PokemonEggGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PokemonEggGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PokemonEggGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonEggGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PokemonEggGroupAggregateArgs>(args: Subset<T, PokemonEggGroupAggregateArgs>): Prisma.PrismaPromise<GetPokemonEggGroupAggregateType<T>>

    /**
     * Group by PokemonEggGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonEggGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PokemonEggGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PokemonEggGroupGroupByArgs['orderBy'] }
        : { orderBy?: PokemonEggGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PokemonEggGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPokemonEggGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PokemonEggGroup model
   */
  readonly fields: PokemonEggGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PokemonEggGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PokemonEggGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pokemon<T extends PokemonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PokemonDefaultArgs<ExtArgs>>): Prisma__PokemonClient<$Result.GetResult<Prisma.$PokemonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    egg_group<T extends EggGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EggGroupDefaultArgs<ExtArgs>>): Prisma__EggGroupClient<$Result.GetResult<Prisma.$EggGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PokemonEggGroup model
   */
  interface PokemonEggGroupFieldRefs {
    readonly id: FieldRef<"PokemonEggGroup", 'Int'>
    readonly pokemon_id: FieldRef<"PokemonEggGroup", 'Int'>
    readonly egg_group_id: FieldRef<"PokemonEggGroup", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PokemonEggGroup findUnique
   */
  export type PokemonEggGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonEggGroup
     */
    select?: PokemonEggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonEggGroup
     */
    omit?: PokemonEggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonEggGroupInclude<ExtArgs> | null
    /**
     * Filter, which PokemonEggGroup to fetch.
     */
    where: PokemonEggGroupWhereUniqueInput
  }

  /**
   * PokemonEggGroup findUniqueOrThrow
   */
  export type PokemonEggGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonEggGroup
     */
    select?: PokemonEggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonEggGroup
     */
    omit?: PokemonEggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonEggGroupInclude<ExtArgs> | null
    /**
     * Filter, which PokemonEggGroup to fetch.
     */
    where: PokemonEggGroupWhereUniqueInput
  }

  /**
   * PokemonEggGroup findFirst
   */
  export type PokemonEggGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonEggGroup
     */
    select?: PokemonEggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonEggGroup
     */
    omit?: PokemonEggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonEggGroupInclude<ExtArgs> | null
    /**
     * Filter, which PokemonEggGroup to fetch.
     */
    where?: PokemonEggGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonEggGroups to fetch.
     */
    orderBy?: PokemonEggGroupOrderByWithRelationInput | PokemonEggGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PokemonEggGroups.
     */
    cursor?: PokemonEggGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonEggGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonEggGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PokemonEggGroups.
     */
    distinct?: PokemonEggGroupScalarFieldEnum | PokemonEggGroupScalarFieldEnum[]
  }

  /**
   * PokemonEggGroup findFirstOrThrow
   */
  export type PokemonEggGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonEggGroup
     */
    select?: PokemonEggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonEggGroup
     */
    omit?: PokemonEggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonEggGroupInclude<ExtArgs> | null
    /**
     * Filter, which PokemonEggGroup to fetch.
     */
    where?: PokemonEggGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonEggGroups to fetch.
     */
    orderBy?: PokemonEggGroupOrderByWithRelationInput | PokemonEggGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PokemonEggGroups.
     */
    cursor?: PokemonEggGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonEggGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonEggGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PokemonEggGroups.
     */
    distinct?: PokemonEggGroupScalarFieldEnum | PokemonEggGroupScalarFieldEnum[]
  }

  /**
   * PokemonEggGroup findMany
   */
  export type PokemonEggGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonEggGroup
     */
    select?: PokemonEggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonEggGroup
     */
    omit?: PokemonEggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonEggGroupInclude<ExtArgs> | null
    /**
     * Filter, which PokemonEggGroups to fetch.
     */
    where?: PokemonEggGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonEggGroups to fetch.
     */
    orderBy?: PokemonEggGroupOrderByWithRelationInput | PokemonEggGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PokemonEggGroups.
     */
    cursor?: PokemonEggGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonEggGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonEggGroups.
     */
    skip?: number
    distinct?: PokemonEggGroupScalarFieldEnum | PokemonEggGroupScalarFieldEnum[]
  }

  /**
   * PokemonEggGroup create
   */
  export type PokemonEggGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonEggGroup
     */
    select?: PokemonEggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonEggGroup
     */
    omit?: PokemonEggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonEggGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a PokemonEggGroup.
     */
    data: XOR<PokemonEggGroupCreateInput, PokemonEggGroupUncheckedCreateInput>
  }

  /**
   * PokemonEggGroup createMany
   */
  export type PokemonEggGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PokemonEggGroups.
     */
    data: PokemonEggGroupCreateManyInput | PokemonEggGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PokemonEggGroup createManyAndReturn
   */
  export type PokemonEggGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonEggGroup
     */
    select?: PokemonEggGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonEggGroup
     */
    omit?: PokemonEggGroupOmit<ExtArgs> | null
    /**
     * The data used to create many PokemonEggGroups.
     */
    data: PokemonEggGroupCreateManyInput | PokemonEggGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonEggGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PokemonEggGroup update
   */
  export type PokemonEggGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonEggGroup
     */
    select?: PokemonEggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonEggGroup
     */
    omit?: PokemonEggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonEggGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a PokemonEggGroup.
     */
    data: XOR<PokemonEggGroupUpdateInput, PokemonEggGroupUncheckedUpdateInput>
    /**
     * Choose, which PokemonEggGroup to update.
     */
    where: PokemonEggGroupWhereUniqueInput
  }

  /**
   * PokemonEggGroup updateMany
   */
  export type PokemonEggGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PokemonEggGroups.
     */
    data: XOR<PokemonEggGroupUpdateManyMutationInput, PokemonEggGroupUncheckedUpdateManyInput>
    /**
     * Filter which PokemonEggGroups to update
     */
    where?: PokemonEggGroupWhereInput
    /**
     * Limit how many PokemonEggGroups to update.
     */
    limit?: number
  }

  /**
   * PokemonEggGroup updateManyAndReturn
   */
  export type PokemonEggGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonEggGroup
     */
    select?: PokemonEggGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonEggGroup
     */
    omit?: PokemonEggGroupOmit<ExtArgs> | null
    /**
     * The data used to update PokemonEggGroups.
     */
    data: XOR<PokemonEggGroupUpdateManyMutationInput, PokemonEggGroupUncheckedUpdateManyInput>
    /**
     * Filter which PokemonEggGroups to update
     */
    where?: PokemonEggGroupWhereInput
    /**
     * Limit how many PokemonEggGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonEggGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PokemonEggGroup upsert
   */
  export type PokemonEggGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonEggGroup
     */
    select?: PokemonEggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonEggGroup
     */
    omit?: PokemonEggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonEggGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the PokemonEggGroup to update in case it exists.
     */
    where: PokemonEggGroupWhereUniqueInput
    /**
     * In case the PokemonEggGroup found by the `where` argument doesn't exist, create a new PokemonEggGroup with this data.
     */
    create: XOR<PokemonEggGroupCreateInput, PokemonEggGroupUncheckedCreateInput>
    /**
     * In case the PokemonEggGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PokemonEggGroupUpdateInput, PokemonEggGroupUncheckedUpdateInput>
  }

  /**
   * PokemonEggGroup delete
   */
  export type PokemonEggGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonEggGroup
     */
    select?: PokemonEggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonEggGroup
     */
    omit?: PokemonEggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonEggGroupInclude<ExtArgs> | null
    /**
     * Filter which PokemonEggGroup to delete.
     */
    where: PokemonEggGroupWhereUniqueInput
  }

  /**
   * PokemonEggGroup deleteMany
   */
  export type PokemonEggGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PokemonEggGroups to delete
     */
    where?: PokemonEggGroupWhereInput
    /**
     * Limit how many PokemonEggGroups to delete.
     */
    limit?: number
  }

  /**
   * PokemonEggGroup without action
   */
  export type PokemonEggGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonEggGroup
     */
    select?: PokemonEggGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonEggGroup
     */
    omit?: PokemonEggGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonEggGroupInclude<ExtArgs> | null
  }


  /**
   * Model Region
   */

  export type AggregateRegion = {
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  export type RegionAvgAggregateOutputType = {
    id: number | null
  }

  export type RegionSumAggregateOutputType = {
    id: number | null
  }

  export type RegionMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RegionMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RegionCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RegionAvgAggregateInputType = {
    id?: true
  }

  export type RegionSumAggregateInputType = {
    id?: true
  }

  export type RegionMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RegionMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RegionCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RegionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Region to aggregate.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regions
    **/
    _count?: true | RegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionMaxAggregateInputType
  }

  export type GetRegionAggregateType<T extends RegionAggregateArgs> = {
        [P in keyof T & keyof AggregateRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegion[P]>
      : GetScalarType<T[P], AggregateRegion[P]>
  }




  export type RegionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithAggregationInput | RegionOrderByWithAggregationInput[]
    by: RegionScalarFieldEnum[] | RegionScalarFieldEnum
    having?: RegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionCountAggregateInputType | true
    _avg?: RegionAvgAggregateInputType
    _sum?: RegionSumAggregateInputType
    _min?: RegionMinAggregateInputType
    _max?: RegionMaxAggregateInputType
  }

  export type RegionGroupByOutputType = {
    id: number
    name: string
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  type GetRegionGroupByPayload<T extends RegionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionGroupByOutputType[P]>
            : GetScalarType<T[P], RegionGroupByOutputType[P]>
        }
      >
    >


  export type RegionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    locations?: boolean | Region$locationsArgs<ExtArgs>
    version_groups?: boolean | Region$version_groupsArgs<ExtArgs>
    generations?: boolean | Region$generationsArgs<ExtArgs>
    pokedex?: boolean | Region$pokedexArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["region"]>

  export type RegionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["region"]>

  export type RegionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["region"]>

  export type RegionSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type RegionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["region"]>
  export type RegionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    locations?: boolean | Region$locationsArgs<ExtArgs>
    version_groups?: boolean | Region$version_groupsArgs<ExtArgs>
    generations?: boolean | Region$generationsArgs<ExtArgs>
    pokedex?: boolean | Region$pokedexArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RegionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RegionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RegionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Region"
    objects: {
      locations: Prisma.$LocationPayload<ExtArgs>[]
      version_groups: Prisma.$VersionGroupRegionPayload<ExtArgs>[]
      generations: Prisma.$GenerationPayload<ExtArgs> | null
      pokedex: Prisma.$PokedexPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["region"]>
    composites: {}
  }

  type RegionGetPayload<S extends boolean | null | undefined | RegionDefaultArgs> = $Result.GetResult<Prisma.$RegionPayload, S>

  type RegionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegionCountAggregateInputType | true
    }

  export interface RegionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Region'], meta: { name: 'Region' } }
    /**
     * Find zero or one Region that matches the filter.
     * @param {RegionFindUniqueArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegionFindUniqueArgs>(args: SelectSubset<T, RegionFindUniqueArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Region that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegionFindUniqueOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegionFindUniqueOrThrowArgs>(args: SelectSubset<T, RegionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Region that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegionFindFirstArgs>(args?: SelectSubset<T, RegionFindFirstArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Region that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegionFindFirstOrThrowArgs>(args?: SelectSubset<T, RegionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.region.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.region.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionWithIdOnly = await prisma.region.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegionFindManyArgs>(args?: SelectSubset<T, RegionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Region.
     * @param {RegionCreateArgs} args - Arguments to create a Region.
     * @example
     * // Create one Region
     * const Region = await prisma.region.create({
     *   data: {
     *     // ... data to create a Region
     *   }
     * })
     * 
     */
    create<T extends RegionCreateArgs>(args: SelectSubset<T, RegionCreateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Regions.
     * @param {RegionCreateManyArgs} args - Arguments to create many Regions.
     * @example
     * // Create many Regions
     * const region = await prisma.region.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegionCreateManyArgs>(args?: SelectSubset<T, RegionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Regions and returns the data saved in the database.
     * @param {RegionCreateManyAndReturnArgs} args - Arguments to create many Regions.
     * @example
     * // Create many Regions
     * const region = await prisma.region.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Regions and only return the `id`
     * const regionWithIdOnly = await prisma.region.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegionCreateManyAndReturnArgs>(args?: SelectSubset<T, RegionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Region.
     * @param {RegionDeleteArgs} args - Arguments to delete one Region.
     * @example
     * // Delete one Region
     * const Region = await prisma.region.delete({
     *   where: {
     *     // ... filter to delete one Region
     *   }
     * })
     * 
     */
    delete<T extends RegionDeleteArgs>(args: SelectSubset<T, RegionDeleteArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Region.
     * @param {RegionUpdateArgs} args - Arguments to update one Region.
     * @example
     * // Update one Region
     * const region = await prisma.region.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegionUpdateArgs>(args: SelectSubset<T, RegionUpdateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Regions.
     * @param {RegionDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.region.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegionDeleteManyArgs>(args?: SelectSubset<T, RegionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegionUpdateManyArgs>(args: SelectSubset<T, RegionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions and returns the data updated in the database.
     * @param {RegionUpdateManyAndReturnArgs} args - Arguments to update many Regions.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Regions and only return the `id`
     * const regionWithIdOnly = await prisma.region.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RegionUpdateManyAndReturnArgs>(args: SelectSubset<T, RegionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Region.
     * @param {RegionUpsertArgs} args - Arguments to update or create a Region.
     * @example
     * // Update or create a Region
     * const region = await prisma.region.upsert({
     *   create: {
     *     // ... data to create a Region
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Region we want to update
     *   }
     * })
     */
    upsert<T extends RegionUpsertArgs>(args: SelectSubset<T, RegionUpsertArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.region.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends RegionCountArgs>(
      args?: Subset<T, RegionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionAggregateArgs>(args: Subset<T, RegionAggregateArgs>): Prisma.PrismaPromise<GetRegionAggregateType<T>>

    /**
     * Group by Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionGroupByArgs['orderBy'] }
        : { orderBy?: RegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Region model
   */
  readonly fields: RegionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Region.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    locations<T extends Region$locationsArgs<ExtArgs> = {}>(args?: Subset<T, Region$locationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    version_groups<T extends Region$version_groupsArgs<ExtArgs> = {}>(args?: Subset<T, Region$version_groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionGroupRegionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generations<T extends Region$generationsArgs<ExtArgs> = {}>(args?: Subset<T, Region$generationsArgs<ExtArgs>>): Prisma__GenerationClient<$Result.GetResult<Prisma.$GenerationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pokedex<T extends Region$pokedexArgs<ExtArgs> = {}>(args?: Subset<T, Region$pokedexArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokedexPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Region model
   */
  interface RegionFieldRefs {
    readonly id: FieldRef<"Region", 'Int'>
    readonly name: FieldRef<"Region", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Region findUnique
   */
  export type RegionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findUniqueOrThrow
   */
  export type RegionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findFirst
   */
  export type RegionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findFirstOrThrow
   */
  export type RegionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findMany
   */
  export type RegionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Regions to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region create
   */
  export type RegionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to create a Region.
     */
    data: XOR<RegionCreateInput, RegionUncheckedCreateInput>
  }

  /**
   * Region createMany
   */
  export type RegionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Region createManyAndReturn
   */
  export type RegionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Region update
   */
  export type RegionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to update a Region.
     */
    data: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
    /**
     * Choose, which Region to update.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region updateMany
   */
  export type RegionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to update.
     */
    limit?: number
  }

  /**
   * Region updateManyAndReturn
   */
  export type RegionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to update.
     */
    limit?: number
  }

  /**
   * Region upsert
   */
  export type RegionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The filter to search for the Region to update in case it exists.
     */
    where: RegionWhereUniqueInput
    /**
     * In case the Region found by the `where` argument doesn't exist, create a new Region with this data.
     */
    create: XOR<RegionCreateInput, RegionUncheckedCreateInput>
    /**
     * In case the Region was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
  }

  /**
   * Region delete
   */
  export type RegionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter which Region to delete.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region deleteMany
   */
  export type RegionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regions to delete
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to delete.
     */
    limit?: number
  }

  /**
   * Region.locations
   */
  export type Region$locationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    cursor?: LocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Region.version_groups
   */
  export type Region$version_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroupRegion
     */
    select?: VersionGroupRegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroupRegion
     */
    omit?: VersionGroupRegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupRegionInclude<ExtArgs> | null
    where?: VersionGroupRegionWhereInput
    orderBy?: VersionGroupRegionOrderByWithRelationInput | VersionGroupRegionOrderByWithRelationInput[]
    cursor?: VersionGroupRegionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VersionGroupRegionScalarFieldEnum | VersionGroupRegionScalarFieldEnum[]
  }

  /**
   * Region.generations
   */
  export type Region$generationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Generation
     */
    select?: GenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Generation
     */
    omit?: GenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenerationInclude<ExtArgs> | null
    where?: GenerationWhereInput
  }

  /**
   * Region.pokedex
   */
  export type Region$pokedexArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokedex
     */
    select?: PokedexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokedex
     */
    omit?: PokedexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexInclude<ExtArgs> | null
    where?: PokedexWhereInput
    orderBy?: PokedexOrderByWithRelationInput | PokedexOrderByWithRelationInput[]
    cursor?: PokedexWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokedexScalarFieldEnum | PokedexScalarFieldEnum[]
  }

  /**
   * Region without action
   */
  export type RegionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
  }


  /**
   * Model Generation
   */

  export type AggregateGeneration = {
    _count: GenerationCountAggregateOutputType | null
    _avg: GenerationAvgAggregateOutputType | null
    _sum: GenerationSumAggregateOutputType | null
    _min: GenerationMinAggregateOutputType | null
    _max: GenerationMaxAggregateOutputType | null
  }

  export type GenerationAvgAggregateOutputType = {
    id: number | null
    region_id: number | null
  }

  export type GenerationSumAggregateOutputType = {
    id: number | null
    region_id: number | null
  }

  export type GenerationMinAggregateOutputType = {
    id: number | null
    name: string | null
    region_id: number | null
  }

  export type GenerationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    region_id: number | null
  }

  export type GenerationCountAggregateOutputType = {
    id: number
    name: number
    region_id: number
    _all: number
  }


  export type GenerationAvgAggregateInputType = {
    id?: true
    region_id?: true
  }

  export type GenerationSumAggregateInputType = {
    id?: true
    region_id?: true
  }

  export type GenerationMinAggregateInputType = {
    id?: true
    name?: true
    region_id?: true
  }

  export type GenerationMaxAggregateInputType = {
    id?: true
    name?: true
    region_id?: true
  }

  export type GenerationCountAggregateInputType = {
    id?: true
    name?: true
    region_id?: true
    _all?: true
  }

  export type GenerationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Generation to aggregate.
     */
    where?: GenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Generations to fetch.
     */
    orderBy?: GenerationOrderByWithRelationInput | GenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Generations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Generations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Generations
    **/
    _count?: true | GenerationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GenerationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GenerationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenerationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenerationMaxAggregateInputType
  }

  export type GetGenerationAggregateType<T extends GenerationAggregateArgs> = {
        [P in keyof T & keyof AggregateGeneration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneration[P]>
      : GetScalarType<T[P], AggregateGeneration[P]>
  }




  export type GenerationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenerationWhereInput
    orderBy?: GenerationOrderByWithAggregationInput | GenerationOrderByWithAggregationInput[]
    by: GenerationScalarFieldEnum[] | GenerationScalarFieldEnum
    having?: GenerationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenerationCountAggregateInputType | true
    _avg?: GenerationAvgAggregateInputType
    _sum?: GenerationSumAggregateInputType
    _min?: GenerationMinAggregateInputType
    _max?: GenerationMaxAggregateInputType
  }

  export type GenerationGroupByOutputType = {
    id: number
    name: string
    region_id: number
    _count: GenerationCountAggregateOutputType | null
    _avg: GenerationAvgAggregateOutputType | null
    _sum: GenerationSumAggregateOutputType | null
    _min: GenerationMinAggregateOutputType | null
    _max: GenerationMaxAggregateOutputType | null
  }

  type GetGenerationGroupByPayload<T extends GenerationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenerationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenerationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenerationGroupByOutputType[P]>
            : GetScalarType<T[P], GenerationGroupByOutputType[P]>
        }
      >
    >


  export type GenerationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    region_id?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    types?: boolean | Generation$typesArgs<ExtArgs>
    versionGroups?: boolean | Generation$versionGroupsArgs<ExtArgs>
    _count?: boolean | GenerationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["generation"]>

  export type GenerationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    region_id?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["generation"]>

  export type GenerationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    region_id?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["generation"]>

  export type GenerationSelectScalar = {
    id?: boolean
    name?: boolean
    region_id?: boolean
  }

  export type GenerationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "region_id", ExtArgs["result"]["generation"]>
  export type GenerationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    types?: boolean | Generation$typesArgs<ExtArgs>
    versionGroups?: boolean | Generation$versionGroupsArgs<ExtArgs>
    _count?: boolean | GenerationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GenerationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }
  export type GenerationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }

  export type $GenerationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Generation"
    objects: {
      region: Prisma.$RegionPayload<ExtArgs>
      types: Prisma.$TypePayload<ExtArgs>[]
      versionGroups: Prisma.$VersionGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      region_id: number
    }, ExtArgs["result"]["generation"]>
    composites: {}
  }

  type GenerationGetPayload<S extends boolean | null | undefined | GenerationDefaultArgs> = $Result.GetResult<Prisma.$GenerationPayload, S>

  type GenerationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GenerationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenerationCountAggregateInputType | true
    }

  export interface GenerationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Generation'], meta: { name: 'Generation' } }
    /**
     * Find zero or one Generation that matches the filter.
     * @param {GenerationFindUniqueArgs} args - Arguments to find a Generation
     * @example
     * // Get one Generation
     * const generation = await prisma.generation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenerationFindUniqueArgs>(args: SelectSubset<T, GenerationFindUniqueArgs<ExtArgs>>): Prisma__GenerationClient<$Result.GetResult<Prisma.$GenerationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Generation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GenerationFindUniqueOrThrowArgs} args - Arguments to find a Generation
     * @example
     * // Get one Generation
     * const generation = await prisma.generation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenerationFindUniqueOrThrowArgs>(args: SelectSubset<T, GenerationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenerationClient<$Result.GetResult<Prisma.$GenerationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Generation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenerationFindFirstArgs} args - Arguments to find a Generation
     * @example
     * // Get one Generation
     * const generation = await prisma.generation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenerationFindFirstArgs>(args?: SelectSubset<T, GenerationFindFirstArgs<ExtArgs>>): Prisma__GenerationClient<$Result.GetResult<Prisma.$GenerationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Generation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenerationFindFirstOrThrowArgs} args - Arguments to find a Generation
     * @example
     * // Get one Generation
     * const generation = await prisma.generation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenerationFindFirstOrThrowArgs>(args?: SelectSubset<T, GenerationFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenerationClient<$Result.GetResult<Prisma.$GenerationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Generations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenerationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Generations
     * const generations = await prisma.generation.findMany()
     * 
     * // Get first 10 Generations
     * const generations = await prisma.generation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const generationWithIdOnly = await prisma.generation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GenerationFindManyArgs>(args?: SelectSubset<T, GenerationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenerationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Generation.
     * @param {GenerationCreateArgs} args - Arguments to create a Generation.
     * @example
     * // Create one Generation
     * const Generation = await prisma.generation.create({
     *   data: {
     *     // ... data to create a Generation
     *   }
     * })
     * 
     */
    create<T extends GenerationCreateArgs>(args: SelectSubset<T, GenerationCreateArgs<ExtArgs>>): Prisma__GenerationClient<$Result.GetResult<Prisma.$GenerationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Generations.
     * @param {GenerationCreateManyArgs} args - Arguments to create many Generations.
     * @example
     * // Create many Generations
     * const generation = await prisma.generation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenerationCreateManyArgs>(args?: SelectSubset<T, GenerationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Generations and returns the data saved in the database.
     * @param {GenerationCreateManyAndReturnArgs} args - Arguments to create many Generations.
     * @example
     * // Create many Generations
     * const generation = await prisma.generation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Generations and only return the `id`
     * const generationWithIdOnly = await prisma.generation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GenerationCreateManyAndReturnArgs>(args?: SelectSubset<T, GenerationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenerationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Generation.
     * @param {GenerationDeleteArgs} args - Arguments to delete one Generation.
     * @example
     * // Delete one Generation
     * const Generation = await prisma.generation.delete({
     *   where: {
     *     // ... filter to delete one Generation
     *   }
     * })
     * 
     */
    delete<T extends GenerationDeleteArgs>(args: SelectSubset<T, GenerationDeleteArgs<ExtArgs>>): Prisma__GenerationClient<$Result.GetResult<Prisma.$GenerationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Generation.
     * @param {GenerationUpdateArgs} args - Arguments to update one Generation.
     * @example
     * // Update one Generation
     * const generation = await prisma.generation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenerationUpdateArgs>(args: SelectSubset<T, GenerationUpdateArgs<ExtArgs>>): Prisma__GenerationClient<$Result.GetResult<Prisma.$GenerationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Generations.
     * @param {GenerationDeleteManyArgs} args - Arguments to filter Generations to delete.
     * @example
     * // Delete a few Generations
     * const { count } = await prisma.generation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenerationDeleteManyArgs>(args?: SelectSubset<T, GenerationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Generations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenerationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Generations
     * const generation = await prisma.generation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenerationUpdateManyArgs>(args: SelectSubset<T, GenerationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Generations and returns the data updated in the database.
     * @param {GenerationUpdateManyAndReturnArgs} args - Arguments to update many Generations.
     * @example
     * // Update many Generations
     * const generation = await prisma.generation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Generations and only return the `id`
     * const generationWithIdOnly = await prisma.generation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GenerationUpdateManyAndReturnArgs>(args: SelectSubset<T, GenerationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenerationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Generation.
     * @param {GenerationUpsertArgs} args - Arguments to update or create a Generation.
     * @example
     * // Update or create a Generation
     * const generation = await prisma.generation.upsert({
     *   create: {
     *     // ... data to create a Generation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Generation we want to update
     *   }
     * })
     */
    upsert<T extends GenerationUpsertArgs>(args: SelectSubset<T, GenerationUpsertArgs<ExtArgs>>): Prisma__GenerationClient<$Result.GetResult<Prisma.$GenerationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Generations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenerationCountArgs} args - Arguments to filter Generations to count.
     * @example
     * // Count the number of Generations
     * const count = await prisma.generation.count({
     *   where: {
     *     // ... the filter for the Generations we want to count
     *   }
     * })
    **/
    count<T extends GenerationCountArgs>(
      args?: Subset<T, GenerationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenerationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Generation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenerationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenerationAggregateArgs>(args: Subset<T, GenerationAggregateArgs>): Prisma.PrismaPromise<GetGenerationAggregateType<T>>

    /**
     * Group by Generation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenerationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenerationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenerationGroupByArgs['orderBy'] }
        : { orderBy?: GenerationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenerationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenerationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Generation model
   */
  readonly fields: GenerationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Generation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenerationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    region<T extends RegionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionDefaultArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    types<T extends Generation$typesArgs<ExtArgs> = {}>(args?: Subset<T, Generation$typesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    versionGroups<T extends Generation$versionGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Generation$versionGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Generation model
   */
  interface GenerationFieldRefs {
    readonly id: FieldRef<"Generation", 'Int'>
    readonly name: FieldRef<"Generation", 'String'>
    readonly region_id: FieldRef<"Generation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Generation findUnique
   */
  export type GenerationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Generation
     */
    select?: GenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Generation
     */
    omit?: GenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenerationInclude<ExtArgs> | null
    /**
     * Filter, which Generation to fetch.
     */
    where: GenerationWhereUniqueInput
  }

  /**
   * Generation findUniqueOrThrow
   */
  export type GenerationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Generation
     */
    select?: GenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Generation
     */
    omit?: GenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenerationInclude<ExtArgs> | null
    /**
     * Filter, which Generation to fetch.
     */
    where: GenerationWhereUniqueInput
  }

  /**
   * Generation findFirst
   */
  export type GenerationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Generation
     */
    select?: GenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Generation
     */
    omit?: GenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenerationInclude<ExtArgs> | null
    /**
     * Filter, which Generation to fetch.
     */
    where?: GenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Generations to fetch.
     */
    orderBy?: GenerationOrderByWithRelationInput | GenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Generations.
     */
    cursor?: GenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Generations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Generations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Generations.
     */
    distinct?: GenerationScalarFieldEnum | GenerationScalarFieldEnum[]
  }

  /**
   * Generation findFirstOrThrow
   */
  export type GenerationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Generation
     */
    select?: GenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Generation
     */
    omit?: GenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenerationInclude<ExtArgs> | null
    /**
     * Filter, which Generation to fetch.
     */
    where?: GenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Generations to fetch.
     */
    orderBy?: GenerationOrderByWithRelationInput | GenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Generations.
     */
    cursor?: GenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Generations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Generations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Generations.
     */
    distinct?: GenerationScalarFieldEnum | GenerationScalarFieldEnum[]
  }

  /**
   * Generation findMany
   */
  export type GenerationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Generation
     */
    select?: GenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Generation
     */
    omit?: GenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenerationInclude<ExtArgs> | null
    /**
     * Filter, which Generations to fetch.
     */
    where?: GenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Generations to fetch.
     */
    orderBy?: GenerationOrderByWithRelationInput | GenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Generations.
     */
    cursor?: GenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Generations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Generations.
     */
    skip?: number
    distinct?: GenerationScalarFieldEnum | GenerationScalarFieldEnum[]
  }

  /**
   * Generation create
   */
  export type GenerationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Generation
     */
    select?: GenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Generation
     */
    omit?: GenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenerationInclude<ExtArgs> | null
    /**
     * The data needed to create a Generation.
     */
    data: XOR<GenerationCreateInput, GenerationUncheckedCreateInput>
  }

  /**
   * Generation createMany
   */
  export type GenerationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Generations.
     */
    data: GenerationCreateManyInput | GenerationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Generation createManyAndReturn
   */
  export type GenerationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Generation
     */
    select?: GenerationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Generation
     */
    omit?: GenerationOmit<ExtArgs> | null
    /**
     * The data used to create many Generations.
     */
    data: GenerationCreateManyInput | GenerationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenerationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Generation update
   */
  export type GenerationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Generation
     */
    select?: GenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Generation
     */
    omit?: GenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenerationInclude<ExtArgs> | null
    /**
     * The data needed to update a Generation.
     */
    data: XOR<GenerationUpdateInput, GenerationUncheckedUpdateInput>
    /**
     * Choose, which Generation to update.
     */
    where: GenerationWhereUniqueInput
  }

  /**
   * Generation updateMany
   */
  export type GenerationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Generations.
     */
    data: XOR<GenerationUpdateManyMutationInput, GenerationUncheckedUpdateManyInput>
    /**
     * Filter which Generations to update
     */
    where?: GenerationWhereInput
    /**
     * Limit how many Generations to update.
     */
    limit?: number
  }

  /**
   * Generation updateManyAndReturn
   */
  export type GenerationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Generation
     */
    select?: GenerationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Generation
     */
    omit?: GenerationOmit<ExtArgs> | null
    /**
     * The data used to update Generations.
     */
    data: XOR<GenerationUpdateManyMutationInput, GenerationUncheckedUpdateManyInput>
    /**
     * Filter which Generations to update
     */
    where?: GenerationWhereInput
    /**
     * Limit how many Generations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenerationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Generation upsert
   */
  export type GenerationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Generation
     */
    select?: GenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Generation
     */
    omit?: GenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenerationInclude<ExtArgs> | null
    /**
     * The filter to search for the Generation to update in case it exists.
     */
    where: GenerationWhereUniqueInput
    /**
     * In case the Generation found by the `where` argument doesn't exist, create a new Generation with this data.
     */
    create: XOR<GenerationCreateInput, GenerationUncheckedCreateInput>
    /**
     * In case the Generation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenerationUpdateInput, GenerationUncheckedUpdateInput>
  }

  /**
   * Generation delete
   */
  export type GenerationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Generation
     */
    select?: GenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Generation
     */
    omit?: GenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenerationInclude<ExtArgs> | null
    /**
     * Filter which Generation to delete.
     */
    where: GenerationWhereUniqueInput
  }

  /**
   * Generation deleteMany
   */
  export type GenerationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Generations to delete
     */
    where?: GenerationWhereInput
    /**
     * Limit how many Generations to delete.
     */
    limit?: number
  }

  /**
   * Generation.types
   */
  export type Generation$typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Type
     */
    select?: TypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Type
     */
    omit?: TypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TypeInclude<ExtArgs> | null
    where?: TypeWhereInput
    orderBy?: TypeOrderByWithRelationInput | TypeOrderByWithRelationInput[]
    cursor?: TypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TypeScalarFieldEnum | TypeScalarFieldEnum[]
  }

  /**
   * Generation.versionGroups
   */
  export type Generation$versionGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroup
     */
    select?: VersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroup
     */
    omit?: VersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupInclude<ExtArgs> | null
    where?: VersionGroupWhereInput
    orderBy?: VersionGroupOrderByWithRelationInput | VersionGroupOrderByWithRelationInput[]
    cursor?: VersionGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VersionGroupScalarFieldEnum | VersionGroupScalarFieldEnum[]
  }

  /**
   * Generation without action
   */
  export type GenerationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Generation
     */
    select?: GenerationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Generation
     */
    omit?: GenerationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenerationInclude<ExtArgs> | null
  }


  /**
   * Model VersionGroup
   */

  export type AggregateVersionGroup = {
    _count: VersionGroupCountAggregateOutputType | null
    _avg: VersionGroupAvgAggregateOutputType | null
    _sum: VersionGroupSumAggregateOutputType | null
    _min: VersionGroupMinAggregateOutputType | null
    _max: VersionGroupMaxAggregateOutputType | null
  }

  export type VersionGroupAvgAggregateOutputType = {
    id: number | null
    generation_id: number | null
  }

  export type VersionGroupSumAggregateOutputType = {
    id: number | null
    generation_id: number | null
  }

  export type VersionGroupMinAggregateOutputType = {
    id: number | null
    name: string | null
    generation_id: number | null
  }

  export type VersionGroupMaxAggregateOutputType = {
    id: number | null
    name: string | null
    generation_id: number | null
  }

  export type VersionGroupCountAggregateOutputType = {
    id: number
    name: number
    generation_id: number
    _all: number
  }


  export type VersionGroupAvgAggregateInputType = {
    id?: true
    generation_id?: true
  }

  export type VersionGroupSumAggregateInputType = {
    id?: true
    generation_id?: true
  }

  export type VersionGroupMinAggregateInputType = {
    id?: true
    name?: true
    generation_id?: true
  }

  export type VersionGroupMaxAggregateInputType = {
    id?: true
    name?: true
    generation_id?: true
  }

  export type VersionGroupCountAggregateInputType = {
    id?: true
    name?: true
    generation_id?: true
    _all?: true
  }

  export type VersionGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VersionGroup to aggregate.
     */
    where?: VersionGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VersionGroups to fetch.
     */
    orderBy?: VersionGroupOrderByWithRelationInput | VersionGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VersionGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VersionGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VersionGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VersionGroups
    **/
    _count?: true | VersionGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VersionGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VersionGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VersionGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VersionGroupMaxAggregateInputType
  }

  export type GetVersionGroupAggregateType<T extends VersionGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateVersionGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVersionGroup[P]>
      : GetScalarType<T[P], AggregateVersionGroup[P]>
  }




  export type VersionGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VersionGroupWhereInput
    orderBy?: VersionGroupOrderByWithAggregationInput | VersionGroupOrderByWithAggregationInput[]
    by: VersionGroupScalarFieldEnum[] | VersionGroupScalarFieldEnum
    having?: VersionGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VersionGroupCountAggregateInputType | true
    _avg?: VersionGroupAvgAggregateInputType
    _sum?: VersionGroupSumAggregateInputType
    _min?: VersionGroupMinAggregateInputType
    _max?: VersionGroupMaxAggregateInputType
  }

  export type VersionGroupGroupByOutputType = {
    id: number
    name: string
    generation_id: number
    _count: VersionGroupCountAggregateOutputType | null
    _avg: VersionGroupAvgAggregateOutputType | null
    _sum: VersionGroupSumAggregateOutputType | null
    _min: VersionGroupMinAggregateOutputType | null
    _max: VersionGroupMaxAggregateOutputType | null
  }

  type GetVersionGroupGroupByPayload<T extends VersionGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VersionGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VersionGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VersionGroupGroupByOutputType[P]>
            : GetScalarType<T[P], VersionGroupGroupByOutputType[P]>
        }
      >
    >


  export type VersionGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    generation_id?: boolean
    generation?: boolean | GenerationDefaultArgs<ExtArgs>
    versions?: boolean | VersionGroup$versionsArgs<ExtArgs>
    regions?: boolean | VersionGroup$regionsArgs<ExtArgs>
    slots?: boolean | VersionGroup$slotsArgs<ExtArgs>
    moves?: boolean | VersionGroup$movesArgs<ExtArgs>
    pokedex_version_groups?: boolean | VersionGroup$pokedex_version_groupsArgs<ExtArgs>
    _count?: boolean | VersionGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["versionGroup"]>

  export type VersionGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    generation_id?: boolean
    generation?: boolean | GenerationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["versionGroup"]>

  export type VersionGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    generation_id?: boolean
    generation?: boolean | GenerationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["versionGroup"]>

  export type VersionGroupSelectScalar = {
    id?: boolean
    name?: boolean
    generation_id?: boolean
  }

  export type VersionGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "generation_id", ExtArgs["result"]["versionGroup"]>
  export type VersionGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generation?: boolean | GenerationDefaultArgs<ExtArgs>
    versions?: boolean | VersionGroup$versionsArgs<ExtArgs>
    regions?: boolean | VersionGroup$regionsArgs<ExtArgs>
    slots?: boolean | VersionGroup$slotsArgs<ExtArgs>
    moves?: boolean | VersionGroup$movesArgs<ExtArgs>
    pokedex_version_groups?: boolean | VersionGroup$pokedex_version_groupsArgs<ExtArgs>
    _count?: boolean | VersionGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VersionGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generation?: boolean | GenerationDefaultArgs<ExtArgs>
  }
  export type VersionGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generation?: boolean | GenerationDefaultArgs<ExtArgs>
  }

  export type $VersionGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VersionGroup"
    objects: {
      generation: Prisma.$GenerationPayload<ExtArgs>
      versions: Prisma.$VersionPayload<ExtArgs>[]
      regions: Prisma.$VersionGroupRegionPayload<ExtArgs>[]
      slots: Prisma.$EncounterSlotPayload<ExtArgs>[]
      moves: Prisma.$PokemonMovePayload<ExtArgs>[]
      pokedex_version_groups: Prisma.$PokedexVersionGroupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      generation_id: number
    }, ExtArgs["result"]["versionGroup"]>
    composites: {}
  }

  type VersionGroupGetPayload<S extends boolean | null | undefined | VersionGroupDefaultArgs> = $Result.GetResult<Prisma.$VersionGroupPayload, S>

  type VersionGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VersionGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VersionGroupCountAggregateInputType | true
    }

  export interface VersionGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VersionGroup'], meta: { name: 'VersionGroup' } }
    /**
     * Find zero or one VersionGroup that matches the filter.
     * @param {VersionGroupFindUniqueArgs} args - Arguments to find a VersionGroup
     * @example
     * // Get one VersionGroup
     * const versionGroup = await prisma.versionGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VersionGroupFindUniqueArgs>(args: SelectSubset<T, VersionGroupFindUniqueArgs<ExtArgs>>): Prisma__VersionGroupClient<$Result.GetResult<Prisma.$VersionGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VersionGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VersionGroupFindUniqueOrThrowArgs} args - Arguments to find a VersionGroup
     * @example
     * // Get one VersionGroup
     * const versionGroup = await prisma.versionGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VersionGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, VersionGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VersionGroupClient<$Result.GetResult<Prisma.$VersionGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VersionGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionGroupFindFirstArgs} args - Arguments to find a VersionGroup
     * @example
     * // Get one VersionGroup
     * const versionGroup = await prisma.versionGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VersionGroupFindFirstArgs>(args?: SelectSubset<T, VersionGroupFindFirstArgs<ExtArgs>>): Prisma__VersionGroupClient<$Result.GetResult<Prisma.$VersionGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VersionGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionGroupFindFirstOrThrowArgs} args - Arguments to find a VersionGroup
     * @example
     * // Get one VersionGroup
     * const versionGroup = await prisma.versionGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VersionGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, VersionGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__VersionGroupClient<$Result.GetResult<Prisma.$VersionGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VersionGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VersionGroups
     * const versionGroups = await prisma.versionGroup.findMany()
     * 
     * // Get first 10 VersionGroups
     * const versionGroups = await prisma.versionGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const versionGroupWithIdOnly = await prisma.versionGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VersionGroupFindManyArgs>(args?: SelectSubset<T, VersionGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VersionGroup.
     * @param {VersionGroupCreateArgs} args - Arguments to create a VersionGroup.
     * @example
     * // Create one VersionGroup
     * const VersionGroup = await prisma.versionGroup.create({
     *   data: {
     *     // ... data to create a VersionGroup
     *   }
     * })
     * 
     */
    create<T extends VersionGroupCreateArgs>(args: SelectSubset<T, VersionGroupCreateArgs<ExtArgs>>): Prisma__VersionGroupClient<$Result.GetResult<Prisma.$VersionGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VersionGroups.
     * @param {VersionGroupCreateManyArgs} args - Arguments to create many VersionGroups.
     * @example
     * // Create many VersionGroups
     * const versionGroup = await prisma.versionGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VersionGroupCreateManyArgs>(args?: SelectSubset<T, VersionGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VersionGroups and returns the data saved in the database.
     * @param {VersionGroupCreateManyAndReturnArgs} args - Arguments to create many VersionGroups.
     * @example
     * // Create many VersionGroups
     * const versionGroup = await prisma.versionGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VersionGroups and only return the `id`
     * const versionGroupWithIdOnly = await prisma.versionGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VersionGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, VersionGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VersionGroup.
     * @param {VersionGroupDeleteArgs} args - Arguments to delete one VersionGroup.
     * @example
     * // Delete one VersionGroup
     * const VersionGroup = await prisma.versionGroup.delete({
     *   where: {
     *     // ... filter to delete one VersionGroup
     *   }
     * })
     * 
     */
    delete<T extends VersionGroupDeleteArgs>(args: SelectSubset<T, VersionGroupDeleteArgs<ExtArgs>>): Prisma__VersionGroupClient<$Result.GetResult<Prisma.$VersionGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VersionGroup.
     * @param {VersionGroupUpdateArgs} args - Arguments to update one VersionGroup.
     * @example
     * // Update one VersionGroup
     * const versionGroup = await prisma.versionGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VersionGroupUpdateArgs>(args: SelectSubset<T, VersionGroupUpdateArgs<ExtArgs>>): Prisma__VersionGroupClient<$Result.GetResult<Prisma.$VersionGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VersionGroups.
     * @param {VersionGroupDeleteManyArgs} args - Arguments to filter VersionGroups to delete.
     * @example
     * // Delete a few VersionGroups
     * const { count } = await prisma.versionGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VersionGroupDeleteManyArgs>(args?: SelectSubset<T, VersionGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VersionGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VersionGroups
     * const versionGroup = await prisma.versionGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VersionGroupUpdateManyArgs>(args: SelectSubset<T, VersionGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VersionGroups and returns the data updated in the database.
     * @param {VersionGroupUpdateManyAndReturnArgs} args - Arguments to update many VersionGroups.
     * @example
     * // Update many VersionGroups
     * const versionGroup = await prisma.versionGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VersionGroups and only return the `id`
     * const versionGroupWithIdOnly = await prisma.versionGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VersionGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, VersionGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VersionGroup.
     * @param {VersionGroupUpsertArgs} args - Arguments to update or create a VersionGroup.
     * @example
     * // Update or create a VersionGroup
     * const versionGroup = await prisma.versionGroup.upsert({
     *   create: {
     *     // ... data to create a VersionGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VersionGroup we want to update
     *   }
     * })
     */
    upsert<T extends VersionGroupUpsertArgs>(args: SelectSubset<T, VersionGroupUpsertArgs<ExtArgs>>): Prisma__VersionGroupClient<$Result.GetResult<Prisma.$VersionGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VersionGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionGroupCountArgs} args - Arguments to filter VersionGroups to count.
     * @example
     * // Count the number of VersionGroups
     * const count = await prisma.versionGroup.count({
     *   where: {
     *     // ... the filter for the VersionGroups we want to count
     *   }
     * })
    **/
    count<T extends VersionGroupCountArgs>(
      args?: Subset<T, VersionGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VersionGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VersionGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VersionGroupAggregateArgs>(args: Subset<T, VersionGroupAggregateArgs>): Prisma.PrismaPromise<GetVersionGroupAggregateType<T>>

    /**
     * Group by VersionGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VersionGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VersionGroupGroupByArgs['orderBy'] }
        : { orderBy?: VersionGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VersionGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVersionGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VersionGroup model
   */
  readonly fields: VersionGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VersionGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VersionGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    generation<T extends GenerationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenerationDefaultArgs<ExtArgs>>): Prisma__GenerationClient<$Result.GetResult<Prisma.$GenerationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    versions<T extends VersionGroup$versionsArgs<ExtArgs> = {}>(args?: Subset<T, VersionGroup$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    regions<T extends VersionGroup$regionsArgs<ExtArgs> = {}>(args?: Subset<T, VersionGroup$regionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionGroupRegionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    slots<T extends VersionGroup$slotsArgs<ExtArgs> = {}>(args?: Subset<T, VersionGroup$slotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    moves<T extends VersionGroup$movesArgs<ExtArgs> = {}>(args?: Subset<T, VersionGroup$movesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonMovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pokedex_version_groups<T extends VersionGroup$pokedex_version_groupsArgs<ExtArgs> = {}>(args?: Subset<T, VersionGroup$pokedex_version_groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokedexVersionGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VersionGroup model
   */
  interface VersionGroupFieldRefs {
    readonly id: FieldRef<"VersionGroup", 'Int'>
    readonly name: FieldRef<"VersionGroup", 'String'>
    readonly generation_id: FieldRef<"VersionGroup", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * VersionGroup findUnique
   */
  export type VersionGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroup
     */
    select?: VersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroup
     */
    omit?: VersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupInclude<ExtArgs> | null
    /**
     * Filter, which VersionGroup to fetch.
     */
    where: VersionGroupWhereUniqueInput
  }

  /**
   * VersionGroup findUniqueOrThrow
   */
  export type VersionGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroup
     */
    select?: VersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroup
     */
    omit?: VersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupInclude<ExtArgs> | null
    /**
     * Filter, which VersionGroup to fetch.
     */
    where: VersionGroupWhereUniqueInput
  }

  /**
   * VersionGroup findFirst
   */
  export type VersionGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroup
     */
    select?: VersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroup
     */
    omit?: VersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupInclude<ExtArgs> | null
    /**
     * Filter, which VersionGroup to fetch.
     */
    where?: VersionGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VersionGroups to fetch.
     */
    orderBy?: VersionGroupOrderByWithRelationInput | VersionGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VersionGroups.
     */
    cursor?: VersionGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VersionGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VersionGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VersionGroups.
     */
    distinct?: VersionGroupScalarFieldEnum | VersionGroupScalarFieldEnum[]
  }

  /**
   * VersionGroup findFirstOrThrow
   */
  export type VersionGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroup
     */
    select?: VersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroup
     */
    omit?: VersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupInclude<ExtArgs> | null
    /**
     * Filter, which VersionGroup to fetch.
     */
    where?: VersionGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VersionGroups to fetch.
     */
    orderBy?: VersionGroupOrderByWithRelationInput | VersionGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VersionGroups.
     */
    cursor?: VersionGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VersionGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VersionGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VersionGroups.
     */
    distinct?: VersionGroupScalarFieldEnum | VersionGroupScalarFieldEnum[]
  }

  /**
   * VersionGroup findMany
   */
  export type VersionGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroup
     */
    select?: VersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroup
     */
    omit?: VersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupInclude<ExtArgs> | null
    /**
     * Filter, which VersionGroups to fetch.
     */
    where?: VersionGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VersionGroups to fetch.
     */
    orderBy?: VersionGroupOrderByWithRelationInput | VersionGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VersionGroups.
     */
    cursor?: VersionGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VersionGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VersionGroups.
     */
    skip?: number
    distinct?: VersionGroupScalarFieldEnum | VersionGroupScalarFieldEnum[]
  }

  /**
   * VersionGroup create
   */
  export type VersionGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroup
     */
    select?: VersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroup
     */
    omit?: VersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a VersionGroup.
     */
    data: XOR<VersionGroupCreateInput, VersionGroupUncheckedCreateInput>
  }

  /**
   * VersionGroup createMany
   */
  export type VersionGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VersionGroups.
     */
    data: VersionGroupCreateManyInput | VersionGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VersionGroup createManyAndReturn
   */
  export type VersionGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroup
     */
    select?: VersionGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroup
     */
    omit?: VersionGroupOmit<ExtArgs> | null
    /**
     * The data used to create many VersionGroups.
     */
    data: VersionGroupCreateManyInput | VersionGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VersionGroup update
   */
  export type VersionGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroup
     */
    select?: VersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroup
     */
    omit?: VersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a VersionGroup.
     */
    data: XOR<VersionGroupUpdateInput, VersionGroupUncheckedUpdateInput>
    /**
     * Choose, which VersionGroup to update.
     */
    where: VersionGroupWhereUniqueInput
  }

  /**
   * VersionGroup updateMany
   */
  export type VersionGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VersionGroups.
     */
    data: XOR<VersionGroupUpdateManyMutationInput, VersionGroupUncheckedUpdateManyInput>
    /**
     * Filter which VersionGroups to update
     */
    where?: VersionGroupWhereInput
    /**
     * Limit how many VersionGroups to update.
     */
    limit?: number
  }

  /**
   * VersionGroup updateManyAndReturn
   */
  export type VersionGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroup
     */
    select?: VersionGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroup
     */
    omit?: VersionGroupOmit<ExtArgs> | null
    /**
     * The data used to update VersionGroups.
     */
    data: XOR<VersionGroupUpdateManyMutationInput, VersionGroupUncheckedUpdateManyInput>
    /**
     * Filter which VersionGroups to update
     */
    where?: VersionGroupWhereInput
    /**
     * Limit how many VersionGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VersionGroup upsert
   */
  export type VersionGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroup
     */
    select?: VersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroup
     */
    omit?: VersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the VersionGroup to update in case it exists.
     */
    where: VersionGroupWhereUniqueInput
    /**
     * In case the VersionGroup found by the `where` argument doesn't exist, create a new VersionGroup with this data.
     */
    create: XOR<VersionGroupCreateInput, VersionGroupUncheckedCreateInput>
    /**
     * In case the VersionGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VersionGroupUpdateInput, VersionGroupUncheckedUpdateInput>
  }

  /**
   * VersionGroup delete
   */
  export type VersionGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroup
     */
    select?: VersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroup
     */
    omit?: VersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupInclude<ExtArgs> | null
    /**
     * Filter which VersionGroup to delete.
     */
    where: VersionGroupWhereUniqueInput
  }

  /**
   * VersionGroup deleteMany
   */
  export type VersionGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VersionGroups to delete
     */
    where?: VersionGroupWhereInput
    /**
     * Limit how many VersionGroups to delete.
     */
    limit?: number
  }

  /**
   * VersionGroup.versions
   */
  export type VersionGroup$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    where?: VersionWhereInput
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    cursor?: VersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VersionScalarFieldEnum | VersionScalarFieldEnum[]
  }

  /**
   * VersionGroup.regions
   */
  export type VersionGroup$regionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroupRegion
     */
    select?: VersionGroupRegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroupRegion
     */
    omit?: VersionGroupRegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupRegionInclude<ExtArgs> | null
    where?: VersionGroupRegionWhereInput
    orderBy?: VersionGroupRegionOrderByWithRelationInput | VersionGroupRegionOrderByWithRelationInput[]
    cursor?: VersionGroupRegionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VersionGroupRegionScalarFieldEnum | VersionGroupRegionScalarFieldEnum[]
  }

  /**
   * VersionGroup.slots
   */
  export type VersionGroup$slotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSlot
     */
    select?: EncounterSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterSlot
     */
    omit?: EncounterSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSlotInclude<ExtArgs> | null
    where?: EncounterSlotWhereInput
    orderBy?: EncounterSlotOrderByWithRelationInput | EncounterSlotOrderByWithRelationInput[]
    cursor?: EncounterSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterSlotScalarFieldEnum | EncounterSlotScalarFieldEnum[]
  }

  /**
   * VersionGroup.moves
   */
  export type VersionGroup$movesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonMove
     */
    select?: PokemonMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonMove
     */
    omit?: PokemonMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonMoveInclude<ExtArgs> | null
    where?: PokemonMoveWhereInput
    orderBy?: PokemonMoveOrderByWithRelationInput | PokemonMoveOrderByWithRelationInput[]
    cursor?: PokemonMoveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokemonMoveScalarFieldEnum | PokemonMoveScalarFieldEnum[]
  }

  /**
   * VersionGroup.pokedex_version_groups
   */
  export type VersionGroup$pokedex_version_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokedexVersionGroup
     */
    select?: PokedexVersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokedexVersionGroup
     */
    omit?: PokedexVersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexVersionGroupInclude<ExtArgs> | null
    where?: PokedexVersionGroupWhereInput
    orderBy?: PokedexVersionGroupOrderByWithRelationInput | PokedexVersionGroupOrderByWithRelationInput[]
    cursor?: PokedexVersionGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokedexVersionGroupScalarFieldEnum | PokedexVersionGroupScalarFieldEnum[]
  }

  /**
   * VersionGroup without action
   */
  export type VersionGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroup
     */
    select?: VersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroup
     */
    omit?: VersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupInclude<ExtArgs> | null
  }


  /**
   * Model VersionGroupRegion
   */

  export type AggregateVersionGroupRegion = {
    _count: VersionGroupRegionCountAggregateOutputType | null
    _avg: VersionGroupRegionAvgAggregateOutputType | null
    _sum: VersionGroupRegionSumAggregateOutputType | null
    _min: VersionGroupRegionMinAggregateOutputType | null
    _max: VersionGroupRegionMaxAggregateOutputType | null
  }

  export type VersionGroupRegionAvgAggregateOutputType = {
    id: number | null
    version_group_id: number | null
    region_id: number | null
  }

  export type VersionGroupRegionSumAggregateOutputType = {
    id: number | null
    version_group_id: number | null
    region_id: number | null
  }

  export type VersionGroupRegionMinAggregateOutputType = {
    id: number | null
    version_group_id: number | null
    region_id: number | null
  }

  export type VersionGroupRegionMaxAggregateOutputType = {
    id: number | null
    version_group_id: number | null
    region_id: number | null
  }

  export type VersionGroupRegionCountAggregateOutputType = {
    id: number
    version_group_id: number
    region_id: number
    _all: number
  }


  export type VersionGroupRegionAvgAggregateInputType = {
    id?: true
    version_group_id?: true
    region_id?: true
  }

  export type VersionGroupRegionSumAggregateInputType = {
    id?: true
    version_group_id?: true
    region_id?: true
  }

  export type VersionGroupRegionMinAggregateInputType = {
    id?: true
    version_group_id?: true
    region_id?: true
  }

  export type VersionGroupRegionMaxAggregateInputType = {
    id?: true
    version_group_id?: true
    region_id?: true
  }

  export type VersionGroupRegionCountAggregateInputType = {
    id?: true
    version_group_id?: true
    region_id?: true
    _all?: true
  }

  export type VersionGroupRegionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VersionGroupRegion to aggregate.
     */
    where?: VersionGroupRegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VersionGroupRegions to fetch.
     */
    orderBy?: VersionGroupRegionOrderByWithRelationInput | VersionGroupRegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VersionGroupRegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VersionGroupRegions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VersionGroupRegions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VersionGroupRegions
    **/
    _count?: true | VersionGroupRegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VersionGroupRegionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VersionGroupRegionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VersionGroupRegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VersionGroupRegionMaxAggregateInputType
  }

  export type GetVersionGroupRegionAggregateType<T extends VersionGroupRegionAggregateArgs> = {
        [P in keyof T & keyof AggregateVersionGroupRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVersionGroupRegion[P]>
      : GetScalarType<T[P], AggregateVersionGroupRegion[P]>
  }




  export type VersionGroupRegionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VersionGroupRegionWhereInput
    orderBy?: VersionGroupRegionOrderByWithAggregationInput | VersionGroupRegionOrderByWithAggregationInput[]
    by: VersionGroupRegionScalarFieldEnum[] | VersionGroupRegionScalarFieldEnum
    having?: VersionGroupRegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VersionGroupRegionCountAggregateInputType | true
    _avg?: VersionGroupRegionAvgAggregateInputType
    _sum?: VersionGroupRegionSumAggregateInputType
    _min?: VersionGroupRegionMinAggregateInputType
    _max?: VersionGroupRegionMaxAggregateInputType
  }

  export type VersionGroupRegionGroupByOutputType = {
    id: number
    version_group_id: number
    region_id: number
    _count: VersionGroupRegionCountAggregateOutputType | null
    _avg: VersionGroupRegionAvgAggregateOutputType | null
    _sum: VersionGroupRegionSumAggregateOutputType | null
    _min: VersionGroupRegionMinAggregateOutputType | null
    _max: VersionGroupRegionMaxAggregateOutputType | null
  }

  type GetVersionGroupRegionGroupByPayload<T extends VersionGroupRegionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VersionGroupRegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VersionGroupRegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VersionGroupRegionGroupByOutputType[P]>
            : GetScalarType<T[P], VersionGroupRegionGroupByOutputType[P]>
        }
      >
    >


  export type VersionGroupRegionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version_group_id?: boolean
    region_id?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["versionGroupRegion"]>

  export type VersionGroupRegionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version_group_id?: boolean
    region_id?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["versionGroupRegion"]>

  export type VersionGroupRegionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version_group_id?: boolean
    region_id?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["versionGroupRegion"]>

  export type VersionGroupRegionSelectScalar = {
    id?: boolean
    version_group_id?: boolean
    region_id?: boolean
  }

  export type VersionGroupRegionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "version_group_id" | "region_id", ExtArgs["result"]["versionGroupRegion"]>
  export type VersionGroupRegionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
  }
  export type VersionGroupRegionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
  }
  export type VersionGroupRegionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
  }

  export type $VersionGroupRegionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VersionGroupRegion"
    objects: {
      region: Prisma.$RegionPayload<ExtArgs>
      version_group: Prisma.$VersionGroupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      version_group_id: number
      region_id: number
    }, ExtArgs["result"]["versionGroupRegion"]>
    composites: {}
  }

  type VersionGroupRegionGetPayload<S extends boolean | null | undefined | VersionGroupRegionDefaultArgs> = $Result.GetResult<Prisma.$VersionGroupRegionPayload, S>

  type VersionGroupRegionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VersionGroupRegionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VersionGroupRegionCountAggregateInputType | true
    }

  export interface VersionGroupRegionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VersionGroupRegion'], meta: { name: 'VersionGroupRegion' } }
    /**
     * Find zero or one VersionGroupRegion that matches the filter.
     * @param {VersionGroupRegionFindUniqueArgs} args - Arguments to find a VersionGroupRegion
     * @example
     * // Get one VersionGroupRegion
     * const versionGroupRegion = await prisma.versionGroupRegion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VersionGroupRegionFindUniqueArgs>(args: SelectSubset<T, VersionGroupRegionFindUniqueArgs<ExtArgs>>): Prisma__VersionGroupRegionClient<$Result.GetResult<Prisma.$VersionGroupRegionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VersionGroupRegion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VersionGroupRegionFindUniqueOrThrowArgs} args - Arguments to find a VersionGroupRegion
     * @example
     * // Get one VersionGroupRegion
     * const versionGroupRegion = await prisma.versionGroupRegion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VersionGroupRegionFindUniqueOrThrowArgs>(args: SelectSubset<T, VersionGroupRegionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VersionGroupRegionClient<$Result.GetResult<Prisma.$VersionGroupRegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VersionGroupRegion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionGroupRegionFindFirstArgs} args - Arguments to find a VersionGroupRegion
     * @example
     * // Get one VersionGroupRegion
     * const versionGroupRegion = await prisma.versionGroupRegion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VersionGroupRegionFindFirstArgs>(args?: SelectSubset<T, VersionGroupRegionFindFirstArgs<ExtArgs>>): Prisma__VersionGroupRegionClient<$Result.GetResult<Prisma.$VersionGroupRegionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VersionGroupRegion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionGroupRegionFindFirstOrThrowArgs} args - Arguments to find a VersionGroupRegion
     * @example
     * // Get one VersionGroupRegion
     * const versionGroupRegion = await prisma.versionGroupRegion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VersionGroupRegionFindFirstOrThrowArgs>(args?: SelectSubset<T, VersionGroupRegionFindFirstOrThrowArgs<ExtArgs>>): Prisma__VersionGroupRegionClient<$Result.GetResult<Prisma.$VersionGroupRegionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VersionGroupRegions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionGroupRegionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VersionGroupRegions
     * const versionGroupRegions = await prisma.versionGroupRegion.findMany()
     * 
     * // Get first 10 VersionGroupRegions
     * const versionGroupRegions = await prisma.versionGroupRegion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const versionGroupRegionWithIdOnly = await prisma.versionGroupRegion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VersionGroupRegionFindManyArgs>(args?: SelectSubset<T, VersionGroupRegionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionGroupRegionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VersionGroupRegion.
     * @param {VersionGroupRegionCreateArgs} args - Arguments to create a VersionGroupRegion.
     * @example
     * // Create one VersionGroupRegion
     * const VersionGroupRegion = await prisma.versionGroupRegion.create({
     *   data: {
     *     // ... data to create a VersionGroupRegion
     *   }
     * })
     * 
     */
    create<T extends VersionGroupRegionCreateArgs>(args: SelectSubset<T, VersionGroupRegionCreateArgs<ExtArgs>>): Prisma__VersionGroupRegionClient<$Result.GetResult<Prisma.$VersionGroupRegionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VersionGroupRegions.
     * @param {VersionGroupRegionCreateManyArgs} args - Arguments to create many VersionGroupRegions.
     * @example
     * // Create many VersionGroupRegions
     * const versionGroupRegion = await prisma.versionGroupRegion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VersionGroupRegionCreateManyArgs>(args?: SelectSubset<T, VersionGroupRegionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VersionGroupRegions and returns the data saved in the database.
     * @param {VersionGroupRegionCreateManyAndReturnArgs} args - Arguments to create many VersionGroupRegions.
     * @example
     * // Create many VersionGroupRegions
     * const versionGroupRegion = await prisma.versionGroupRegion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VersionGroupRegions and only return the `id`
     * const versionGroupRegionWithIdOnly = await prisma.versionGroupRegion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VersionGroupRegionCreateManyAndReturnArgs>(args?: SelectSubset<T, VersionGroupRegionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionGroupRegionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VersionGroupRegion.
     * @param {VersionGroupRegionDeleteArgs} args - Arguments to delete one VersionGroupRegion.
     * @example
     * // Delete one VersionGroupRegion
     * const VersionGroupRegion = await prisma.versionGroupRegion.delete({
     *   where: {
     *     // ... filter to delete one VersionGroupRegion
     *   }
     * })
     * 
     */
    delete<T extends VersionGroupRegionDeleteArgs>(args: SelectSubset<T, VersionGroupRegionDeleteArgs<ExtArgs>>): Prisma__VersionGroupRegionClient<$Result.GetResult<Prisma.$VersionGroupRegionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VersionGroupRegion.
     * @param {VersionGroupRegionUpdateArgs} args - Arguments to update one VersionGroupRegion.
     * @example
     * // Update one VersionGroupRegion
     * const versionGroupRegion = await prisma.versionGroupRegion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VersionGroupRegionUpdateArgs>(args: SelectSubset<T, VersionGroupRegionUpdateArgs<ExtArgs>>): Prisma__VersionGroupRegionClient<$Result.GetResult<Prisma.$VersionGroupRegionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VersionGroupRegions.
     * @param {VersionGroupRegionDeleteManyArgs} args - Arguments to filter VersionGroupRegions to delete.
     * @example
     * // Delete a few VersionGroupRegions
     * const { count } = await prisma.versionGroupRegion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VersionGroupRegionDeleteManyArgs>(args?: SelectSubset<T, VersionGroupRegionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VersionGroupRegions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionGroupRegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VersionGroupRegions
     * const versionGroupRegion = await prisma.versionGroupRegion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VersionGroupRegionUpdateManyArgs>(args: SelectSubset<T, VersionGroupRegionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VersionGroupRegions and returns the data updated in the database.
     * @param {VersionGroupRegionUpdateManyAndReturnArgs} args - Arguments to update many VersionGroupRegions.
     * @example
     * // Update many VersionGroupRegions
     * const versionGroupRegion = await prisma.versionGroupRegion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VersionGroupRegions and only return the `id`
     * const versionGroupRegionWithIdOnly = await prisma.versionGroupRegion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VersionGroupRegionUpdateManyAndReturnArgs>(args: SelectSubset<T, VersionGroupRegionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionGroupRegionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VersionGroupRegion.
     * @param {VersionGroupRegionUpsertArgs} args - Arguments to update or create a VersionGroupRegion.
     * @example
     * // Update or create a VersionGroupRegion
     * const versionGroupRegion = await prisma.versionGroupRegion.upsert({
     *   create: {
     *     // ... data to create a VersionGroupRegion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VersionGroupRegion we want to update
     *   }
     * })
     */
    upsert<T extends VersionGroupRegionUpsertArgs>(args: SelectSubset<T, VersionGroupRegionUpsertArgs<ExtArgs>>): Prisma__VersionGroupRegionClient<$Result.GetResult<Prisma.$VersionGroupRegionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VersionGroupRegions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionGroupRegionCountArgs} args - Arguments to filter VersionGroupRegions to count.
     * @example
     * // Count the number of VersionGroupRegions
     * const count = await prisma.versionGroupRegion.count({
     *   where: {
     *     // ... the filter for the VersionGroupRegions we want to count
     *   }
     * })
    **/
    count<T extends VersionGroupRegionCountArgs>(
      args?: Subset<T, VersionGroupRegionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VersionGroupRegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VersionGroupRegion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionGroupRegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VersionGroupRegionAggregateArgs>(args: Subset<T, VersionGroupRegionAggregateArgs>): Prisma.PrismaPromise<GetVersionGroupRegionAggregateType<T>>

    /**
     * Group by VersionGroupRegion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionGroupRegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VersionGroupRegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VersionGroupRegionGroupByArgs['orderBy'] }
        : { orderBy?: VersionGroupRegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VersionGroupRegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVersionGroupRegionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VersionGroupRegion model
   */
  readonly fields: VersionGroupRegionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VersionGroupRegion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VersionGroupRegionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    region<T extends RegionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionDefaultArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    version_group<T extends VersionGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VersionGroupDefaultArgs<ExtArgs>>): Prisma__VersionGroupClient<$Result.GetResult<Prisma.$VersionGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VersionGroupRegion model
   */
  interface VersionGroupRegionFieldRefs {
    readonly id: FieldRef<"VersionGroupRegion", 'Int'>
    readonly version_group_id: FieldRef<"VersionGroupRegion", 'Int'>
    readonly region_id: FieldRef<"VersionGroupRegion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * VersionGroupRegion findUnique
   */
  export type VersionGroupRegionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroupRegion
     */
    select?: VersionGroupRegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroupRegion
     */
    omit?: VersionGroupRegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupRegionInclude<ExtArgs> | null
    /**
     * Filter, which VersionGroupRegion to fetch.
     */
    where: VersionGroupRegionWhereUniqueInput
  }

  /**
   * VersionGroupRegion findUniqueOrThrow
   */
  export type VersionGroupRegionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroupRegion
     */
    select?: VersionGroupRegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroupRegion
     */
    omit?: VersionGroupRegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupRegionInclude<ExtArgs> | null
    /**
     * Filter, which VersionGroupRegion to fetch.
     */
    where: VersionGroupRegionWhereUniqueInput
  }

  /**
   * VersionGroupRegion findFirst
   */
  export type VersionGroupRegionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroupRegion
     */
    select?: VersionGroupRegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroupRegion
     */
    omit?: VersionGroupRegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupRegionInclude<ExtArgs> | null
    /**
     * Filter, which VersionGroupRegion to fetch.
     */
    where?: VersionGroupRegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VersionGroupRegions to fetch.
     */
    orderBy?: VersionGroupRegionOrderByWithRelationInput | VersionGroupRegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VersionGroupRegions.
     */
    cursor?: VersionGroupRegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VersionGroupRegions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VersionGroupRegions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VersionGroupRegions.
     */
    distinct?: VersionGroupRegionScalarFieldEnum | VersionGroupRegionScalarFieldEnum[]
  }

  /**
   * VersionGroupRegion findFirstOrThrow
   */
  export type VersionGroupRegionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroupRegion
     */
    select?: VersionGroupRegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroupRegion
     */
    omit?: VersionGroupRegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupRegionInclude<ExtArgs> | null
    /**
     * Filter, which VersionGroupRegion to fetch.
     */
    where?: VersionGroupRegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VersionGroupRegions to fetch.
     */
    orderBy?: VersionGroupRegionOrderByWithRelationInput | VersionGroupRegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VersionGroupRegions.
     */
    cursor?: VersionGroupRegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VersionGroupRegions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VersionGroupRegions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VersionGroupRegions.
     */
    distinct?: VersionGroupRegionScalarFieldEnum | VersionGroupRegionScalarFieldEnum[]
  }

  /**
   * VersionGroupRegion findMany
   */
  export type VersionGroupRegionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroupRegion
     */
    select?: VersionGroupRegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroupRegion
     */
    omit?: VersionGroupRegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupRegionInclude<ExtArgs> | null
    /**
     * Filter, which VersionGroupRegions to fetch.
     */
    where?: VersionGroupRegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VersionGroupRegions to fetch.
     */
    orderBy?: VersionGroupRegionOrderByWithRelationInput | VersionGroupRegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VersionGroupRegions.
     */
    cursor?: VersionGroupRegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VersionGroupRegions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VersionGroupRegions.
     */
    skip?: number
    distinct?: VersionGroupRegionScalarFieldEnum | VersionGroupRegionScalarFieldEnum[]
  }

  /**
   * VersionGroupRegion create
   */
  export type VersionGroupRegionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroupRegion
     */
    select?: VersionGroupRegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroupRegion
     */
    omit?: VersionGroupRegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupRegionInclude<ExtArgs> | null
    /**
     * The data needed to create a VersionGroupRegion.
     */
    data: XOR<VersionGroupRegionCreateInput, VersionGroupRegionUncheckedCreateInput>
  }

  /**
   * VersionGroupRegion createMany
   */
  export type VersionGroupRegionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VersionGroupRegions.
     */
    data: VersionGroupRegionCreateManyInput | VersionGroupRegionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VersionGroupRegion createManyAndReturn
   */
  export type VersionGroupRegionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroupRegion
     */
    select?: VersionGroupRegionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroupRegion
     */
    omit?: VersionGroupRegionOmit<ExtArgs> | null
    /**
     * The data used to create many VersionGroupRegions.
     */
    data: VersionGroupRegionCreateManyInput | VersionGroupRegionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupRegionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VersionGroupRegion update
   */
  export type VersionGroupRegionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroupRegion
     */
    select?: VersionGroupRegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroupRegion
     */
    omit?: VersionGroupRegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupRegionInclude<ExtArgs> | null
    /**
     * The data needed to update a VersionGroupRegion.
     */
    data: XOR<VersionGroupRegionUpdateInput, VersionGroupRegionUncheckedUpdateInput>
    /**
     * Choose, which VersionGroupRegion to update.
     */
    where: VersionGroupRegionWhereUniqueInput
  }

  /**
   * VersionGroupRegion updateMany
   */
  export type VersionGroupRegionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VersionGroupRegions.
     */
    data: XOR<VersionGroupRegionUpdateManyMutationInput, VersionGroupRegionUncheckedUpdateManyInput>
    /**
     * Filter which VersionGroupRegions to update
     */
    where?: VersionGroupRegionWhereInput
    /**
     * Limit how many VersionGroupRegions to update.
     */
    limit?: number
  }

  /**
   * VersionGroupRegion updateManyAndReturn
   */
  export type VersionGroupRegionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroupRegion
     */
    select?: VersionGroupRegionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroupRegion
     */
    omit?: VersionGroupRegionOmit<ExtArgs> | null
    /**
     * The data used to update VersionGroupRegions.
     */
    data: XOR<VersionGroupRegionUpdateManyMutationInput, VersionGroupRegionUncheckedUpdateManyInput>
    /**
     * Filter which VersionGroupRegions to update
     */
    where?: VersionGroupRegionWhereInput
    /**
     * Limit how many VersionGroupRegions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupRegionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VersionGroupRegion upsert
   */
  export type VersionGroupRegionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroupRegion
     */
    select?: VersionGroupRegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroupRegion
     */
    omit?: VersionGroupRegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupRegionInclude<ExtArgs> | null
    /**
     * The filter to search for the VersionGroupRegion to update in case it exists.
     */
    where: VersionGroupRegionWhereUniqueInput
    /**
     * In case the VersionGroupRegion found by the `where` argument doesn't exist, create a new VersionGroupRegion with this data.
     */
    create: XOR<VersionGroupRegionCreateInput, VersionGroupRegionUncheckedCreateInput>
    /**
     * In case the VersionGroupRegion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VersionGroupRegionUpdateInput, VersionGroupRegionUncheckedUpdateInput>
  }

  /**
   * VersionGroupRegion delete
   */
  export type VersionGroupRegionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroupRegion
     */
    select?: VersionGroupRegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroupRegion
     */
    omit?: VersionGroupRegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupRegionInclude<ExtArgs> | null
    /**
     * Filter which VersionGroupRegion to delete.
     */
    where: VersionGroupRegionWhereUniqueInput
  }

  /**
   * VersionGroupRegion deleteMany
   */
  export type VersionGroupRegionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VersionGroupRegions to delete
     */
    where?: VersionGroupRegionWhereInput
    /**
     * Limit how many VersionGroupRegions to delete.
     */
    limit?: number
  }

  /**
   * VersionGroupRegion without action
   */
  export type VersionGroupRegionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionGroupRegion
     */
    select?: VersionGroupRegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VersionGroupRegion
     */
    omit?: VersionGroupRegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionGroupRegionInclude<ExtArgs> | null
  }


  /**
   * Model Version
   */

  export type AggregateVersion = {
    _count: VersionCountAggregateOutputType | null
    _avg: VersionAvgAggregateOutputType | null
    _sum: VersionSumAggregateOutputType | null
    _min: VersionMinAggregateOutputType | null
    _max: VersionMaxAggregateOutputType | null
  }

  export type VersionAvgAggregateOutputType = {
    id: number | null
    version_group_id: number | null
  }

  export type VersionSumAggregateOutputType = {
    id: number | null
    version_group_id: number | null
  }

  export type VersionMinAggregateOutputType = {
    id: number | null
    name: string | null
    version_group_id: number | null
  }

  export type VersionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    version_group_id: number | null
  }

  export type VersionCountAggregateOutputType = {
    id: number
    name: number
    version_group_id: number
    _all: number
  }


  export type VersionAvgAggregateInputType = {
    id?: true
    version_group_id?: true
  }

  export type VersionSumAggregateInputType = {
    id?: true
    version_group_id?: true
  }

  export type VersionMinAggregateInputType = {
    id?: true
    name?: true
    version_group_id?: true
  }

  export type VersionMaxAggregateInputType = {
    id?: true
    name?: true
    version_group_id?: true
  }

  export type VersionCountAggregateInputType = {
    id?: true
    name?: true
    version_group_id?: true
    _all?: true
  }

  export type VersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Version to aggregate.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Versions
    **/
    _count?: true | VersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VersionMaxAggregateInputType
  }

  export type GetVersionAggregateType<T extends VersionAggregateArgs> = {
        [P in keyof T & keyof AggregateVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVersion[P]>
      : GetScalarType<T[P], AggregateVersion[P]>
  }




  export type VersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VersionWhereInput
    orderBy?: VersionOrderByWithAggregationInput | VersionOrderByWithAggregationInput[]
    by: VersionScalarFieldEnum[] | VersionScalarFieldEnum
    having?: VersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VersionCountAggregateInputType | true
    _avg?: VersionAvgAggregateInputType
    _sum?: VersionSumAggregateInputType
    _min?: VersionMinAggregateInputType
    _max?: VersionMaxAggregateInputType
  }

  export type VersionGroupByOutputType = {
    id: number
    name: string
    version_group_id: number
    _count: VersionCountAggregateOutputType | null
    _avg: VersionAvgAggregateOutputType | null
    _sum: VersionSumAggregateOutputType | null
    _min: VersionMinAggregateOutputType | null
    _max: VersionMaxAggregateOutputType | null
  }

  type GetVersionGroupByPayload<T extends VersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VersionGroupByOutputType[P]>
            : GetScalarType<T[P], VersionGroupByOutputType[P]>
        }
      >
    >


  export type VersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    version_group_id?: boolean
    versionGroup?: boolean | VersionGroupDefaultArgs<ExtArgs>
    encounters?: boolean | Version$encountersArgs<ExtArgs>
    encounterRates?: boolean | Version$encounterRatesArgs<ExtArgs>
    _count?: boolean | VersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["version"]>

  export type VersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    version_group_id?: boolean
    versionGroup?: boolean | VersionGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["version"]>

  export type VersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    version_group_id?: boolean
    versionGroup?: boolean | VersionGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["version"]>

  export type VersionSelectScalar = {
    id?: boolean
    name?: boolean
    version_group_id?: boolean
  }

  export type VersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "version_group_id", ExtArgs["result"]["version"]>
  export type VersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versionGroup?: boolean | VersionGroupDefaultArgs<ExtArgs>
    encounters?: boolean | Version$encountersArgs<ExtArgs>
    encounterRates?: boolean | Version$encounterRatesArgs<ExtArgs>
    _count?: boolean | VersionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versionGroup?: boolean | VersionGroupDefaultArgs<ExtArgs>
  }
  export type VersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versionGroup?: boolean | VersionGroupDefaultArgs<ExtArgs>
  }

  export type $VersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Version"
    objects: {
      versionGroup: Prisma.$VersionGroupPayload<ExtArgs>
      encounters: Prisma.$EncounterPayload<ExtArgs>[]
      encounterRates: Prisma.$LocationAreaEncounterRatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      version_group_id: number
    }, ExtArgs["result"]["version"]>
    composites: {}
  }

  type VersionGetPayload<S extends boolean | null | undefined | VersionDefaultArgs> = $Result.GetResult<Prisma.$VersionPayload, S>

  type VersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VersionCountAggregateInputType | true
    }

  export interface VersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Version'], meta: { name: 'Version' } }
    /**
     * Find zero or one Version that matches the filter.
     * @param {VersionFindUniqueArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VersionFindUniqueArgs>(args: SelectSubset<T, VersionFindUniqueArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Version that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VersionFindUniqueOrThrowArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VersionFindUniqueOrThrowArgs>(args: SelectSubset<T, VersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Version that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionFindFirstArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VersionFindFirstArgs>(args?: SelectSubset<T, VersionFindFirstArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Version that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionFindFirstOrThrowArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VersionFindFirstOrThrowArgs>(args?: SelectSubset<T, VersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Versions
     * const versions = await prisma.version.findMany()
     * 
     * // Get first 10 Versions
     * const versions = await prisma.version.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const versionWithIdOnly = await prisma.version.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VersionFindManyArgs>(args?: SelectSubset<T, VersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Version.
     * @param {VersionCreateArgs} args - Arguments to create a Version.
     * @example
     * // Create one Version
     * const Version = await prisma.version.create({
     *   data: {
     *     // ... data to create a Version
     *   }
     * })
     * 
     */
    create<T extends VersionCreateArgs>(args: SelectSubset<T, VersionCreateArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Versions.
     * @param {VersionCreateManyArgs} args - Arguments to create many Versions.
     * @example
     * // Create many Versions
     * const version = await prisma.version.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VersionCreateManyArgs>(args?: SelectSubset<T, VersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Versions and returns the data saved in the database.
     * @param {VersionCreateManyAndReturnArgs} args - Arguments to create many Versions.
     * @example
     * // Create many Versions
     * const version = await prisma.version.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Versions and only return the `id`
     * const versionWithIdOnly = await prisma.version.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VersionCreateManyAndReturnArgs>(args?: SelectSubset<T, VersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Version.
     * @param {VersionDeleteArgs} args - Arguments to delete one Version.
     * @example
     * // Delete one Version
     * const Version = await prisma.version.delete({
     *   where: {
     *     // ... filter to delete one Version
     *   }
     * })
     * 
     */
    delete<T extends VersionDeleteArgs>(args: SelectSubset<T, VersionDeleteArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Version.
     * @param {VersionUpdateArgs} args - Arguments to update one Version.
     * @example
     * // Update one Version
     * const version = await prisma.version.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VersionUpdateArgs>(args: SelectSubset<T, VersionUpdateArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Versions.
     * @param {VersionDeleteManyArgs} args - Arguments to filter Versions to delete.
     * @example
     * // Delete a few Versions
     * const { count } = await prisma.version.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VersionDeleteManyArgs>(args?: SelectSubset<T, VersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Versions
     * const version = await prisma.version.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VersionUpdateManyArgs>(args: SelectSubset<T, VersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Versions and returns the data updated in the database.
     * @param {VersionUpdateManyAndReturnArgs} args - Arguments to update many Versions.
     * @example
     * // Update many Versions
     * const version = await prisma.version.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Versions and only return the `id`
     * const versionWithIdOnly = await prisma.version.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VersionUpdateManyAndReturnArgs>(args: SelectSubset<T, VersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Version.
     * @param {VersionUpsertArgs} args - Arguments to update or create a Version.
     * @example
     * // Update or create a Version
     * const version = await prisma.version.upsert({
     *   create: {
     *     // ... data to create a Version
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Version we want to update
     *   }
     * })
     */
    upsert<T extends VersionUpsertArgs>(args: SelectSubset<T, VersionUpsertArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionCountArgs} args - Arguments to filter Versions to count.
     * @example
     * // Count the number of Versions
     * const count = await prisma.version.count({
     *   where: {
     *     // ... the filter for the Versions we want to count
     *   }
     * })
    **/
    count<T extends VersionCountArgs>(
      args?: Subset<T, VersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Version.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VersionAggregateArgs>(args: Subset<T, VersionAggregateArgs>): Prisma.PrismaPromise<GetVersionAggregateType<T>>

    /**
     * Group by Version.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VersionGroupByArgs['orderBy'] }
        : { orderBy?: VersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Version model
   */
  readonly fields: VersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Version.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    versionGroup<T extends VersionGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VersionGroupDefaultArgs<ExtArgs>>): Prisma__VersionGroupClient<$Result.GetResult<Prisma.$VersionGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    encounters<T extends Version$encountersArgs<ExtArgs> = {}>(args?: Subset<T, Version$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    encounterRates<T extends Version$encounterRatesArgs<ExtArgs> = {}>(args?: Subset<T, Version$encounterRatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationAreaEncounterRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Version model
   */
  interface VersionFieldRefs {
    readonly id: FieldRef<"Version", 'Int'>
    readonly name: FieldRef<"Version", 'String'>
    readonly version_group_id: FieldRef<"Version", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Version findUnique
   */
  export type VersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version findUniqueOrThrow
   */
  export type VersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version findFirst
   */
  export type VersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Versions.
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Versions.
     */
    distinct?: VersionScalarFieldEnum | VersionScalarFieldEnum[]
  }

  /**
   * Version findFirstOrThrow
   */
  export type VersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Versions.
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Versions.
     */
    distinct?: VersionScalarFieldEnum | VersionScalarFieldEnum[]
  }

  /**
   * Version findMany
   */
  export type VersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Versions to fetch.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Versions.
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    distinct?: VersionScalarFieldEnum | VersionScalarFieldEnum[]
  }

  /**
   * Version create
   */
  export type VersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * The data needed to create a Version.
     */
    data: XOR<VersionCreateInput, VersionUncheckedCreateInput>
  }

  /**
   * Version createMany
   */
  export type VersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Versions.
     */
    data: VersionCreateManyInput | VersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Version createManyAndReturn
   */
  export type VersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * The data used to create many Versions.
     */
    data: VersionCreateManyInput | VersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Version update
   */
  export type VersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * The data needed to update a Version.
     */
    data: XOR<VersionUpdateInput, VersionUncheckedUpdateInput>
    /**
     * Choose, which Version to update.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version updateMany
   */
  export type VersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Versions.
     */
    data: XOR<VersionUpdateManyMutationInput, VersionUncheckedUpdateManyInput>
    /**
     * Filter which Versions to update
     */
    where?: VersionWhereInput
    /**
     * Limit how many Versions to update.
     */
    limit?: number
  }

  /**
   * Version updateManyAndReturn
   */
  export type VersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * The data used to update Versions.
     */
    data: XOR<VersionUpdateManyMutationInput, VersionUncheckedUpdateManyInput>
    /**
     * Filter which Versions to update
     */
    where?: VersionWhereInput
    /**
     * Limit how many Versions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Version upsert
   */
  export type VersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * The filter to search for the Version to update in case it exists.
     */
    where: VersionWhereUniqueInput
    /**
     * In case the Version found by the `where` argument doesn't exist, create a new Version with this data.
     */
    create: XOR<VersionCreateInput, VersionUncheckedCreateInput>
    /**
     * In case the Version was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VersionUpdateInput, VersionUncheckedUpdateInput>
  }

  /**
   * Version delete
   */
  export type VersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter which Version to delete.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version deleteMany
   */
  export type VersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Versions to delete
     */
    where?: VersionWhereInput
    /**
     * Limit how many Versions to delete.
     */
    limit?: number
  }

  /**
   * Version.encounters
   */
  export type Version$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Version.encounterRates
   */
  export type Version$encounterRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAreaEncounterRate
     */
    select?: LocationAreaEncounterRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAreaEncounterRate
     */
    omit?: LocationAreaEncounterRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaEncounterRateInclude<ExtArgs> | null
    where?: LocationAreaEncounterRateWhereInput
    orderBy?: LocationAreaEncounterRateOrderByWithRelationInput | LocationAreaEncounterRateOrderByWithRelationInput[]
    cursor?: LocationAreaEncounterRateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationAreaEncounterRateScalarFieldEnum | LocationAreaEncounterRateScalarFieldEnum[]
  }

  /**
   * Version without action
   */
  export type VersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    id: number | null
    region_id: number | null
  }

  export type LocationSumAggregateOutputType = {
    id: number | null
    region_id: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: number | null
    name: string | null
    region_id: number | null
  }

  export type LocationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    region_id: number | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    name: number
    region_id: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    id?: true
    region_id?: true
  }

  export type LocationSumAggregateInputType = {
    id?: true
    region_id?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    name?: true
    region_id?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    name?: true
    region_id?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    name?: true
    region_id?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: number
    name: string
    region_id: number
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    region_id?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    areas?: boolean | Location$areasArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    region_id?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    region_id?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    name?: boolean
    region_id?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "region_id", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    areas?: boolean | Location$areasArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      region: Prisma.$RegionPayload<ExtArgs>
      areas: Prisma.$LocationAreaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      region_id: number
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    region<T extends RegionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionDefaultArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    areas<T extends Location$areasArgs<ExtArgs> = {}>(args?: Subset<T, Location$areasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationAreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'Int'>
    readonly name: FieldRef<"Location", 'String'>
    readonly region_id: FieldRef<"Location", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.areas
   */
  export type Location$areasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationArea
     */
    select?: LocationAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationArea
     */
    omit?: LocationAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaInclude<ExtArgs> | null
    where?: LocationAreaWhereInput
    orderBy?: LocationAreaOrderByWithRelationInput | LocationAreaOrderByWithRelationInput[]
    cursor?: LocationAreaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationAreaScalarFieldEnum | LocationAreaScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model LocationArea
   */

  export type AggregateLocationArea = {
    _count: LocationAreaCountAggregateOutputType | null
    _avg: LocationAreaAvgAggregateOutputType | null
    _sum: LocationAreaSumAggregateOutputType | null
    _min: LocationAreaMinAggregateOutputType | null
    _max: LocationAreaMaxAggregateOutputType | null
  }

  export type LocationAreaAvgAggregateOutputType = {
    id: number | null
    location_id: number | null
  }

  export type LocationAreaSumAggregateOutputType = {
    id: number | null
    location_id: number | null
  }

  export type LocationAreaMinAggregateOutputType = {
    id: number | null
    name: string | null
    location_id: number | null
  }

  export type LocationAreaMaxAggregateOutputType = {
    id: number | null
    name: string | null
    location_id: number | null
  }

  export type LocationAreaCountAggregateOutputType = {
    id: number
    name: number
    location_id: number
    _all: number
  }


  export type LocationAreaAvgAggregateInputType = {
    id?: true
    location_id?: true
  }

  export type LocationAreaSumAggregateInputType = {
    id?: true
    location_id?: true
  }

  export type LocationAreaMinAggregateInputType = {
    id?: true
    name?: true
    location_id?: true
  }

  export type LocationAreaMaxAggregateInputType = {
    id?: true
    name?: true
    location_id?: true
  }

  export type LocationAreaCountAggregateInputType = {
    id?: true
    name?: true
    location_id?: true
    _all?: true
  }

  export type LocationAreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationArea to aggregate.
     */
    where?: LocationAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationAreas to fetch.
     */
    orderBy?: LocationAreaOrderByWithRelationInput | LocationAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocationAreas
    **/
    _count?: true | LocationAreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAreaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationAreaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationAreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationAreaMaxAggregateInputType
  }

  export type GetLocationAreaAggregateType<T extends LocationAreaAggregateArgs> = {
        [P in keyof T & keyof AggregateLocationArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocationArea[P]>
      : GetScalarType<T[P], AggregateLocationArea[P]>
  }




  export type LocationAreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationAreaWhereInput
    orderBy?: LocationAreaOrderByWithAggregationInput | LocationAreaOrderByWithAggregationInput[]
    by: LocationAreaScalarFieldEnum[] | LocationAreaScalarFieldEnum
    having?: LocationAreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationAreaCountAggregateInputType | true
    _avg?: LocationAreaAvgAggregateInputType
    _sum?: LocationAreaSumAggregateInputType
    _min?: LocationAreaMinAggregateInputType
    _max?: LocationAreaMaxAggregateInputType
  }

  export type LocationAreaGroupByOutputType = {
    id: number
    name: string
    location_id: number
    _count: LocationAreaCountAggregateOutputType | null
    _avg: LocationAreaAvgAggregateOutputType | null
    _sum: LocationAreaSumAggregateOutputType | null
    _min: LocationAreaMinAggregateOutputType | null
    _max: LocationAreaMaxAggregateOutputType | null
  }

  type GetLocationAreaGroupByPayload<T extends LocationAreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationAreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationAreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationAreaGroupByOutputType[P]>
            : GetScalarType<T[P], LocationAreaGroupByOutputType[P]>
        }
      >
    >


  export type LocationAreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location_id?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    encounters?: boolean | LocationArea$encountersArgs<ExtArgs>
    encounterRates?: boolean | LocationArea$encounterRatesArgs<ExtArgs>
    _count?: boolean | LocationAreaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationArea"]>

  export type LocationAreaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location_id?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationArea"]>

  export type LocationAreaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location_id?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationArea"]>

  export type LocationAreaSelectScalar = {
    id?: boolean
    name?: boolean
    location_id?: boolean
  }

  export type LocationAreaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "location_id", ExtArgs["result"]["locationArea"]>
  export type LocationAreaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    encounters?: boolean | LocationArea$encountersArgs<ExtArgs>
    encounterRates?: boolean | LocationArea$encounterRatesArgs<ExtArgs>
    _count?: boolean | LocationAreaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationAreaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type LocationAreaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $LocationAreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocationArea"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      encounters: Prisma.$EncounterPayload<ExtArgs>[]
      encounterRates: Prisma.$LocationAreaEncounterRatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      location_id: number
    }, ExtArgs["result"]["locationArea"]>
    composites: {}
  }

  type LocationAreaGetPayload<S extends boolean | null | undefined | LocationAreaDefaultArgs> = $Result.GetResult<Prisma.$LocationAreaPayload, S>

  type LocationAreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationAreaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationAreaCountAggregateInputType | true
    }

  export interface LocationAreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocationArea'], meta: { name: 'LocationArea' } }
    /**
     * Find zero or one LocationArea that matches the filter.
     * @param {LocationAreaFindUniqueArgs} args - Arguments to find a LocationArea
     * @example
     * // Get one LocationArea
     * const locationArea = await prisma.locationArea.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationAreaFindUniqueArgs>(args: SelectSubset<T, LocationAreaFindUniqueArgs<ExtArgs>>): Prisma__LocationAreaClient<$Result.GetResult<Prisma.$LocationAreaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LocationArea that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationAreaFindUniqueOrThrowArgs} args - Arguments to find a LocationArea
     * @example
     * // Get one LocationArea
     * const locationArea = await prisma.locationArea.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationAreaFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationAreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationAreaClient<$Result.GetResult<Prisma.$LocationAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocationArea that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAreaFindFirstArgs} args - Arguments to find a LocationArea
     * @example
     * // Get one LocationArea
     * const locationArea = await prisma.locationArea.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationAreaFindFirstArgs>(args?: SelectSubset<T, LocationAreaFindFirstArgs<ExtArgs>>): Prisma__LocationAreaClient<$Result.GetResult<Prisma.$LocationAreaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocationArea that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAreaFindFirstOrThrowArgs} args - Arguments to find a LocationArea
     * @example
     * // Get one LocationArea
     * const locationArea = await prisma.locationArea.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationAreaFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationAreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationAreaClient<$Result.GetResult<Prisma.$LocationAreaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LocationAreas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocationAreas
     * const locationAreas = await prisma.locationArea.findMany()
     * 
     * // Get first 10 LocationAreas
     * const locationAreas = await prisma.locationArea.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationAreaWithIdOnly = await prisma.locationArea.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationAreaFindManyArgs>(args?: SelectSubset<T, LocationAreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationAreaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LocationArea.
     * @param {LocationAreaCreateArgs} args - Arguments to create a LocationArea.
     * @example
     * // Create one LocationArea
     * const LocationArea = await prisma.locationArea.create({
     *   data: {
     *     // ... data to create a LocationArea
     *   }
     * })
     * 
     */
    create<T extends LocationAreaCreateArgs>(args: SelectSubset<T, LocationAreaCreateArgs<ExtArgs>>): Prisma__LocationAreaClient<$Result.GetResult<Prisma.$LocationAreaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LocationAreas.
     * @param {LocationAreaCreateManyArgs} args - Arguments to create many LocationAreas.
     * @example
     * // Create many LocationAreas
     * const locationArea = await prisma.locationArea.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationAreaCreateManyArgs>(args?: SelectSubset<T, LocationAreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LocationAreas and returns the data saved in the database.
     * @param {LocationAreaCreateManyAndReturnArgs} args - Arguments to create many LocationAreas.
     * @example
     * // Create many LocationAreas
     * const locationArea = await prisma.locationArea.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LocationAreas and only return the `id`
     * const locationAreaWithIdOnly = await prisma.locationArea.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationAreaCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationAreaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationAreaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LocationArea.
     * @param {LocationAreaDeleteArgs} args - Arguments to delete one LocationArea.
     * @example
     * // Delete one LocationArea
     * const LocationArea = await prisma.locationArea.delete({
     *   where: {
     *     // ... filter to delete one LocationArea
     *   }
     * })
     * 
     */
    delete<T extends LocationAreaDeleteArgs>(args: SelectSubset<T, LocationAreaDeleteArgs<ExtArgs>>): Prisma__LocationAreaClient<$Result.GetResult<Prisma.$LocationAreaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LocationArea.
     * @param {LocationAreaUpdateArgs} args - Arguments to update one LocationArea.
     * @example
     * // Update one LocationArea
     * const locationArea = await prisma.locationArea.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationAreaUpdateArgs>(args: SelectSubset<T, LocationAreaUpdateArgs<ExtArgs>>): Prisma__LocationAreaClient<$Result.GetResult<Prisma.$LocationAreaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LocationAreas.
     * @param {LocationAreaDeleteManyArgs} args - Arguments to filter LocationAreas to delete.
     * @example
     * // Delete a few LocationAreas
     * const { count } = await prisma.locationArea.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationAreaDeleteManyArgs>(args?: SelectSubset<T, LocationAreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocationAreas
     * const locationArea = await prisma.locationArea.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationAreaUpdateManyArgs>(args: SelectSubset<T, LocationAreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationAreas and returns the data updated in the database.
     * @param {LocationAreaUpdateManyAndReturnArgs} args - Arguments to update many LocationAreas.
     * @example
     * // Update many LocationAreas
     * const locationArea = await prisma.locationArea.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LocationAreas and only return the `id`
     * const locationAreaWithIdOnly = await prisma.locationArea.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationAreaUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationAreaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationAreaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LocationArea.
     * @param {LocationAreaUpsertArgs} args - Arguments to update or create a LocationArea.
     * @example
     * // Update or create a LocationArea
     * const locationArea = await prisma.locationArea.upsert({
     *   create: {
     *     // ... data to create a LocationArea
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocationArea we want to update
     *   }
     * })
     */
    upsert<T extends LocationAreaUpsertArgs>(args: SelectSubset<T, LocationAreaUpsertArgs<ExtArgs>>): Prisma__LocationAreaClient<$Result.GetResult<Prisma.$LocationAreaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LocationAreas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAreaCountArgs} args - Arguments to filter LocationAreas to count.
     * @example
     * // Count the number of LocationAreas
     * const count = await prisma.locationArea.count({
     *   where: {
     *     // ... the filter for the LocationAreas we want to count
     *   }
     * })
    **/
    count<T extends LocationAreaCountArgs>(
      args?: Subset<T, LocationAreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationAreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocationArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAreaAggregateArgs>(args: Subset<T, LocationAreaAggregateArgs>): Prisma.PrismaPromise<GetLocationAreaAggregateType<T>>

    /**
     * Group by LocationArea.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationAreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationAreaGroupByArgs['orderBy'] }
        : { orderBy?: LocationAreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationAreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocationArea model
   */
  readonly fields: LocationAreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocationArea.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationAreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    encounters<T extends LocationArea$encountersArgs<ExtArgs> = {}>(args?: Subset<T, LocationArea$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    encounterRates<T extends LocationArea$encounterRatesArgs<ExtArgs> = {}>(args?: Subset<T, LocationArea$encounterRatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationAreaEncounterRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocationArea model
   */
  interface LocationAreaFieldRefs {
    readonly id: FieldRef<"LocationArea", 'Int'>
    readonly name: FieldRef<"LocationArea", 'String'>
    readonly location_id: FieldRef<"LocationArea", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LocationArea findUnique
   */
  export type LocationAreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationArea
     */
    select?: LocationAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationArea
     */
    omit?: LocationAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaInclude<ExtArgs> | null
    /**
     * Filter, which LocationArea to fetch.
     */
    where: LocationAreaWhereUniqueInput
  }

  /**
   * LocationArea findUniqueOrThrow
   */
  export type LocationAreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationArea
     */
    select?: LocationAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationArea
     */
    omit?: LocationAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaInclude<ExtArgs> | null
    /**
     * Filter, which LocationArea to fetch.
     */
    where: LocationAreaWhereUniqueInput
  }

  /**
   * LocationArea findFirst
   */
  export type LocationAreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationArea
     */
    select?: LocationAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationArea
     */
    omit?: LocationAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaInclude<ExtArgs> | null
    /**
     * Filter, which LocationArea to fetch.
     */
    where?: LocationAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationAreas to fetch.
     */
    orderBy?: LocationAreaOrderByWithRelationInput | LocationAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationAreas.
     */
    cursor?: LocationAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationAreas.
     */
    distinct?: LocationAreaScalarFieldEnum | LocationAreaScalarFieldEnum[]
  }

  /**
   * LocationArea findFirstOrThrow
   */
  export type LocationAreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationArea
     */
    select?: LocationAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationArea
     */
    omit?: LocationAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaInclude<ExtArgs> | null
    /**
     * Filter, which LocationArea to fetch.
     */
    where?: LocationAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationAreas to fetch.
     */
    orderBy?: LocationAreaOrderByWithRelationInput | LocationAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationAreas.
     */
    cursor?: LocationAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationAreas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationAreas.
     */
    distinct?: LocationAreaScalarFieldEnum | LocationAreaScalarFieldEnum[]
  }

  /**
   * LocationArea findMany
   */
  export type LocationAreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationArea
     */
    select?: LocationAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationArea
     */
    omit?: LocationAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaInclude<ExtArgs> | null
    /**
     * Filter, which LocationAreas to fetch.
     */
    where?: LocationAreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationAreas to fetch.
     */
    orderBy?: LocationAreaOrderByWithRelationInput | LocationAreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocationAreas.
     */
    cursor?: LocationAreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationAreas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationAreas.
     */
    skip?: number
    distinct?: LocationAreaScalarFieldEnum | LocationAreaScalarFieldEnum[]
  }

  /**
   * LocationArea create
   */
  export type LocationAreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationArea
     */
    select?: LocationAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationArea
     */
    omit?: LocationAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaInclude<ExtArgs> | null
    /**
     * The data needed to create a LocationArea.
     */
    data: XOR<LocationAreaCreateInput, LocationAreaUncheckedCreateInput>
  }

  /**
   * LocationArea createMany
   */
  export type LocationAreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocationAreas.
     */
    data: LocationAreaCreateManyInput | LocationAreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LocationArea createManyAndReturn
   */
  export type LocationAreaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationArea
     */
    select?: LocationAreaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LocationArea
     */
    omit?: LocationAreaOmit<ExtArgs> | null
    /**
     * The data used to create many LocationAreas.
     */
    data: LocationAreaCreateManyInput | LocationAreaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LocationArea update
   */
  export type LocationAreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationArea
     */
    select?: LocationAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationArea
     */
    omit?: LocationAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaInclude<ExtArgs> | null
    /**
     * The data needed to update a LocationArea.
     */
    data: XOR<LocationAreaUpdateInput, LocationAreaUncheckedUpdateInput>
    /**
     * Choose, which LocationArea to update.
     */
    where: LocationAreaWhereUniqueInput
  }

  /**
   * LocationArea updateMany
   */
  export type LocationAreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocationAreas.
     */
    data: XOR<LocationAreaUpdateManyMutationInput, LocationAreaUncheckedUpdateManyInput>
    /**
     * Filter which LocationAreas to update
     */
    where?: LocationAreaWhereInput
    /**
     * Limit how many LocationAreas to update.
     */
    limit?: number
  }

  /**
   * LocationArea updateManyAndReturn
   */
  export type LocationAreaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationArea
     */
    select?: LocationAreaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LocationArea
     */
    omit?: LocationAreaOmit<ExtArgs> | null
    /**
     * The data used to update LocationAreas.
     */
    data: XOR<LocationAreaUpdateManyMutationInput, LocationAreaUncheckedUpdateManyInput>
    /**
     * Filter which LocationAreas to update
     */
    where?: LocationAreaWhereInput
    /**
     * Limit how many LocationAreas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LocationArea upsert
   */
  export type LocationAreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationArea
     */
    select?: LocationAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationArea
     */
    omit?: LocationAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaInclude<ExtArgs> | null
    /**
     * The filter to search for the LocationArea to update in case it exists.
     */
    where: LocationAreaWhereUniqueInput
    /**
     * In case the LocationArea found by the `where` argument doesn't exist, create a new LocationArea with this data.
     */
    create: XOR<LocationAreaCreateInput, LocationAreaUncheckedCreateInput>
    /**
     * In case the LocationArea was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationAreaUpdateInput, LocationAreaUncheckedUpdateInput>
  }

  /**
   * LocationArea delete
   */
  export type LocationAreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationArea
     */
    select?: LocationAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationArea
     */
    omit?: LocationAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaInclude<ExtArgs> | null
    /**
     * Filter which LocationArea to delete.
     */
    where: LocationAreaWhereUniqueInput
  }

  /**
   * LocationArea deleteMany
   */
  export type LocationAreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationAreas to delete
     */
    where?: LocationAreaWhereInput
    /**
     * Limit how many LocationAreas to delete.
     */
    limit?: number
  }

  /**
   * LocationArea.encounters
   */
  export type LocationArea$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * LocationArea.encounterRates
   */
  export type LocationArea$encounterRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAreaEncounterRate
     */
    select?: LocationAreaEncounterRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAreaEncounterRate
     */
    omit?: LocationAreaEncounterRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaEncounterRateInclude<ExtArgs> | null
    where?: LocationAreaEncounterRateWhereInput
    orderBy?: LocationAreaEncounterRateOrderByWithRelationInput | LocationAreaEncounterRateOrderByWithRelationInput[]
    cursor?: LocationAreaEncounterRateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationAreaEncounterRateScalarFieldEnum | LocationAreaEncounterRateScalarFieldEnum[]
  }

  /**
   * LocationArea without action
   */
  export type LocationAreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationArea
     */
    select?: LocationAreaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationArea
     */
    omit?: LocationAreaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaInclude<ExtArgs> | null
  }


  /**
   * Model EncounterMethod
   */

  export type AggregateEncounterMethod = {
    _count: EncounterMethodCountAggregateOutputType | null
    _avg: EncounterMethodAvgAggregateOutputType | null
    _sum: EncounterMethodSumAggregateOutputType | null
    _min: EncounterMethodMinAggregateOutputType | null
    _max: EncounterMethodMaxAggregateOutputType | null
  }

  export type EncounterMethodAvgAggregateOutputType = {
    id: number | null
  }

  export type EncounterMethodSumAggregateOutputType = {
    id: number | null
  }

  export type EncounterMethodMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type EncounterMethodMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type EncounterMethodCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type EncounterMethodAvgAggregateInputType = {
    id?: true
  }

  export type EncounterMethodSumAggregateInputType = {
    id?: true
  }

  export type EncounterMethodMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type EncounterMethodMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type EncounterMethodCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type EncounterMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterMethod to aggregate.
     */
    where?: EncounterMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterMethods to fetch.
     */
    orderBy?: EncounterMethodOrderByWithRelationInput | EncounterMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncounterMethods
    **/
    _count?: true | EncounterMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncounterMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncounterMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterMethodMaxAggregateInputType
  }

  export type GetEncounterMethodAggregateType<T extends EncounterMethodAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounterMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounterMethod[P]>
      : GetScalarType<T[P], AggregateEncounterMethod[P]>
  }




  export type EncounterMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterMethodWhereInput
    orderBy?: EncounterMethodOrderByWithAggregationInput | EncounterMethodOrderByWithAggregationInput[]
    by: EncounterMethodScalarFieldEnum[] | EncounterMethodScalarFieldEnum
    having?: EncounterMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterMethodCountAggregateInputType | true
    _avg?: EncounterMethodAvgAggregateInputType
    _sum?: EncounterMethodSumAggregateInputType
    _min?: EncounterMethodMinAggregateInputType
    _max?: EncounterMethodMaxAggregateInputType
  }

  export type EncounterMethodGroupByOutputType = {
    id: number
    name: string
    _count: EncounterMethodCountAggregateOutputType | null
    _avg: EncounterMethodAvgAggregateOutputType | null
    _sum: EncounterMethodSumAggregateOutputType | null
    _min: EncounterMethodMinAggregateOutputType | null
    _max: EncounterMethodMaxAggregateOutputType | null
  }

  type GetEncounterMethodGroupByPayload<T extends EncounterMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterMethodGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterMethodGroupByOutputType[P]>
        }
      >
    >


  export type EncounterMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slots?: boolean | EncounterMethod$slotsArgs<ExtArgs>
    location_area_encounter_rates?: boolean | EncounterMethod$location_area_encounter_ratesArgs<ExtArgs>
    _count?: boolean | EncounterMethodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterMethod"]>

  export type EncounterMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["encounterMethod"]>

  export type EncounterMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["encounterMethod"]>

  export type EncounterMethodSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type EncounterMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["encounterMethod"]>
  export type EncounterMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    slots?: boolean | EncounterMethod$slotsArgs<ExtArgs>
    location_area_encounter_rates?: boolean | EncounterMethod$location_area_encounter_ratesArgs<ExtArgs>
    _count?: boolean | EncounterMethodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EncounterMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EncounterMethodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EncounterMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncounterMethod"
    objects: {
      slots: Prisma.$EncounterSlotPayload<ExtArgs>[]
      location_area_encounter_rates: Prisma.$LocationAreaEncounterRatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["encounterMethod"]>
    composites: {}
  }

  type EncounterMethodGetPayload<S extends boolean | null | undefined | EncounterMethodDefaultArgs> = $Result.GetResult<Prisma.$EncounterMethodPayload, S>

  type EncounterMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EncounterMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EncounterMethodCountAggregateInputType | true
    }

  export interface EncounterMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncounterMethod'], meta: { name: 'EncounterMethod' } }
    /**
     * Find zero or one EncounterMethod that matches the filter.
     * @param {EncounterMethodFindUniqueArgs} args - Arguments to find a EncounterMethod
     * @example
     * // Get one EncounterMethod
     * const encounterMethod = await prisma.encounterMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterMethodFindUniqueArgs>(args: SelectSubset<T, EncounterMethodFindUniqueArgs<ExtArgs>>): Prisma__EncounterMethodClient<$Result.GetResult<Prisma.$EncounterMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EncounterMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EncounterMethodFindUniqueOrThrowArgs} args - Arguments to find a EncounterMethod
     * @example
     * // Get one EncounterMethod
     * const encounterMethod = await prisma.encounterMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterMethodClient<$Result.GetResult<Prisma.$EncounterMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EncounterMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterMethodFindFirstArgs} args - Arguments to find a EncounterMethod
     * @example
     * // Get one EncounterMethod
     * const encounterMethod = await prisma.encounterMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterMethodFindFirstArgs>(args?: SelectSubset<T, EncounterMethodFindFirstArgs<ExtArgs>>): Prisma__EncounterMethodClient<$Result.GetResult<Prisma.$EncounterMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EncounterMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterMethodFindFirstOrThrowArgs} args - Arguments to find a EncounterMethod
     * @example
     * // Get one EncounterMethod
     * const encounterMethod = await prisma.encounterMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterMethodClient<$Result.GetResult<Prisma.$EncounterMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EncounterMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncounterMethods
     * const encounterMethods = await prisma.encounterMethod.findMany()
     * 
     * // Get first 10 EncounterMethods
     * const encounterMethods = await prisma.encounterMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterMethodWithIdOnly = await prisma.encounterMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterMethodFindManyArgs>(args?: SelectSubset<T, EncounterMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EncounterMethod.
     * @param {EncounterMethodCreateArgs} args - Arguments to create a EncounterMethod.
     * @example
     * // Create one EncounterMethod
     * const EncounterMethod = await prisma.encounterMethod.create({
     *   data: {
     *     // ... data to create a EncounterMethod
     *   }
     * })
     * 
     */
    create<T extends EncounterMethodCreateArgs>(args: SelectSubset<T, EncounterMethodCreateArgs<ExtArgs>>): Prisma__EncounterMethodClient<$Result.GetResult<Prisma.$EncounterMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EncounterMethods.
     * @param {EncounterMethodCreateManyArgs} args - Arguments to create many EncounterMethods.
     * @example
     * // Create many EncounterMethods
     * const encounterMethod = await prisma.encounterMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterMethodCreateManyArgs>(args?: SelectSubset<T, EncounterMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EncounterMethods and returns the data saved in the database.
     * @param {EncounterMethodCreateManyAndReturnArgs} args - Arguments to create many EncounterMethods.
     * @example
     * // Create many EncounterMethods
     * const encounterMethod = await prisma.encounterMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EncounterMethods and only return the `id`
     * const encounterMethodWithIdOnly = await prisma.encounterMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EncounterMethod.
     * @param {EncounterMethodDeleteArgs} args - Arguments to delete one EncounterMethod.
     * @example
     * // Delete one EncounterMethod
     * const EncounterMethod = await prisma.encounterMethod.delete({
     *   where: {
     *     // ... filter to delete one EncounterMethod
     *   }
     * })
     * 
     */
    delete<T extends EncounterMethodDeleteArgs>(args: SelectSubset<T, EncounterMethodDeleteArgs<ExtArgs>>): Prisma__EncounterMethodClient<$Result.GetResult<Prisma.$EncounterMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EncounterMethod.
     * @param {EncounterMethodUpdateArgs} args - Arguments to update one EncounterMethod.
     * @example
     * // Update one EncounterMethod
     * const encounterMethod = await prisma.encounterMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterMethodUpdateArgs>(args: SelectSubset<T, EncounterMethodUpdateArgs<ExtArgs>>): Prisma__EncounterMethodClient<$Result.GetResult<Prisma.$EncounterMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EncounterMethods.
     * @param {EncounterMethodDeleteManyArgs} args - Arguments to filter EncounterMethods to delete.
     * @example
     * // Delete a few EncounterMethods
     * const { count } = await prisma.encounterMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterMethodDeleteManyArgs>(args?: SelectSubset<T, EncounterMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncounterMethods
     * const encounterMethod = await prisma.encounterMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterMethodUpdateManyArgs>(args: SelectSubset<T, EncounterMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterMethods and returns the data updated in the database.
     * @param {EncounterMethodUpdateManyAndReturnArgs} args - Arguments to update many EncounterMethods.
     * @example
     * // Update many EncounterMethods
     * const encounterMethod = await prisma.encounterMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EncounterMethods and only return the `id`
     * const encounterMethodWithIdOnly = await prisma.encounterMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EncounterMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, EncounterMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EncounterMethod.
     * @param {EncounterMethodUpsertArgs} args - Arguments to update or create a EncounterMethod.
     * @example
     * // Update or create a EncounterMethod
     * const encounterMethod = await prisma.encounterMethod.upsert({
     *   create: {
     *     // ... data to create a EncounterMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncounterMethod we want to update
     *   }
     * })
     */
    upsert<T extends EncounterMethodUpsertArgs>(args: SelectSubset<T, EncounterMethodUpsertArgs<ExtArgs>>): Prisma__EncounterMethodClient<$Result.GetResult<Prisma.$EncounterMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EncounterMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterMethodCountArgs} args - Arguments to filter EncounterMethods to count.
     * @example
     * // Count the number of EncounterMethods
     * const count = await prisma.encounterMethod.count({
     *   where: {
     *     // ... the filter for the EncounterMethods we want to count
     *   }
     * })
    **/
    count<T extends EncounterMethodCountArgs>(
      args?: Subset<T, EncounterMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncounterMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterMethodAggregateArgs>(args: Subset<T, EncounterMethodAggregateArgs>): Prisma.PrismaPromise<GetEncounterMethodAggregateType<T>>

    /**
     * Group by EncounterMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterMethodGroupByArgs['orderBy'] }
        : { orderBy?: EncounterMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncounterMethod model
   */
  readonly fields: EncounterMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncounterMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    slots<T extends EncounterMethod$slotsArgs<ExtArgs> = {}>(args?: Subset<T, EncounterMethod$slotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    location_area_encounter_rates<T extends EncounterMethod$location_area_encounter_ratesArgs<ExtArgs> = {}>(args?: Subset<T, EncounterMethod$location_area_encounter_ratesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationAreaEncounterRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EncounterMethod model
   */
  interface EncounterMethodFieldRefs {
    readonly id: FieldRef<"EncounterMethod", 'Int'>
    readonly name: FieldRef<"EncounterMethod", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EncounterMethod findUnique
   */
  export type EncounterMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterMethod
     */
    select?: EncounterMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterMethod
     */
    omit?: EncounterMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterMethodInclude<ExtArgs> | null
    /**
     * Filter, which EncounterMethod to fetch.
     */
    where: EncounterMethodWhereUniqueInput
  }

  /**
   * EncounterMethod findUniqueOrThrow
   */
  export type EncounterMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterMethod
     */
    select?: EncounterMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterMethod
     */
    omit?: EncounterMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterMethodInclude<ExtArgs> | null
    /**
     * Filter, which EncounterMethod to fetch.
     */
    where: EncounterMethodWhereUniqueInput
  }

  /**
   * EncounterMethod findFirst
   */
  export type EncounterMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterMethod
     */
    select?: EncounterMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterMethod
     */
    omit?: EncounterMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterMethodInclude<ExtArgs> | null
    /**
     * Filter, which EncounterMethod to fetch.
     */
    where?: EncounterMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterMethods to fetch.
     */
    orderBy?: EncounterMethodOrderByWithRelationInput | EncounterMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterMethods.
     */
    cursor?: EncounterMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterMethods.
     */
    distinct?: EncounterMethodScalarFieldEnum | EncounterMethodScalarFieldEnum[]
  }

  /**
   * EncounterMethod findFirstOrThrow
   */
  export type EncounterMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterMethod
     */
    select?: EncounterMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterMethod
     */
    omit?: EncounterMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterMethodInclude<ExtArgs> | null
    /**
     * Filter, which EncounterMethod to fetch.
     */
    where?: EncounterMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterMethods to fetch.
     */
    orderBy?: EncounterMethodOrderByWithRelationInput | EncounterMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterMethods.
     */
    cursor?: EncounterMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterMethods.
     */
    distinct?: EncounterMethodScalarFieldEnum | EncounterMethodScalarFieldEnum[]
  }

  /**
   * EncounterMethod findMany
   */
  export type EncounterMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterMethod
     */
    select?: EncounterMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterMethod
     */
    omit?: EncounterMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterMethodInclude<ExtArgs> | null
    /**
     * Filter, which EncounterMethods to fetch.
     */
    where?: EncounterMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterMethods to fetch.
     */
    orderBy?: EncounterMethodOrderByWithRelationInput | EncounterMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncounterMethods.
     */
    cursor?: EncounterMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterMethods.
     */
    skip?: number
    distinct?: EncounterMethodScalarFieldEnum | EncounterMethodScalarFieldEnum[]
  }

  /**
   * EncounterMethod create
   */
  export type EncounterMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterMethod
     */
    select?: EncounterMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterMethod
     */
    omit?: EncounterMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a EncounterMethod.
     */
    data: XOR<EncounterMethodCreateInput, EncounterMethodUncheckedCreateInput>
  }

  /**
   * EncounterMethod createMany
   */
  export type EncounterMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncounterMethods.
     */
    data: EncounterMethodCreateManyInput | EncounterMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncounterMethod createManyAndReturn
   */
  export type EncounterMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterMethod
     */
    select?: EncounterMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterMethod
     */
    omit?: EncounterMethodOmit<ExtArgs> | null
    /**
     * The data used to create many EncounterMethods.
     */
    data: EncounterMethodCreateManyInput | EncounterMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncounterMethod update
   */
  export type EncounterMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterMethod
     */
    select?: EncounterMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterMethod
     */
    omit?: EncounterMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a EncounterMethod.
     */
    data: XOR<EncounterMethodUpdateInput, EncounterMethodUncheckedUpdateInput>
    /**
     * Choose, which EncounterMethod to update.
     */
    where: EncounterMethodWhereUniqueInput
  }

  /**
   * EncounterMethod updateMany
   */
  export type EncounterMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncounterMethods.
     */
    data: XOR<EncounterMethodUpdateManyMutationInput, EncounterMethodUncheckedUpdateManyInput>
    /**
     * Filter which EncounterMethods to update
     */
    where?: EncounterMethodWhereInput
    /**
     * Limit how many EncounterMethods to update.
     */
    limit?: number
  }

  /**
   * EncounterMethod updateManyAndReturn
   */
  export type EncounterMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterMethod
     */
    select?: EncounterMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterMethod
     */
    omit?: EncounterMethodOmit<ExtArgs> | null
    /**
     * The data used to update EncounterMethods.
     */
    data: XOR<EncounterMethodUpdateManyMutationInput, EncounterMethodUncheckedUpdateManyInput>
    /**
     * Filter which EncounterMethods to update
     */
    where?: EncounterMethodWhereInput
    /**
     * Limit how many EncounterMethods to update.
     */
    limit?: number
  }

  /**
   * EncounterMethod upsert
   */
  export type EncounterMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterMethod
     */
    select?: EncounterMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterMethod
     */
    omit?: EncounterMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the EncounterMethod to update in case it exists.
     */
    where: EncounterMethodWhereUniqueInput
    /**
     * In case the EncounterMethod found by the `where` argument doesn't exist, create a new EncounterMethod with this data.
     */
    create: XOR<EncounterMethodCreateInput, EncounterMethodUncheckedCreateInput>
    /**
     * In case the EncounterMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterMethodUpdateInput, EncounterMethodUncheckedUpdateInput>
  }

  /**
   * EncounterMethod delete
   */
  export type EncounterMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterMethod
     */
    select?: EncounterMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterMethod
     */
    omit?: EncounterMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterMethodInclude<ExtArgs> | null
    /**
     * Filter which EncounterMethod to delete.
     */
    where: EncounterMethodWhereUniqueInput
  }

  /**
   * EncounterMethod deleteMany
   */
  export type EncounterMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterMethods to delete
     */
    where?: EncounterMethodWhereInput
    /**
     * Limit how many EncounterMethods to delete.
     */
    limit?: number
  }

  /**
   * EncounterMethod.slots
   */
  export type EncounterMethod$slotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSlot
     */
    select?: EncounterSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterSlot
     */
    omit?: EncounterSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSlotInclude<ExtArgs> | null
    where?: EncounterSlotWhereInput
    orderBy?: EncounterSlotOrderByWithRelationInput | EncounterSlotOrderByWithRelationInput[]
    cursor?: EncounterSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterSlotScalarFieldEnum | EncounterSlotScalarFieldEnum[]
  }

  /**
   * EncounterMethod.location_area_encounter_rates
   */
  export type EncounterMethod$location_area_encounter_ratesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAreaEncounterRate
     */
    select?: LocationAreaEncounterRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAreaEncounterRate
     */
    omit?: LocationAreaEncounterRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaEncounterRateInclude<ExtArgs> | null
    where?: LocationAreaEncounterRateWhereInput
    orderBy?: LocationAreaEncounterRateOrderByWithRelationInput | LocationAreaEncounterRateOrderByWithRelationInput[]
    cursor?: LocationAreaEncounterRateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationAreaEncounterRateScalarFieldEnum | LocationAreaEncounterRateScalarFieldEnum[]
  }

  /**
   * EncounterMethod without action
   */
  export type EncounterMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterMethod
     */
    select?: EncounterMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterMethod
     */
    omit?: EncounterMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterMethodInclude<ExtArgs> | null
  }


  /**
   * Model EncounterSlot
   */

  export type AggregateEncounterSlot = {
    _count: EncounterSlotCountAggregateOutputType | null
    _avg: EncounterSlotAvgAggregateOutputType | null
    _sum: EncounterSlotSumAggregateOutputType | null
    _min: EncounterSlotMinAggregateOutputType | null
    _max: EncounterSlotMaxAggregateOutputType | null
  }

  export type EncounterSlotAvgAggregateOutputType = {
    id: number | null
    version_group_id: number | null
    encounter_method_id: number | null
    slot: number | null
    rarity: number | null
  }

  export type EncounterSlotSumAggregateOutputType = {
    id: number | null
    version_group_id: number | null
    encounter_method_id: number | null
    slot: number | null
    rarity: number | null
  }

  export type EncounterSlotMinAggregateOutputType = {
    id: number | null
    version_group_id: number | null
    encounter_method_id: number | null
    slot: number | null
    rarity: number | null
  }

  export type EncounterSlotMaxAggregateOutputType = {
    id: number | null
    version_group_id: number | null
    encounter_method_id: number | null
    slot: number | null
    rarity: number | null
  }

  export type EncounterSlotCountAggregateOutputType = {
    id: number
    version_group_id: number
    encounter_method_id: number
    slot: number
    rarity: number
    _all: number
  }


  export type EncounterSlotAvgAggregateInputType = {
    id?: true
    version_group_id?: true
    encounter_method_id?: true
    slot?: true
    rarity?: true
  }

  export type EncounterSlotSumAggregateInputType = {
    id?: true
    version_group_id?: true
    encounter_method_id?: true
    slot?: true
    rarity?: true
  }

  export type EncounterSlotMinAggregateInputType = {
    id?: true
    version_group_id?: true
    encounter_method_id?: true
    slot?: true
    rarity?: true
  }

  export type EncounterSlotMaxAggregateInputType = {
    id?: true
    version_group_id?: true
    encounter_method_id?: true
    slot?: true
    rarity?: true
  }

  export type EncounterSlotCountAggregateInputType = {
    id?: true
    version_group_id?: true
    encounter_method_id?: true
    slot?: true
    rarity?: true
    _all?: true
  }

  export type EncounterSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterSlot to aggregate.
     */
    where?: EncounterSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterSlots to fetch.
     */
    orderBy?: EncounterSlotOrderByWithRelationInput | EncounterSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncounterSlots
    **/
    _count?: true | EncounterSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncounterSlotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncounterSlotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterSlotMaxAggregateInputType
  }

  export type GetEncounterSlotAggregateType<T extends EncounterSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounterSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounterSlot[P]>
      : GetScalarType<T[P], AggregateEncounterSlot[P]>
  }




  export type EncounterSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterSlotWhereInput
    orderBy?: EncounterSlotOrderByWithAggregationInput | EncounterSlotOrderByWithAggregationInput[]
    by: EncounterSlotScalarFieldEnum[] | EncounterSlotScalarFieldEnum
    having?: EncounterSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterSlotCountAggregateInputType | true
    _avg?: EncounterSlotAvgAggregateInputType
    _sum?: EncounterSlotSumAggregateInputType
    _min?: EncounterSlotMinAggregateInputType
    _max?: EncounterSlotMaxAggregateInputType
  }

  export type EncounterSlotGroupByOutputType = {
    id: number
    version_group_id: number
    encounter_method_id: number
    slot: number
    rarity: number
    _count: EncounterSlotCountAggregateOutputType | null
    _avg: EncounterSlotAvgAggregateOutputType | null
    _sum: EncounterSlotSumAggregateOutputType | null
    _min: EncounterSlotMinAggregateOutputType | null
    _max: EncounterSlotMaxAggregateOutputType | null
  }

  type GetEncounterSlotGroupByPayload<T extends EncounterSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterSlotGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterSlotGroupByOutputType[P]>
        }
      >
    >


  export type EncounterSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version_group_id?: boolean
    encounter_method_id?: boolean
    slot?: boolean
    rarity?: boolean
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
    method?: boolean | EncounterMethodDefaultArgs<ExtArgs>
    encounters?: boolean | EncounterSlot$encountersArgs<ExtArgs>
    _count?: boolean | EncounterSlotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterSlot"]>

  export type EncounterSlotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version_group_id?: boolean
    encounter_method_id?: boolean
    slot?: boolean
    rarity?: boolean
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
    method?: boolean | EncounterMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterSlot"]>

  export type EncounterSlotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version_group_id?: boolean
    encounter_method_id?: boolean
    slot?: boolean
    rarity?: boolean
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
    method?: boolean | EncounterMethodDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterSlot"]>

  export type EncounterSlotSelectScalar = {
    id?: boolean
    version_group_id?: boolean
    encounter_method_id?: boolean
    slot?: boolean
    rarity?: boolean
  }

  export type EncounterSlotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "version_group_id" | "encounter_method_id" | "slot" | "rarity", ExtArgs["result"]["encounterSlot"]>
  export type EncounterSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
    method?: boolean | EncounterMethodDefaultArgs<ExtArgs>
    encounters?: boolean | EncounterSlot$encountersArgs<ExtArgs>
    _count?: boolean | EncounterSlotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EncounterSlotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
    method?: boolean | EncounterMethodDefaultArgs<ExtArgs>
  }
  export type EncounterSlotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
    method?: boolean | EncounterMethodDefaultArgs<ExtArgs>
  }

  export type $EncounterSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncounterSlot"
    objects: {
      version_group: Prisma.$VersionGroupPayload<ExtArgs>
      method: Prisma.$EncounterMethodPayload<ExtArgs>
      encounters: Prisma.$EncounterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      version_group_id: number
      encounter_method_id: number
      slot: number
      rarity: number
    }, ExtArgs["result"]["encounterSlot"]>
    composites: {}
  }

  type EncounterSlotGetPayload<S extends boolean | null | undefined | EncounterSlotDefaultArgs> = $Result.GetResult<Prisma.$EncounterSlotPayload, S>

  type EncounterSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EncounterSlotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EncounterSlotCountAggregateInputType | true
    }

  export interface EncounterSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncounterSlot'], meta: { name: 'EncounterSlot' } }
    /**
     * Find zero or one EncounterSlot that matches the filter.
     * @param {EncounterSlotFindUniqueArgs} args - Arguments to find a EncounterSlot
     * @example
     * // Get one EncounterSlot
     * const encounterSlot = await prisma.encounterSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterSlotFindUniqueArgs>(args: SelectSubset<T, EncounterSlotFindUniqueArgs<ExtArgs>>): Prisma__EncounterSlotClient<$Result.GetResult<Prisma.$EncounterSlotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EncounterSlot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EncounterSlotFindUniqueOrThrowArgs} args - Arguments to find a EncounterSlot
     * @example
     * // Get one EncounterSlot
     * const encounterSlot = await prisma.encounterSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterSlotClient<$Result.GetResult<Prisma.$EncounterSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EncounterSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterSlotFindFirstArgs} args - Arguments to find a EncounterSlot
     * @example
     * // Get one EncounterSlot
     * const encounterSlot = await prisma.encounterSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterSlotFindFirstArgs>(args?: SelectSubset<T, EncounterSlotFindFirstArgs<ExtArgs>>): Prisma__EncounterSlotClient<$Result.GetResult<Prisma.$EncounterSlotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EncounterSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterSlotFindFirstOrThrowArgs} args - Arguments to find a EncounterSlot
     * @example
     * // Get one EncounterSlot
     * const encounterSlot = await prisma.encounterSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterSlotClient<$Result.GetResult<Prisma.$EncounterSlotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EncounterSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncounterSlots
     * const encounterSlots = await prisma.encounterSlot.findMany()
     * 
     * // Get first 10 EncounterSlots
     * const encounterSlots = await prisma.encounterSlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterSlotWithIdOnly = await prisma.encounterSlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterSlotFindManyArgs>(args?: SelectSubset<T, EncounterSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterSlotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EncounterSlot.
     * @param {EncounterSlotCreateArgs} args - Arguments to create a EncounterSlot.
     * @example
     * // Create one EncounterSlot
     * const EncounterSlot = await prisma.encounterSlot.create({
     *   data: {
     *     // ... data to create a EncounterSlot
     *   }
     * })
     * 
     */
    create<T extends EncounterSlotCreateArgs>(args: SelectSubset<T, EncounterSlotCreateArgs<ExtArgs>>): Prisma__EncounterSlotClient<$Result.GetResult<Prisma.$EncounterSlotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EncounterSlots.
     * @param {EncounterSlotCreateManyArgs} args - Arguments to create many EncounterSlots.
     * @example
     * // Create many EncounterSlots
     * const encounterSlot = await prisma.encounterSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterSlotCreateManyArgs>(args?: SelectSubset<T, EncounterSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EncounterSlots and returns the data saved in the database.
     * @param {EncounterSlotCreateManyAndReturnArgs} args - Arguments to create many EncounterSlots.
     * @example
     * // Create many EncounterSlots
     * const encounterSlot = await prisma.encounterSlot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EncounterSlots and only return the `id`
     * const encounterSlotWithIdOnly = await prisma.encounterSlot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterSlotCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterSlotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterSlotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EncounterSlot.
     * @param {EncounterSlotDeleteArgs} args - Arguments to delete one EncounterSlot.
     * @example
     * // Delete one EncounterSlot
     * const EncounterSlot = await prisma.encounterSlot.delete({
     *   where: {
     *     // ... filter to delete one EncounterSlot
     *   }
     * })
     * 
     */
    delete<T extends EncounterSlotDeleteArgs>(args: SelectSubset<T, EncounterSlotDeleteArgs<ExtArgs>>): Prisma__EncounterSlotClient<$Result.GetResult<Prisma.$EncounterSlotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EncounterSlot.
     * @param {EncounterSlotUpdateArgs} args - Arguments to update one EncounterSlot.
     * @example
     * // Update one EncounterSlot
     * const encounterSlot = await prisma.encounterSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterSlotUpdateArgs>(args: SelectSubset<T, EncounterSlotUpdateArgs<ExtArgs>>): Prisma__EncounterSlotClient<$Result.GetResult<Prisma.$EncounterSlotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EncounterSlots.
     * @param {EncounterSlotDeleteManyArgs} args - Arguments to filter EncounterSlots to delete.
     * @example
     * // Delete a few EncounterSlots
     * const { count } = await prisma.encounterSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterSlotDeleteManyArgs>(args?: SelectSubset<T, EncounterSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncounterSlots
     * const encounterSlot = await prisma.encounterSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterSlotUpdateManyArgs>(args: SelectSubset<T, EncounterSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterSlots and returns the data updated in the database.
     * @param {EncounterSlotUpdateManyAndReturnArgs} args - Arguments to update many EncounterSlots.
     * @example
     * // Update many EncounterSlots
     * const encounterSlot = await prisma.encounterSlot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EncounterSlots and only return the `id`
     * const encounterSlotWithIdOnly = await prisma.encounterSlot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EncounterSlotUpdateManyAndReturnArgs>(args: SelectSubset<T, EncounterSlotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterSlotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EncounterSlot.
     * @param {EncounterSlotUpsertArgs} args - Arguments to update or create a EncounterSlot.
     * @example
     * // Update or create a EncounterSlot
     * const encounterSlot = await prisma.encounterSlot.upsert({
     *   create: {
     *     // ... data to create a EncounterSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncounterSlot we want to update
     *   }
     * })
     */
    upsert<T extends EncounterSlotUpsertArgs>(args: SelectSubset<T, EncounterSlotUpsertArgs<ExtArgs>>): Prisma__EncounterSlotClient<$Result.GetResult<Prisma.$EncounterSlotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EncounterSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterSlotCountArgs} args - Arguments to filter EncounterSlots to count.
     * @example
     * // Count the number of EncounterSlots
     * const count = await prisma.encounterSlot.count({
     *   where: {
     *     // ... the filter for the EncounterSlots we want to count
     *   }
     * })
    **/
    count<T extends EncounterSlotCountArgs>(
      args?: Subset<T, EncounterSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncounterSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterSlotAggregateArgs>(args: Subset<T, EncounterSlotAggregateArgs>): Prisma.PrismaPromise<GetEncounterSlotAggregateType<T>>

    /**
     * Group by EncounterSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterSlotGroupByArgs['orderBy'] }
        : { orderBy?: EncounterSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncounterSlot model
   */
  readonly fields: EncounterSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncounterSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    version_group<T extends VersionGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VersionGroupDefaultArgs<ExtArgs>>): Prisma__VersionGroupClient<$Result.GetResult<Prisma.$VersionGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    method<T extends EncounterMethodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterMethodDefaultArgs<ExtArgs>>): Prisma__EncounterMethodClient<$Result.GetResult<Prisma.$EncounterMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    encounters<T extends EncounterSlot$encountersArgs<ExtArgs> = {}>(args?: Subset<T, EncounterSlot$encountersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EncounterSlot model
   */
  interface EncounterSlotFieldRefs {
    readonly id: FieldRef<"EncounterSlot", 'Int'>
    readonly version_group_id: FieldRef<"EncounterSlot", 'Int'>
    readonly encounter_method_id: FieldRef<"EncounterSlot", 'Int'>
    readonly slot: FieldRef<"EncounterSlot", 'Int'>
    readonly rarity: FieldRef<"EncounterSlot", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EncounterSlot findUnique
   */
  export type EncounterSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSlot
     */
    select?: EncounterSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterSlot
     */
    omit?: EncounterSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSlotInclude<ExtArgs> | null
    /**
     * Filter, which EncounterSlot to fetch.
     */
    where: EncounterSlotWhereUniqueInput
  }

  /**
   * EncounterSlot findUniqueOrThrow
   */
  export type EncounterSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSlot
     */
    select?: EncounterSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterSlot
     */
    omit?: EncounterSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSlotInclude<ExtArgs> | null
    /**
     * Filter, which EncounterSlot to fetch.
     */
    where: EncounterSlotWhereUniqueInput
  }

  /**
   * EncounterSlot findFirst
   */
  export type EncounterSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSlot
     */
    select?: EncounterSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterSlot
     */
    omit?: EncounterSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSlotInclude<ExtArgs> | null
    /**
     * Filter, which EncounterSlot to fetch.
     */
    where?: EncounterSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterSlots to fetch.
     */
    orderBy?: EncounterSlotOrderByWithRelationInput | EncounterSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterSlots.
     */
    cursor?: EncounterSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterSlots.
     */
    distinct?: EncounterSlotScalarFieldEnum | EncounterSlotScalarFieldEnum[]
  }

  /**
   * EncounterSlot findFirstOrThrow
   */
  export type EncounterSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSlot
     */
    select?: EncounterSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterSlot
     */
    omit?: EncounterSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSlotInclude<ExtArgs> | null
    /**
     * Filter, which EncounterSlot to fetch.
     */
    where?: EncounterSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterSlots to fetch.
     */
    orderBy?: EncounterSlotOrderByWithRelationInput | EncounterSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterSlots.
     */
    cursor?: EncounterSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterSlots.
     */
    distinct?: EncounterSlotScalarFieldEnum | EncounterSlotScalarFieldEnum[]
  }

  /**
   * EncounterSlot findMany
   */
  export type EncounterSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSlot
     */
    select?: EncounterSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterSlot
     */
    omit?: EncounterSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSlotInclude<ExtArgs> | null
    /**
     * Filter, which EncounterSlots to fetch.
     */
    where?: EncounterSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterSlots to fetch.
     */
    orderBy?: EncounterSlotOrderByWithRelationInput | EncounterSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncounterSlots.
     */
    cursor?: EncounterSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterSlots.
     */
    skip?: number
    distinct?: EncounterSlotScalarFieldEnum | EncounterSlotScalarFieldEnum[]
  }

  /**
   * EncounterSlot create
   */
  export type EncounterSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSlot
     */
    select?: EncounterSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterSlot
     */
    omit?: EncounterSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a EncounterSlot.
     */
    data: XOR<EncounterSlotCreateInput, EncounterSlotUncheckedCreateInput>
  }

  /**
   * EncounterSlot createMany
   */
  export type EncounterSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncounterSlots.
     */
    data: EncounterSlotCreateManyInput | EncounterSlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncounterSlot createManyAndReturn
   */
  export type EncounterSlotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSlot
     */
    select?: EncounterSlotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterSlot
     */
    omit?: EncounterSlotOmit<ExtArgs> | null
    /**
     * The data used to create many EncounterSlots.
     */
    data: EncounterSlotCreateManyInput | EncounterSlotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSlotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EncounterSlot update
   */
  export type EncounterSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSlot
     */
    select?: EncounterSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterSlot
     */
    omit?: EncounterSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a EncounterSlot.
     */
    data: XOR<EncounterSlotUpdateInput, EncounterSlotUncheckedUpdateInput>
    /**
     * Choose, which EncounterSlot to update.
     */
    where: EncounterSlotWhereUniqueInput
  }

  /**
   * EncounterSlot updateMany
   */
  export type EncounterSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncounterSlots.
     */
    data: XOR<EncounterSlotUpdateManyMutationInput, EncounterSlotUncheckedUpdateManyInput>
    /**
     * Filter which EncounterSlots to update
     */
    where?: EncounterSlotWhereInput
    /**
     * Limit how many EncounterSlots to update.
     */
    limit?: number
  }

  /**
   * EncounterSlot updateManyAndReturn
   */
  export type EncounterSlotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSlot
     */
    select?: EncounterSlotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterSlot
     */
    omit?: EncounterSlotOmit<ExtArgs> | null
    /**
     * The data used to update EncounterSlots.
     */
    data: XOR<EncounterSlotUpdateManyMutationInput, EncounterSlotUncheckedUpdateManyInput>
    /**
     * Filter which EncounterSlots to update
     */
    where?: EncounterSlotWhereInput
    /**
     * Limit how many EncounterSlots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSlotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EncounterSlot upsert
   */
  export type EncounterSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSlot
     */
    select?: EncounterSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterSlot
     */
    omit?: EncounterSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the EncounterSlot to update in case it exists.
     */
    where: EncounterSlotWhereUniqueInput
    /**
     * In case the EncounterSlot found by the `where` argument doesn't exist, create a new EncounterSlot with this data.
     */
    create: XOR<EncounterSlotCreateInput, EncounterSlotUncheckedCreateInput>
    /**
     * In case the EncounterSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterSlotUpdateInput, EncounterSlotUncheckedUpdateInput>
  }

  /**
   * EncounterSlot delete
   */
  export type EncounterSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSlot
     */
    select?: EncounterSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterSlot
     */
    omit?: EncounterSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSlotInclude<ExtArgs> | null
    /**
     * Filter which EncounterSlot to delete.
     */
    where: EncounterSlotWhereUniqueInput
  }

  /**
   * EncounterSlot deleteMany
   */
  export type EncounterSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterSlots to delete
     */
    where?: EncounterSlotWhereInput
    /**
     * Limit how many EncounterSlots to delete.
     */
    limit?: number
  }

  /**
   * EncounterSlot.encounters
   */
  export type EncounterSlot$encountersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    cursor?: EncounterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * EncounterSlot without action
   */
  export type EncounterSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterSlot
     */
    select?: EncounterSlotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterSlot
     */
    omit?: EncounterSlotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterSlotInclude<ExtArgs> | null
  }


  /**
   * Model Encounter
   */

  export type AggregateEncounter = {
    _count: EncounterCountAggregateOutputType | null
    _avg: EncounterAvgAggregateOutputType | null
    _sum: EncounterSumAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  export type EncounterAvgAggregateOutputType = {
    id: number | null
    version_id: number | null
    pokemon_id: number | null
    location_area_id: number | null
    encounter_slot_id: number | null
    min_level: number | null
    max_level: number | null
  }

  export type EncounterSumAggregateOutputType = {
    id: number | null
    version_id: number | null
    pokemon_id: number | null
    location_area_id: number | null
    encounter_slot_id: number | null
    min_level: number | null
    max_level: number | null
  }

  export type EncounterMinAggregateOutputType = {
    id: number | null
    version_id: number | null
    pokemon_id: number | null
    location_area_id: number | null
    encounter_slot_id: number | null
    min_level: number | null
    max_level: number | null
  }

  export type EncounterMaxAggregateOutputType = {
    id: number | null
    version_id: number | null
    pokemon_id: number | null
    location_area_id: number | null
    encounter_slot_id: number | null
    min_level: number | null
    max_level: number | null
  }

  export type EncounterCountAggregateOutputType = {
    id: number
    version_id: number
    pokemon_id: number
    location_area_id: number
    encounter_slot_id: number
    min_level: number
    max_level: number
    _all: number
  }


  export type EncounterAvgAggregateInputType = {
    id?: true
    version_id?: true
    pokemon_id?: true
    location_area_id?: true
    encounter_slot_id?: true
    min_level?: true
    max_level?: true
  }

  export type EncounterSumAggregateInputType = {
    id?: true
    version_id?: true
    pokemon_id?: true
    location_area_id?: true
    encounter_slot_id?: true
    min_level?: true
    max_level?: true
  }

  export type EncounterMinAggregateInputType = {
    id?: true
    version_id?: true
    pokemon_id?: true
    location_area_id?: true
    encounter_slot_id?: true
    min_level?: true
    max_level?: true
  }

  export type EncounterMaxAggregateInputType = {
    id?: true
    version_id?: true
    pokemon_id?: true
    location_area_id?: true
    encounter_slot_id?: true
    min_level?: true
    max_level?: true
  }

  export type EncounterCountAggregateInputType = {
    id?: true
    version_id?: true
    pokemon_id?: true
    location_area_id?: true
    encounter_slot_id?: true
    min_level?: true
    max_level?: true
    _all?: true
  }

  export type EncounterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounter to aggregate.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Encounters
    **/
    _count?: true | EncounterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncounterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncounterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterMaxAggregateInputType
  }

  export type GetEncounterAggregateType<T extends EncounterAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounter[P]>
      : GetScalarType<T[P], AggregateEncounter[P]>
  }




  export type EncounterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterWhereInput
    orderBy?: EncounterOrderByWithAggregationInput | EncounterOrderByWithAggregationInput[]
    by: EncounterScalarFieldEnum[] | EncounterScalarFieldEnum
    having?: EncounterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterCountAggregateInputType | true
    _avg?: EncounterAvgAggregateInputType
    _sum?: EncounterSumAggregateInputType
    _min?: EncounterMinAggregateInputType
    _max?: EncounterMaxAggregateInputType
  }

  export type EncounterGroupByOutputType = {
    id: number
    version_id: number
    pokemon_id: number
    location_area_id: number
    encounter_slot_id: number
    min_level: number
    max_level: number
    _count: EncounterCountAggregateOutputType | null
    _avg: EncounterAvgAggregateOutputType | null
    _sum: EncounterSumAggregateOutputType | null
    _min: EncounterMinAggregateOutputType | null
    _max: EncounterMaxAggregateOutputType | null
  }

  type GetEncounterGroupByPayload<T extends EncounterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterGroupByOutputType[P]>
        }
      >
    >


  export type EncounterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version_id?: boolean
    pokemon_id?: boolean
    location_area_id?: boolean
    encounter_slot_id?: boolean
    min_level?: boolean
    max_level?: boolean
    version?: boolean | VersionDefaultArgs<ExtArgs>
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    location_area?: boolean | LocationAreaDefaultArgs<ExtArgs>
    slot?: boolean | EncounterSlotDefaultArgs<ExtArgs>
    conditions?: boolean | Encounter$conditionsArgs<ExtArgs>
    _count?: boolean | EncounterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version_id?: boolean
    pokemon_id?: boolean
    location_area_id?: boolean
    encounter_slot_id?: boolean
    min_level?: boolean
    max_level?: boolean
    version?: boolean | VersionDefaultArgs<ExtArgs>
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    location_area?: boolean | LocationAreaDefaultArgs<ExtArgs>
    slot?: boolean | EncounterSlotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version_id?: boolean
    pokemon_id?: boolean
    location_area_id?: boolean
    encounter_slot_id?: boolean
    min_level?: boolean
    max_level?: boolean
    version?: boolean | VersionDefaultArgs<ExtArgs>
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    location_area?: boolean | LocationAreaDefaultArgs<ExtArgs>
    slot?: boolean | EncounterSlotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounter"]>

  export type EncounterSelectScalar = {
    id?: boolean
    version_id?: boolean
    pokemon_id?: boolean
    location_area_id?: boolean
    encounter_slot_id?: boolean
    min_level?: boolean
    max_level?: boolean
  }

  export type EncounterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "version_id" | "pokemon_id" | "location_area_id" | "encounter_slot_id" | "min_level" | "max_level", ExtArgs["result"]["encounter"]>
  export type EncounterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version?: boolean | VersionDefaultArgs<ExtArgs>
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    location_area?: boolean | LocationAreaDefaultArgs<ExtArgs>
    slot?: boolean | EncounterSlotDefaultArgs<ExtArgs>
    conditions?: boolean | Encounter$conditionsArgs<ExtArgs>
    _count?: boolean | EncounterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EncounterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version?: boolean | VersionDefaultArgs<ExtArgs>
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    location_area?: boolean | LocationAreaDefaultArgs<ExtArgs>
    slot?: boolean | EncounterSlotDefaultArgs<ExtArgs>
  }
  export type EncounterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version?: boolean | VersionDefaultArgs<ExtArgs>
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    location_area?: boolean | LocationAreaDefaultArgs<ExtArgs>
    slot?: boolean | EncounterSlotDefaultArgs<ExtArgs>
  }

  export type $EncounterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Encounter"
    objects: {
      version: Prisma.$VersionPayload<ExtArgs>
      pokemon: Prisma.$PokemonPayload<ExtArgs>
      location_area: Prisma.$LocationAreaPayload<ExtArgs>
      slot: Prisma.$EncounterSlotPayload<ExtArgs>
      conditions: Prisma.$EncounterConditionValueMapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      version_id: number
      pokemon_id: number
      location_area_id: number
      encounter_slot_id: number
      min_level: number
      max_level: number
    }, ExtArgs["result"]["encounter"]>
    composites: {}
  }

  type EncounterGetPayload<S extends boolean | null | undefined | EncounterDefaultArgs> = $Result.GetResult<Prisma.$EncounterPayload, S>

  type EncounterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EncounterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EncounterCountAggregateInputType | true
    }

  export interface EncounterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Encounter'], meta: { name: 'Encounter' } }
    /**
     * Find zero or one Encounter that matches the filter.
     * @param {EncounterFindUniqueArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterFindUniqueArgs>(args: SelectSubset<T, EncounterFindUniqueArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Encounter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EncounterFindUniqueOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Encounter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterFindFirstArgs>(args?: SelectSubset<T, EncounterFindFirstArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Encounter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindFirstOrThrowArgs} args - Arguments to find a Encounter
     * @example
     * // Get one Encounter
     * const encounter = await prisma.encounter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Encounters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Encounters
     * const encounters = await prisma.encounter.findMany()
     * 
     * // Get first 10 Encounters
     * const encounters = await prisma.encounter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterWithIdOnly = await prisma.encounter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterFindManyArgs>(args?: SelectSubset<T, EncounterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Encounter.
     * @param {EncounterCreateArgs} args - Arguments to create a Encounter.
     * @example
     * // Create one Encounter
     * const Encounter = await prisma.encounter.create({
     *   data: {
     *     // ... data to create a Encounter
     *   }
     * })
     * 
     */
    create<T extends EncounterCreateArgs>(args: SelectSubset<T, EncounterCreateArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Encounters.
     * @param {EncounterCreateManyArgs} args - Arguments to create many Encounters.
     * @example
     * // Create many Encounters
     * const encounter = await prisma.encounter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterCreateManyArgs>(args?: SelectSubset<T, EncounterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Encounters and returns the data saved in the database.
     * @param {EncounterCreateManyAndReturnArgs} args - Arguments to create many Encounters.
     * @example
     * // Create many Encounters
     * const encounter = await prisma.encounter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Encounters and only return the `id`
     * const encounterWithIdOnly = await prisma.encounter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Encounter.
     * @param {EncounterDeleteArgs} args - Arguments to delete one Encounter.
     * @example
     * // Delete one Encounter
     * const Encounter = await prisma.encounter.delete({
     *   where: {
     *     // ... filter to delete one Encounter
     *   }
     * })
     * 
     */
    delete<T extends EncounterDeleteArgs>(args: SelectSubset<T, EncounterDeleteArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Encounter.
     * @param {EncounterUpdateArgs} args - Arguments to update one Encounter.
     * @example
     * // Update one Encounter
     * const encounter = await prisma.encounter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterUpdateArgs>(args: SelectSubset<T, EncounterUpdateArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Encounters.
     * @param {EncounterDeleteManyArgs} args - Arguments to filter Encounters to delete.
     * @example
     * // Delete a few Encounters
     * const { count } = await prisma.encounter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterDeleteManyArgs>(args?: SelectSubset<T, EncounterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Encounters
     * const encounter = await prisma.encounter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterUpdateManyArgs>(args: SelectSubset<T, EncounterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encounters and returns the data updated in the database.
     * @param {EncounterUpdateManyAndReturnArgs} args - Arguments to update many Encounters.
     * @example
     * // Update many Encounters
     * const encounter = await prisma.encounter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Encounters and only return the `id`
     * const encounterWithIdOnly = await prisma.encounter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EncounterUpdateManyAndReturnArgs>(args: SelectSubset<T, EncounterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Encounter.
     * @param {EncounterUpsertArgs} args - Arguments to update or create a Encounter.
     * @example
     * // Update or create a Encounter
     * const encounter = await prisma.encounter.upsert({
     *   create: {
     *     // ... data to create a Encounter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Encounter we want to update
     *   }
     * })
     */
    upsert<T extends EncounterUpsertArgs>(args: SelectSubset<T, EncounterUpsertArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Encounters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterCountArgs} args - Arguments to filter Encounters to count.
     * @example
     * // Count the number of Encounters
     * const count = await prisma.encounter.count({
     *   where: {
     *     // ... the filter for the Encounters we want to count
     *   }
     * })
    **/
    count<T extends EncounterCountArgs>(
      args?: Subset<T, EncounterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterAggregateArgs>(args: Subset<T, EncounterAggregateArgs>): Prisma.PrismaPromise<GetEncounterAggregateType<T>>

    /**
     * Group by Encounter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterGroupByArgs['orderBy'] }
        : { orderBy?: EncounterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Encounter model
   */
  readonly fields: EncounterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Encounter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    version<T extends VersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VersionDefaultArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemon<T extends PokemonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PokemonDefaultArgs<ExtArgs>>): Prisma__PokemonClient<$Result.GetResult<Prisma.$PokemonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location_area<T extends LocationAreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationAreaDefaultArgs<ExtArgs>>): Prisma__LocationAreaClient<$Result.GetResult<Prisma.$LocationAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    slot<T extends EncounterSlotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterSlotDefaultArgs<ExtArgs>>): Prisma__EncounterSlotClient<$Result.GetResult<Prisma.$EncounterSlotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conditions<T extends Encounter$conditionsArgs<ExtArgs> = {}>(args?: Subset<T, Encounter$conditionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterConditionValueMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Encounter model
   */
  interface EncounterFieldRefs {
    readonly id: FieldRef<"Encounter", 'Int'>
    readonly version_id: FieldRef<"Encounter", 'Int'>
    readonly pokemon_id: FieldRef<"Encounter", 'Int'>
    readonly location_area_id: FieldRef<"Encounter", 'Int'>
    readonly encounter_slot_id: FieldRef<"Encounter", 'Int'>
    readonly min_level: FieldRef<"Encounter", 'Int'>
    readonly max_level: FieldRef<"Encounter", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Encounter findUnique
   */
  export type EncounterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findUniqueOrThrow
   */
  export type EncounterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter findFirst
   */
  export type EncounterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findFirstOrThrow
   */
  export type EncounterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounter to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Encounters.
     */
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter findMany
   */
  export type EncounterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter, which Encounters to fetch.
     */
    where?: EncounterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Encounters to fetch.
     */
    orderBy?: EncounterOrderByWithRelationInput | EncounterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Encounters.
     */
    cursor?: EncounterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Encounters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Encounters.
     */
    skip?: number
    distinct?: EncounterScalarFieldEnum | EncounterScalarFieldEnum[]
  }

  /**
   * Encounter create
   */
  export type EncounterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to create a Encounter.
     */
    data: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
  }

  /**
   * Encounter createMany
   */
  export type EncounterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Encounters.
     */
    data: EncounterCreateManyInput | EncounterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Encounter createManyAndReturn
   */
  export type EncounterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * The data used to create many Encounters.
     */
    data: EncounterCreateManyInput | EncounterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Encounter update
   */
  export type EncounterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The data needed to update a Encounter.
     */
    data: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
    /**
     * Choose, which Encounter to update.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter updateMany
   */
  export type EncounterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Encounters.
     */
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyInput>
    /**
     * Filter which Encounters to update
     */
    where?: EncounterWhereInput
    /**
     * Limit how many Encounters to update.
     */
    limit?: number
  }

  /**
   * Encounter updateManyAndReturn
   */
  export type EncounterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * The data used to update Encounters.
     */
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyInput>
    /**
     * Filter which Encounters to update
     */
    where?: EncounterWhereInput
    /**
     * Limit how many Encounters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Encounter upsert
   */
  export type EncounterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * The filter to search for the Encounter to update in case it exists.
     */
    where: EncounterWhereUniqueInput
    /**
     * In case the Encounter found by the `where` argument doesn't exist, create a new Encounter with this data.
     */
    create: XOR<EncounterCreateInput, EncounterUncheckedCreateInput>
    /**
     * In case the Encounter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterUpdateInput, EncounterUncheckedUpdateInput>
  }

  /**
   * Encounter delete
   */
  export type EncounterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
    /**
     * Filter which Encounter to delete.
     */
    where: EncounterWhereUniqueInput
  }

  /**
   * Encounter deleteMany
   */
  export type EncounterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Encounters to delete
     */
    where?: EncounterWhereInput
    /**
     * Limit how many Encounters to delete.
     */
    limit?: number
  }

  /**
   * Encounter.conditions
   */
  export type Encounter$conditionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValueMap
     */
    select?: EncounterConditionValueMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValueMap
     */
    omit?: EncounterConditionValueMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueMapInclude<ExtArgs> | null
    where?: EncounterConditionValueMapWhereInput
    orderBy?: EncounterConditionValueMapOrderByWithRelationInput | EncounterConditionValueMapOrderByWithRelationInput[]
    cursor?: EncounterConditionValueMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterConditionValueMapScalarFieldEnum | EncounterConditionValueMapScalarFieldEnum[]
  }

  /**
   * Encounter without action
   */
  export type EncounterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Encounter
     */
    select?: EncounterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Encounter
     */
    omit?: EncounterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterInclude<ExtArgs> | null
  }


  /**
   * Model EncounterCondition
   */

  export type AggregateEncounterCondition = {
    _count: EncounterConditionCountAggregateOutputType | null
    _avg: EncounterConditionAvgAggregateOutputType | null
    _sum: EncounterConditionSumAggregateOutputType | null
    _min: EncounterConditionMinAggregateOutputType | null
    _max: EncounterConditionMaxAggregateOutputType | null
  }

  export type EncounterConditionAvgAggregateOutputType = {
    id: number | null
  }

  export type EncounterConditionSumAggregateOutputType = {
    id: number | null
  }

  export type EncounterConditionMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type EncounterConditionMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type EncounterConditionCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type EncounterConditionAvgAggregateInputType = {
    id?: true
  }

  export type EncounterConditionSumAggregateInputType = {
    id?: true
  }

  export type EncounterConditionMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type EncounterConditionMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type EncounterConditionCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type EncounterConditionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterCondition to aggregate.
     */
    where?: EncounterConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConditions to fetch.
     */
    orderBy?: EncounterConditionOrderByWithRelationInput | EncounterConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncounterConditions
    **/
    _count?: true | EncounterConditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncounterConditionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncounterConditionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterConditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterConditionMaxAggregateInputType
  }

  export type GetEncounterConditionAggregateType<T extends EncounterConditionAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounterCondition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounterCondition[P]>
      : GetScalarType<T[P], AggregateEncounterCondition[P]>
  }




  export type EncounterConditionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterConditionWhereInput
    orderBy?: EncounterConditionOrderByWithAggregationInput | EncounterConditionOrderByWithAggregationInput[]
    by: EncounterConditionScalarFieldEnum[] | EncounterConditionScalarFieldEnum
    having?: EncounterConditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterConditionCountAggregateInputType | true
    _avg?: EncounterConditionAvgAggregateInputType
    _sum?: EncounterConditionSumAggregateInputType
    _min?: EncounterConditionMinAggregateInputType
    _max?: EncounterConditionMaxAggregateInputType
  }

  export type EncounterConditionGroupByOutputType = {
    id: number
    name: string
    _count: EncounterConditionCountAggregateOutputType | null
    _avg: EncounterConditionAvgAggregateOutputType | null
    _sum: EncounterConditionSumAggregateOutputType | null
    _min: EncounterConditionMinAggregateOutputType | null
    _max: EncounterConditionMaxAggregateOutputType | null
  }

  type GetEncounterConditionGroupByPayload<T extends EncounterConditionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterConditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterConditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterConditionGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterConditionGroupByOutputType[P]>
        }
      >
    >


  export type EncounterConditionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    values?: boolean | EncounterCondition$valuesArgs<ExtArgs>
    _count?: boolean | EncounterConditionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterCondition"]>

  export type EncounterConditionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["encounterCondition"]>

  export type EncounterConditionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["encounterCondition"]>

  export type EncounterConditionSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type EncounterConditionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["encounterCondition"]>
  export type EncounterConditionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | EncounterCondition$valuesArgs<ExtArgs>
    _count?: boolean | EncounterConditionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EncounterConditionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EncounterConditionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EncounterConditionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncounterCondition"
    objects: {
      values: Prisma.$EncounterConditionValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["encounterCondition"]>
    composites: {}
  }

  type EncounterConditionGetPayload<S extends boolean | null | undefined | EncounterConditionDefaultArgs> = $Result.GetResult<Prisma.$EncounterConditionPayload, S>

  type EncounterConditionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EncounterConditionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EncounterConditionCountAggregateInputType | true
    }

  export interface EncounterConditionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncounterCondition'], meta: { name: 'EncounterCondition' } }
    /**
     * Find zero or one EncounterCondition that matches the filter.
     * @param {EncounterConditionFindUniqueArgs} args - Arguments to find a EncounterCondition
     * @example
     * // Get one EncounterCondition
     * const encounterCondition = await prisma.encounterCondition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterConditionFindUniqueArgs>(args: SelectSubset<T, EncounterConditionFindUniqueArgs<ExtArgs>>): Prisma__EncounterConditionClient<$Result.GetResult<Prisma.$EncounterConditionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EncounterCondition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EncounterConditionFindUniqueOrThrowArgs} args - Arguments to find a EncounterCondition
     * @example
     * // Get one EncounterCondition
     * const encounterCondition = await prisma.encounterCondition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterConditionFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterConditionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterConditionClient<$Result.GetResult<Prisma.$EncounterConditionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EncounterCondition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionFindFirstArgs} args - Arguments to find a EncounterCondition
     * @example
     * // Get one EncounterCondition
     * const encounterCondition = await prisma.encounterCondition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterConditionFindFirstArgs>(args?: SelectSubset<T, EncounterConditionFindFirstArgs<ExtArgs>>): Prisma__EncounterConditionClient<$Result.GetResult<Prisma.$EncounterConditionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EncounterCondition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionFindFirstOrThrowArgs} args - Arguments to find a EncounterCondition
     * @example
     * // Get one EncounterCondition
     * const encounterCondition = await prisma.encounterCondition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterConditionFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterConditionFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterConditionClient<$Result.GetResult<Prisma.$EncounterConditionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EncounterConditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncounterConditions
     * const encounterConditions = await prisma.encounterCondition.findMany()
     * 
     * // Get first 10 EncounterConditions
     * const encounterConditions = await prisma.encounterCondition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterConditionWithIdOnly = await prisma.encounterCondition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterConditionFindManyArgs>(args?: SelectSubset<T, EncounterConditionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterConditionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EncounterCondition.
     * @param {EncounterConditionCreateArgs} args - Arguments to create a EncounterCondition.
     * @example
     * // Create one EncounterCondition
     * const EncounterCondition = await prisma.encounterCondition.create({
     *   data: {
     *     // ... data to create a EncounterCondition
     *   }
     * })
     * 
     */
    create<T extends EncounterConditionCreateArgs>(args: SelectSubset<T, EncounterConditionCreateArgs<ExtArgs>>): Prisma__EncounterConditionClient<$Result.GetResult<Prisma.$EncounterConditionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EncounterConditions.
     * @param {EncounterConditionCreateManyArgs} args - Arguments to create many EncounterConditions.
     * @example
     * // Create many EncounterConditions
     * const encounterCondition = await prisma.encounterCondition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterConditionCreateManyArgs>(args?: SelectSubset<T, EncounterConditionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EncounterConditions and returns the data saved in the database.
     * @param {EncounterConditionCreateManyAndReturnArgs} args - Arguments to create many EncounterConditions.
     * @example
     * // Create many EncounterConditions
     * const encounterCondition = await prisma.encounterCondition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EncounterConditions and only return the `id`
     * const encounterConditionWithIdOnly = await prisma.encounterCondition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterConditionCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterConditionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterConditionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EncounterCondition.
     * @param {EncounterConditionDeleteArgs} args - Arguments to delete one EncounterCondition.
     * @example
     * // Delete one EncounterCondition
     * const EncounterCondition = await prisma.encounterCondition.delete({
     *   where: {
     *     // ... filter to delete one EncounterCondition
     *   }
     * })
     * 
     */
    delete<T extends EncounterConditionDeleteArgs>(args: SelectSubset<T, EncounterConditionDeleteArgs<ExtArgs>>): Prisma__EncounterConditionClient<$Result.GetResult<Prisma.$EncounterConditionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EncounterCondition.
     * @param {EncounterConditionUpdateArgs} args - Arguments to update one EncounterCondition.
     * @example
     * // Update one EncounterCondition
     * const encounterCondition = await prisma.encounterCondition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterConditionUpdateArgs>(args: SelectSubset<T, EncounterConditionUpdateArgs<ExtArgs>>): Prisma__EncounterConditionClient<$Result.GetResult<Prisma.$EncounterConditionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EncounterConditions.
     * @param {EncounterConditionDeleteManyArgs} args - Arguments to filter EncounterConditions to delete.
     * @example
     * // Delete a few EncounterConditions
     * const { count } = await prisma.encounterCondition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterConditionDeleteManyArgs>(args?: SelectSubset<T, EncounterConditionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncounterConditions
     * const encounterCondition = await prisma.encounterCondition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterConditionUpdateManyArgs>(args: SelectSubset<T, EncounterConditionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterConditions and returns the data updated in the database.
     * @param {EncounterConditionUpdateManyAndReturnArgs} args - Arguments to update many EncounterConditions.
     * @example
     * // Update many EncounterConditions
     * const encounterCondition = await prisma.encounterCondition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EncounterConditions and only return the `id`
     * const encounterConditionWithIdOnly = await prisma.encounterCondition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EncounterConditionUpdateManyAndReturnArgs>(args: SelectSubset<T, EncounterConditionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterConditionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EncounterCondition.
     * @param {EncounterConditionUpsertArgs} args - Arguments to update or create a EncounterCondition.
     * @example
     * // Update or create a EncounterCondition
     * const encounterCondition = await prisma.encounterCondition.upsert({
     *   create: {
     *     // ... data to create a EncounterCondition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncounterCondition we want to update
     *   }
     * })
     */
    upsert<T extends EncounterConditionUpsertArgs>(args: SelectSubset<T, EncounterConditionUpsertArgs<ExtArgs>>): Prisma__EncounterConditionClient<$Result.GetResult<Prisma.$EncounterConditionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EncounterConditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionCountArgs} args - Arguments to filter EncounterConditions to count.
     * @example
     * // Count the number of EncounterConditions
     * const count = await prisma.encounterCondition.count({
     *   where: {
     *     // ... the filter for the EncounterConditions we want to count
     *   }
     * })
    **/
    count<T extends EncounterConditionCountArgs>(
      args?: Subset<T, EncounterConditionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterConditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncounterCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterConditionAggregateArgs>(args: Subset<T, EncounterConditionAggregateArgs>): Prisma.PrismaPromise<GetEncounterConditionAggregateType<T>>

    /**
     * Group by EncounterCondition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterConditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterConditionGroupByArgs['orderBy'] }
        : { orderBy?: EncounterConditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterConditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterConditionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncounterCondition model
   */
  readonly fields: EncounterConditionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncounterCondition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterConditionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    values<T extends EncounterCondition$valuesArgs<ExtArgs> = {}>(args?: Subset<T, EncounterCondition$valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterConditionValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EncounterCondition model
   */
  interface EncounterConditionFieldRefs {
    readonly id: FieldRef<"EncounterCondition", 'Int'>
    readonly name: FieldRef<"EncounterCondition", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EncounterCondition findUnique
   */
  export type EncounterConditionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCondition
     */
    select?: EncounterConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterCondition
     */
    omit?: EncounterConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionInclude<ExtArgs> | null
    /**
     * Filter, which EncounterCondition to fetch.
     */
    where: EncounterConditionWhereUniqueInput
  }

  /**
   * EncounterCondition findUniqueOrThrow
   */
  export type EncounterConditionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCondition
     */
    select?: EncounterConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterCondition
     */
    omit?: EncounterConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionInclude<ExtArgs> | null
    /**
     * Filter, which EncounterCondition to fetch.
     */
    where: EncounterConditionWhereUniqueInput
  }

  /**
   * EncounterCondition findFirst
   */
  export type EncounterConditionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCondition
     */
    select?: EncounterConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterCondition
     */
    omit?: EncounterConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionInclude<ExtArgs> | null
    /**
     * Filter, which EncounterCondition to fetch.
     */
    where?: EncounterConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConditions to fetch.
     */
    orderBy?: EncounterConditionOrderByWithRelationInput | EncounterConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterConditions.
     */
    cursor?: EncounterConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterConditions.
     */
    distinct?: EncounterConditionScalarFieldEnum | EncounterConditionScalarFieldEnum[]
  }

  /**
   * EncounterCondition findFirstOrThrow
   */
  export type EncounterConditionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCondition
     */
    select?: EncounterConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterCondition
     */
    omit?: EncounterConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionInclude<ExtArgs> | null
    /**
     * Filter, which EncounterCondition to fetch.
     */
    where?: EncounterConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConditions to fetch.
     */
    orderBy?: EncounterConditionOrderByWithRelationInput | EncounterConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterConditions.
     */
    cursor?: EncounterConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterConditions.
     */
    distinct?: EncounterConditionScalarFieldEnum | EncounterConditionScalarFieldEnum[]
  }

  /**
   * EncounterCondition findMany
   */
  export type EncounterConditionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCondition
     */
    select?: EncounterConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterCondition
     */
    omit?: EncounterConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConditions to fetch.
     */
    where?: EncounterConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConditions to fetch.
     */
    orderBy?: EncounterConditionOrderByWithRelationInput | EncounterConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncounterConditions.
     */
    cursor?: EncounterConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConditions.
     */
    skip?: number
    distinct?: EncounterConditionScalarFieldEnum | EncounterConditionScalarFieldEnum[]
  }

  /**
   * EncounterCondition create
   */
  export type EncounterConditionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCondition
     */
    select?: EncounterConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterCondition
     */
    omit?: EncounterConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionInclude<ExtArgs> | null
    /**
     * The data needed to create a EncounterCondition.
     */
    data: XOR<EncounterConditionCreateInput, EncounterConditionUncheckedCreateInput>
  }

  /**
   * EncounterCondition createMany
   */
  export type EncounterConditionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncounterConditions.
     */
    data: EncounterConditionCreateManyInput | EncounterConditionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncounterCondition createManyAndReturn
   */
  export type EncounterConditionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCondition
     */
    select?: EncounterConditionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterCondition
     */
    omit?: EncounterConditionOmit<ExtArgs> | null
    /**
     * The data used to create many EncounterConditions.
     */
    data: EncounterConditionCreateManyInput | EncounterConditionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncounterCondition update
   */
  export type EncounterConditionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCondition
     */
    select?: EncounterConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterCondition
     */
    omit?: EncounterConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionInclude<ExtArgs> | null
    /**
     * The data needed to update a EncounterCondition.
     */
    data: XOR<EncounterConditionUpdateInput, EncounterConditionUncheckedUpdateInput>
    /**
     * Choose, which EncounterCondition to update.
     */
    where: EncounterConditionWhereUniqueInput
  }

  /**
   * EncounterCondition updateMany
   */
  export type EncounterConditionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncounterConditions.
     */
    data: XOR<EncounterConditionUpdateManyMutationInput, EncounterConditionUncheckedUpdateManyInput>
    /**
     * Filter which EncounterConditions to update
     */
    where?: EncounterConditionWhereInput
    /**
     * Limit how many EncounterConditions to update.
     */
    limit?: number
  }

  /**
   * EncounterCondition updateManyAndReturn
   */
  export type EncounterConditionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCondition
     */
    select?: EncounterConditionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterCondition
     */
    omit?: EncounterConditionOmit<ExtArgs> | null
    /**
     * The data used to update EncounterConditions.
     */
    data: XOR<EncounterConditionUpdateManyMutationInput, EncounterConditionUncheckedUpdateManyInput>
    /**
     * Filter which EncounterConditions to update
     */
    where?: EncounterConditionWhereInput
    /**
     * Limit how many EncounterConditions to update.
     */
    limit?: number
  }

  /**
   * EncounterCondition upsert
   */
  export type EncounterConditionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCondition
     */
    select?: EncounterConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterCondition
     */
    omit?: EncounterConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionInclude<ExtArgs> | null
    /**
     * The filter to search for the EncounterCondition to update in case it exists.
     */
    where: EncounterConditionWhereUniqueInput
    /**
     * In case the EncounterCondition found by the `where` argument doesn't exist, create a new EncounterCondition with this data.
     */
    create: XOR<EncounterConditionCreateInput, EncounterConditionUncheckedCreateInput>
    /**
     * In case the EncounterCondition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterConditionUpdateInput, EncounterConditionUncheckedUpdateInput>
  }

  /**
   * EncounterCondition delete
   */
  export type EncounterConditionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCondition
     */
    select?: EncounterConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterCondition
     */
    omit?: EncounterConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionInclude<ExtArgs> | null
    /**
     * Filter which EncounterCondition to delete.
     */
    where: EncounterConditionWhereUniqueInput
  }

  /**
   * EncounterCondition deleteMany
   */
  export type EncounterConditionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterConditions to delete
     */
    where?: EncounterConditionWhereInput
    /**
     * Limit how many EncounterConditions to delete.
     */
    limit?: number
  }

  /**
   * EncounterCondition.values
   */
  export type EncounterCondition$valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValue
     */
    select?: EncounterConditionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValue
     */
    omit?: EncounterConditionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueInclude<ExtArgs> | null
    where?: EncounterConditionValueWhereInput
    orderBy?: EncounterConditionValueOrderByWithRelationInput | EncounterConditionValueOrderByWithRelationInput[]
    cursor?: EncounterConditionValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterConditionValueScalarFieldEnum | EncounterConditionValueScalarFieldEnum[]
  }

  /**
   * EncounterCondition without action
   */
  export type EncounterConditionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterCondition
     */
    select?: EncounterConditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterCondition
     */
    omit?: EncounterConditionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionInclude<ExtArgs> | null
  }


  /**
   * Model EncounterConditionValue
   */

  export type AggregateEncounterConditionValue = {
    _count: EncounterConditionValueCountAggregateOutputType | null
    _avg: EncounterConditionValueAvgAggregateOutputType | null
    _sum: EncounterConditionValueSumAggregateOutputType | null
    _min: EncounterConditionValueMinAggregateOutputType | null
    _max: EncounterConditionValueMaxAggregateOutputType | null
  }

  export type EncounterConditionValueAvgAggregateOutputType = {
    id: number | null
    encounter_condition_id: number | null
  }

  export type EncounterConditionValueSumAggregateOutputType = {
    id: number | null
    encounter_condition_id: number | null
  }

  export type EncounterConditionValueMinAggregateOutputType = {
    id: number | null
    encounter_condition_id: number | null
    name: string | null
    is_default: boolean | null
  }

  export type EncounterConditionValueMaxAggregateOutputType = {
    id: number | null
    encounter_condition_id: number | null
    name: string | null
    is_default: boolean | null
  }

  export type EncounterConditionValueCountAggregateOutputType = {
    id: number
    encounter_condition_id: number
    name: number
    is_default: number
    _all: number
  }


  export type EncounterConditionValueAvgAggregateInputType = {
    id?: true
    encounter_condition_id?: true
  }

  export type EncounterConditionValueSumAggregateInputType = {
    id?: true
    encounter_condition_id?: true
  }

  export type EncounterConditionValueMinAggregateInputType = {
    id?: true
    encounter_condition_id?: true
    name?: true
    is_default?: true
  }

  export type EncounterConditionValueMaxAggregateInputType = {
    id?: true
    encounter_condition_id?: true
    name?: true
    is_default?: true
  }

  export type EncounterConditionValueCountAggregateInputType = {
    id?: true
    encounter_condition_id?: true
    name?: true
    is_default?: true
    _all?: true
  }

  export type EncounterConditionValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterConditionValue to aggregate.
     */
    where?: EncounterConditionValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConditionValues to fetch.
     */
    orderBy?: EncounterConditionValueOrderByWithRelationInput | EncounterConditionValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterConditionValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConditionValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConditionValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncounterConditionValues
    **/
    _count?: true | EncounterConditionValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncounterConditionValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncounterConditionValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterConditionValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterConditionValueMaxAggregateInputType
  }

  export type GetEncounterConditionValueAggregateType<T extends EncounterConditionValueAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounterConditionValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounterConditionValue[P]>
      : GetScalarType<T[P], AggregateEncounterConditionValue[P]>
  }




  export type EncounterConditionValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterConditionValueWhereInput
    orderBy?: EncounterConditionValueOrderByWithAggregationInput | EncounterConditionValueOrderByWithAggregationInput[]
    by: EncounterConditionValueScalarFieldEnum[] | EncounterConditionValueScalarFieldEnum
    having?: EncounterConditionValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterConditionValueCountAggregateInputType | true
    _avg?: EncounterConditionValueAvgAggregateInputType
    _sum?: EncounterConditionValueSumAggregateInputType
    _min?: EncounterConditionValueMinAggregateInputType
    _max?: EncounterConditionValueMaxAggregateInputType
  }

  export type EncounterConditionValueGroupByOutputType = {
    id: number
    encounter_condition_id: number
    name: string
    is_default: boolean
    _count: EncounterConditionValueCountAggregateOutputType | null
    _avg: EncounterConditionValueAvgAggregateOutputType | null
    _sum: EncounterConditionValueSumAggregateOutputType | null
    _min: EncounterConditionValueMinAggregateOutputType | null
    _max: EncounterConditionValueMaxAggregateOutputType | null
  }

  type GetEncounterConditionValueGroupByPayload<T extends EncounterConditionValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterConditionValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterConditionValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterConditionValueGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterConditionValueGroupByOutputType[P]>
        }
      >
    >


  export type EncounterConditionValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounter_condition_id?: boolean
    name?: boolean
    is_default?: boolean
    condition?: boolean | EncounterConditionDefaultArgs<ExtArgs>
    maps?: boolean | EncounterConditionValue$mapsArgs<ExtArgs>
    _count?: boolean | EncounterConditionValueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterConditionValue"]>

  export type EncounterConditionValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounter_condition_id?: boolean
    name?: boolean
    is_default?: boolean
    condition?: boolean | EncounterConditionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterConditionValue"]>

  export type EncounterConditionValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounter_condition_id?: boolean
    name?: boolean
    is_default?: boolean
    condition?: boolean | EncounterConditionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterConditionValue"]>

  export type EncounterConditionValueSelectScalar = {
    id?: boolean
    encounter_condition_id?: boolean
    name?: boolean
    is_default?: boolean
  }

  export type EncounterConditionValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "encounter_condition_id" | "name" | "is_default", ExtArgs["result"]["encounterConditionValue"]>
  export type EncounterConditionValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    condition?: boolean | EncounterConditionDefaultArgs<ExtArgs>
    maps?: boolean | EncounterConditionValue$mapsArgs<ExtArgs>
    _count?: boolean | EncounterConditionValueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EncounterConditionValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    condition?: boolean | EncounterConditionDefaultArgs<ExtArgs>
  }
  export type EncounterConditionValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    condition?: boolean | EncounterConditionDefaultArgs<ExtArgs>
  }

  export type $EncounterConditionValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncounterConditionValue"
    objects: {
      condition: Prisma.$EncounterConditionPayload<ExtArgs>
      maps: Prisma.$EncounterConditionValueMapPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      encounter_condition_id: number
      name: string
      is_default: boolean
    }, ExtArgs["result"]["encounterConditionValue"]>
    composites: {}
  }

  type EncounterConditionValueGetPayload<S extends boolean | null | undefined | EncounterConditionValueDefaultArgs> = $Result.GetResult<Prisma.$EncounterConditionValuePayload, S>

  type EncounterConditionValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EncounterConditionValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EncounterConditionValueCountAggregateInputType | true
    }

  export interface EncounterConditionValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncounterConditionValue'], meta: { name: 'EncounterConditionValue' } }
    /**
     * Find zero or one EncounterConditionValue that matches the filter.
     * @param {EncounterConditionValueFindUniqueArgs} args - Arguments to find a EncounterConditionValue
     * @example
     * // Get one EncounterConditionValue
     * const encounterConditionValue = await prisma.encounterConditionValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterConditionValueFindUniqueArgs>(args: SelectSubset<T, EncounterConditionValueFindUniqueArgs<ExtArgs>>): Prisma__EncounterConditionValueClient<$Result.GetResult<Prisma.$EncounterConditionValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EncounterConditionValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EncounterConditionValueFindUniqueOrThrowArgs} args - Arguments to find a EncounterConditionValue
     * @example
     * // Get one EncounterConditionValue
     * const encounterConditionValue = await prisma.encounterConditionValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterConditionValueFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterConditionValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterConditionValueClient<$Result.GetResult<Prisma.$EncounterConditionValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EncounterConditionValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionValueFindFirstArgs} args - Arguments to find a EncounterConditionValue
     * @example
     * // Get one EncounterConditionValue
     * const encounterConditionValue = await prisma.encounterConditionValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterConditionValueFindFirstArgs>(args?: SelectSubset<T, EncounterConditionValueFindFirstArgs<ExtArgs>>): Prisma__EncounterConditionValueClient<$Result.GetResult<Prisma.$EncounterConditionValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EncounterConditionValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionValueFindFirstOrThrowArgs} args - Arguments to find a EncounterConditionValue
     * @example
     * // Get one EncounterConditionValue
     * const encounterConditionValue = await prisma.encounterConditionValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterConditionValueFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterConditionValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterConditionValueClient<$Result.GetResult<Prisma.$EncounterConditionValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EncounterConditionValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncounterConditionValues
     * const encounterConditionValues = await prisma.encounterConditionValue.findMany()
     * 
     * // Get first 10 EncounterConditionValues
     * const encounterConditionValues = await prisma.encounterConditionValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterConditionValueWithIdOnly = await prisma.encounterConditionValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterConditionValueFindManyArgs>(args?: SelectSubset<T, EncounterConditionValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterConditionValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EncounterConditionValue.
     * @param {EncounterConditionValueCreateArgs} args - Arguments to create a EncounterConditionValue.
     * @example
     * // Create one EncounterConditionValue
     * const EncounterConditionValue = await prisma.encounterConditionValue.create({
     *   data: {
     *     // ... data to create a EncounterConditionValue
     *   }
     * })
     * 
     */
    create<T extends EncounterConditionValueCreateArgs>(args: SelectSubset<T, EncounterConditionValueCreateArgs<ExtArgs>>): Prisma__EncounterConditionValueClient<$Result.GetResult<Prisma.$EncounterConditionValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EncounterConditionValues.
     * @param {EncounterConditionValueCreateManyArgs} args - Arguments to create many EncounterConditionValues.
     * @example
     * // Create many EncounterConditionValues
     * const encounterConditionValue = await prisma.encounterConditionValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterConditionValueCreateManyArgs>(args?: SelectSubset<T, EncounterConditionValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EncounterConditionValues and returns the data saved in the database.
     * @param {EncounterConditionValueCreateManyAndReturnArgs} args - Arguments to create many EncounterConditionValues.
     * @example
     * // Create many EncounterConditionValues
     * const encounterConditionValue = await prisma.encounterConditionValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EncounterConditionValues and only return the `id`
     * const encounterConditionValueWithIdOnly = await prisma.encounterConditionValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterConditionValueCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterConditionValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterConditionValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EncounterConditionValue.
     * @param {EncounterConditionValueDeleteArgs} args - Arguments to delete one EncounterConditionValue.
     * @example
     * // Delete one EncounterConditionValue
     * const EncounterConditionValue = await prisma.encounterConditionValue.delete({
     *   where: {
     *     // ... filter to delete one EncounterConditionValue
     *   }
     * })
     * 
     */
    delete<T extends EncounterConditionValueDeleteArgs>(args: SelectSubset<T, EncounterConditionValueDeleteArgs<ExtArgs>>): Prisma__EncounterConditionValueClient<$Result.GetResult<Prisma.$EncounterConditionValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EncounterConditionValue.
     * @param {EncounterConditionValueUpdateArgs} args - Arguments to update one EncounterConditionValue.
     * @example
     * // Update one EncounterConditionValue
     * const encounterConditionValue = await prisma.encounterConditionValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterConditionValueUpdateArgs>(args: SelectSubset<T, EncounterConditionValueUpdateArgs<ExtArgs>>): Prisma__EncounterConditionValueClient<$Result.GetResult<Prisma.$EncounterConditionValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EncounterConditionValues.
     * @param {EncounterConditionValueDeleteManyArgs} args - Arguments to filter EncounterConditionValues to delete.
     * @example
     * // Delete a few EncounterConditionValues
     * const { count } = await prisma.encounterConditionValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterConditionValueDeleteManyArgs>(args?: SelectSubset<T, EncounterConditionValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterConditionValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncounterConditionValues
     * const encounterConditionValue = await prisma.encounterConditionValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterConditionValueUpdateManyArgs>(args: SelectSubset<T, EncounterConditionValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterConditionValues and returns the data updated in the database.
     * @param {EncounterConditionValueUpdateManyAndReturnArgs} args - Arguments to update many EncounterConditionValues.
     * @example
     * // Update many EncounterConditionValues
     * const encounterConditionValue = await prisma.encounterConditionValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EncounterConditionValues and only return the `id`
     * const encounterConditionValueWithIdOnly = await prisma.encounterConditionValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EncounterConditionValueUpdateManyAndReturnArgs>(args: SelectSubset<T, EncounterConditionValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterConditionValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EncounterConditionValue.
     * @param {EncounterConditionValueUpsertArgs} args - Arguments to update or create a EncounterConditionValue.
     * @example
     * // Update or create a EncounterConditionValue
     * const encounterConditionValue = await prisma.encounterConditionValue.upsert({
     *   create: {
     *     // ... data to create a EncounterConditionValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncounterConditionValue we want to update
     *   }
     * })
     */
    upsert<T extends EncounterConditionValueUpsertArgs>(args: SelectSubset<T, EncounterConditionValueUpsertArgs<ExtArgs>>): Prisma__EncounterConditionValueClient<$Result.GetResult<Prisma.$EncounterConditionValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EncounterConditionValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionValueCountArgs} args - Arguments to filter EncounterConditionValues to count.
     * @example
     * // Count the number of EncounterConditionValues
     * const count = await prisma.encounterConditionValue.count({
     *   where: {
     *     // ... the filter for the EncounterConditionValues we want to count
     *   }
     * })
    **/
    count<T extends EncounterConditionValueCountArgs>(
      args?: Subset<T, EncounterConditionValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterConditionValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncounterConditionValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterConditionValueAggregateArgs>(args: Subset<T, EncounterConditionValueAggregateArgs>): Prisma.PrismaPromise<GetEncounterConditionValueAggregateType<T>>

    /**
     * Group by EncounterConditionValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterConditionValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterConditionValueGroupByArgs['orderBy'] }
        : { orderBy?: EncounterConditionValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterConditionValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterConditionValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncounterConditionValue model
   */
  readonly fields: EncounterConditionValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncounterConditionValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterConditionValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    condition<T extends EncounterConditionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterConditionDefaultArgs<ExtArgs>>): Prisma__EncounterConditionClient<$Result.GetResult<Prisma.$EncounterConditionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    maps<T extends EncounterConditionValue$mapsArgs<ExtArgs> = {}>(args?: Subset<T, EncounterConditionValue$mapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterConditionValueMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EncounterConditionValue model
   */
  interface EncounterConditionValueFieldRefs {
    readonly id: FieldRef<"EncounterConditionValue", 'Int'>
    readonly encounter_condition_id: FieldRef<"EncounterConditionValue", 'Int'>
    readonly name: FieldRef<"EncounterConditionValue", 'String'>
    readonly is_default: FieldRef<"EncounterConditionValue", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * EncounterConditionValue findUnique
   */
  export type EncounterConditionValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValue
     */
    select?: EncounterConditionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValue
     */
    omit?: EncounterConditionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConditionValue to fetch.
     */
    where: EncounterConditionValueWhereUniqueInput
  }

  /**
   * EncounterConditionValue findUniqueOrThrow
   */
  export type EncounterConditionValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValue
     */
    select?: EncounterConditionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValue
     */
    omit?: EncounterConditionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConditionValue to fetch.
     */
    where: EncounterConditionValueWhereUniqueInput
  }

  /**
   * EncounterConditionValue findFirst
   */
  export type EncounterConditionValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValue
     */
    select?: EncounterConditionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValue
     */
    omit?: EncounterConditionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConditionValue to fetch.
     */
    where?: EncounterConditionValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConditionValues to fetch.
     */
    orderBy?: EncounterConditionValueOrderByWithRelationInput | EncounterConditionValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterConditionValues.
     */
    cursor?: EncounterConditionValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConditionValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConditionValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterConditionValues.
     */
    distinct?: EncounterConditionValueScalarFieldEnum | EncounterConditionValueScalarFieldEnum[]
  }

  /**
   * EncounterConditionValue findFirstOrThrow
   */
  export type EncounterConditionValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValue
     */
    select?: EncounterConditionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValue
     */
    omit?: EncounterConditionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConditionValue to fetch.
     */
    where?: EncounterConditionValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConditionValues to fetch.
     */
    orderBy?: EncounterConditionValueOrderByWithRelationInput | EncounterConditionValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterConditionValues.
     */
    cursor?: EncounterConditionValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConditionValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConditionValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterConditionValues.
     */
    distinct?: EncounterConditionValueScalarFieldEnum | EncounterConditionValueScalarFieldEnum[]
  }

  /**
   * EncounterConditionValue findMany
   */
  export type EncounterConditionValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValue
     */
    select?: EncounterConditionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValue
     */
    omit?: EncounterConditionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConditionValues to fetch.
     */
    where?: EncounterConditionValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConditionValues to fetch.
     */
    orderBy?: EncounterConditionValueOrderByWithRelationInput | EncounterConditionValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncounterConditionValues.
     */
    cursor?: EncounterConditionValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConditionValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConditionValues.
     */
    skip?: number
    distinct?: EncounterConditionValueScalarFieldEnum | EncounterConditionValueScalarFieldEnum[]
  }

  /**
   * EncounterConditionValue create
   */
  export type EncounterConditionValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValue
     */
    select?: EncounterConditionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValue
     */
    omit?: EncounterConditionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueInclude<ExtArgs> | null
    /**
     * The data needed to create a EncounterConditionValue.
     */
    data: XOR<EncounterConditionValueCreateInput, EncounterConditionValueUncheckedCreateInput>
  }

  /**
   * EncounterConditionValue createMany
   */
  export type EncounterConditionValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncounterConditionValues.
     */
    data: EncounterConditionValueCreateManyInput | EncounterConditionValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncounterConditionValue createManyAndReturn
   */
  export type EncounterConditionValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValue
     */
    select?: EncounterConditionValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValue
     */
    omit?: EncounterConditionValueOmit<ExtArgs> | null
    /**
     * The data used to create many EncounterConditionValues.
     */
    data: EncounterConditionValueCreateManyInput | EncounterConditionValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EncounterConditionValue update
   */
  export type EncounterConditionValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValue
     */
    select?: EncounterConditionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValue
     */
    omit?: EncounterConditionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueInclude<ExtArgs> | null
    /**
     * The data needed to update a EncounterConditionValue.
     */
    data: XOR<EncounterConditionValueUpdateInput, EncounterConditionValueUncheckedUpdateInput>
    /**
     * Choose, which EncounterConditionValue to update.
     */
    where: EncounterConditionValueWhereUniqueInput
  }

  /**
   * EncounterConditionValue updateMany
   */
  export type EncounterConditionValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncounterConditionValues.
     */
    data: XOR<EncounterConditionValueUpdateManyMutationInput, EncounterConditionValueUncheckedUpdateManyInput>
    /**
     * Filter which EncounterConditionValues to update
     */
    where?: EncounterConditionValueWhereInput
    /**
     * Limit how many EncounterConditionValues to update.
     */
    limit?: number
  }

  /**
   * EncounterConditionValue updateManyAndReturn
   */
  export type EncounterConditionValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValue
     */
    select?: EncounterConditionValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValue
     */
    omit?: EncounterConditionValueOmit<ExtArgs> | null
    /**
     * The data used to update EncounterConditionValues.
     */
    data: XOR<EncounterConditionValueUpdateManyMutationInput, EncounterConditionValueUncheckedUpdateManyInput>
    /**
     * Filter which EncounterConditionValues to update
     */
    where?: EncounterConditionValueWhereInput
    /**
     * Limit how many EncounterConditionValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EncounterConditionValue upsert
   */
  export type EncounterConditionValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValue
     */
    select?: EncounterConditionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValue
     */
    omit?: EncounterConditionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueInclude<ExtArgs> | null
    /**
     * The filter to search for the EncounterConditionValue to update in case it exists.
     */
    where: EncounterConditionValueWhereUniqueInput
    /**
     * In case the EncounterConditionValue found by the `where` argument doesn't exist, create a new EncounterConditionValue with this data.
     */
    create: XOR<EncounterConditionValueCreateInput, EncounterConditionValueUncheckedCreateInput>
    /**
     * In case the EncounterConditionValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterConditionValueUpdateInput, EncounterConditionValueUncheckedUpdateInput>
  }

  /**
   * EncounterConditionValue delete
   */
  export type EncounterConditionValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValue
     */
    select?: EncounterConditionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValue
     */
    omit?: EncounterConditionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueInclude<ExtArgs> | null
    /**
     * Filter which EncounterConditionValue to delete.
     */
    where: EncounterConditionValueWhereUniqueInput
  }

  /**
   * EncounterConditionValue deleteMany
   */
  export type EncounterConditionValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterConditionValues to delete
     */
    where?: EncounterConditionValueWhereInput
    /**
     * Limit how many EncounterConditionValues to delete.
     */
    limit?: number
  }

  /**
   * EncounterConditionValue.maps
   */
  export type EncounterConditionValue$mapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValueMap
     */
    select?: EncounterConditionValueMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValueMap
     */
    omit?: EncounterConditionValueMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueMapInclude<ExtArgs> | null
    where?: EncounterConditionValueMapWhereInput
    orderBy?: EncounterConditionValueMapOrderByWithRelationInput | EncounterConditionValueMapOrderByWithRelationInput[]
    cursor?: EncounterConditionValueMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncounterConditionValueMapScalarFieldEnum | EncounterConditionValueMapScalarFieldEnum[]
  }

  /**
   * EncounterConditionValue without action
   */
  export type EncounterConditionValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValue
     */
    select?: EncounterConditionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValue
     */
    omit?: EncounterConditionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueInclude<ExtArgs> | null
  }


  /**
   * Model EncounterConditionValueMap
   */

  export type AggregateEncounterConditionValueMap = {
    _count: EncounterConditionValueMapCountAggregateOutputType | null
    _avg: EncounterConditionValueMapAvgAggregateOutputType | null
    _sum: EncounterConditionValueMapSumAggregateOutputType | null
    _min: EncounterConditionValueMapMinAggregateOutputType | null
    _max: EncounterConditionValueMapMaxAggregateOutputType | null
  }

  export type EncounterConditionValueMapAvgAggregateOutputType = {
    id: number | null
    encounter_id: number | null
    encounter_condition_value_id: number | null
  }

  export type EncounterConditionValueMapSumAggregateOutputType = {
    id: number | null
    encounter_id: number | null
    encounter_condition_value_id: number | null
  }

  export type EncounterConditionValueMapMinAggregateOutputType = {
    id: number | null
    encounter_id: number | null
    encounter_condition_value_id: number | null
  }

  export type EncounterConditionValueMapMaxAggregateOutputType = {
    id: number | null
    encounter_id: number | null
    encounter_condition_value_id: number | null
  }

  export type EncounterConditionValueMapCountAggregateOutputType = {
    id: number
    encounter_id: number
    encounter_condition_value_id: number
    _all: number
  }


  export type EncounterConditionValueMapAvgAggregateInputType = {
    id?: true
    encounter_id?: true
    encounter_condition_value_id?: true
  }

  export type EncounterConditionValueMapSumAggregateInputType = {
    id?: true
    encounter_id?: true
    encounter_condition_value_id?: true
  }

  export type EncounterConditionValueMapMinAggregateInputType = {
    id?: true
    encounter_id?: true
    encounter_condition_value_id?: true
  }

  export type EncounterConditionValueMapMaxAggregateInputType = {
    id?: true
    encounter_id?: true
    encounter_condition_value_id?: true
  }

  export type EncounterConditionValueMapCountAggregateInputType = {
    id?: true
    encounter_id?: true
    encounter_condition_value_id?: true
    _all?: true
  }

  export type EncounterConditionValueMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterConditionValueMap to aggregate.
     */
    where?: EncounterConditionValueMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConditionValueMaps to fetch.
     */
    orderBy?: EncounterConditionValueMapOrderByWithRelationInput | EncounterConditionValueMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncounterConditionValueMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConditionValueMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConditionValueMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncounterConditionValueMaps
    **/
    _count?: true | EncounterConditionValueMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncounterConditionValueMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncounterConditionValueMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncounterConditionValueMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncounterConditionValueMapMaxAggregateInputType
  }

  export type GetEncounterConditionValueMapAggregateType<T extends EncounterConditionValueMapAggregateArgs> = {
        [P in keyof T & keyof AggregateEncounterConditionValueMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncounterConditionValueMap[P]>
      : GetScalarType<T[P], AggregateEncounterConditionValueMap[P]>
  }




  export type EncounterConditionValueMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncounterConditionValueMapWhereInput
    orderBy?: EncounterConditionValueMapOrderByWithAggregationInput | EncounterConditionValueMapOrderByWithAggregationInput[]
    by: EncounterConditionValueMapScalarFieldEnum[] | EncounterConditionValueMapScalarFieldEnum
    having?: EncounterConditionValueMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncounterConditionValueMapCountAggregateInputType | true
    _avg?: EncounterConditionValueMapAvgAggregateInputType
    _sum?: EncounterConditionValueMapSumAggregateInputType
    _min?: EncounterConditionValueMapMinAggregateInputType
    _max?: EncounterConditionValueMapMaxAggregateInputType
  }

  export type EncounterConditionValueMapGroupByOutputType = {
    id: number
    encounter_id: number
    encounter_condition_value_id: number
    _count: EncounterConditionValueMapCountAggregateOutputType | null
    _avg: EncounterConditionValueMapAvgAggregateOutputType | null
    _sum: EncounterConditionValueMapSumAggregateOutputType | null
    _min: EncounterConditionValueMapMinAggregateOutputType | null
    _max: EncounterConditionValueMapMaxAggregateOutputType | null
  }

  type GetEncounterConditionValueMapGroupByPayload<T extends EncounterConditionValueMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncounterConditionValueMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncounterConditionValueMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncounterConditionValueMapGroupByOutputType[P]>
            : GetScalarType<T[P], EncounterConditionValueMapGroupByOutputType[P]>
        }
      >
    >


  export type EncounterConditionValueMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounter_id?: boolean
    encounter_condition_value_id?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    value?: boolean | EncounterConditionValueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterConditionValueMap"]>

  export type EncounterConditionValueMapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounter_id?: boolean
    encounter_condition_value_id?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    value?: boolean | EncounterConditionValueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterConditionValueMap"]>

  export type EncounterConditionValueMapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    encounter_id?: boolean
    encounter_condition_value_id?: boolean
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    value?: boolean | EncounterConditionValueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encounterConditionValueMap"]>

  export type EncounterConditionValueMapSelectScalar = {
    id?: boolean
    encounter_id?: boolean
    encounter_condition_value_id?: boolean
  }

  export type EncounterConditionValueMapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "encounter_id" | "encounter_condition_value_id", ExtArgs["result"]["encounterConditionValueMap"]>
  export type EncounterConditionValueMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    value?: boolean | EncounterConditionValueDefaultArgs<ExtArgs>
  }
  export type EncounterConditionValueMapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    value?: boolean | EncounterConditionValueDefaultArgs<ExtArgs>
  }
  export type EncounterConditionValueMapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    encounter?: boolean | EncounterDefaultArgs<ExtArgs>
    value?: boolean | EncounterConditionValueDefaultArgs<ExtArgs>
  }

  export type $EncounterConditionValueMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncounterConditionValueMap"
    objects: {
      encounter: Prisma.$EncounterPayload<ExtArgs>
      value: Prisma.$EncounterConditionValuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      encounter_id: number
      encounter_condition_value_id: number
    }, ExtArgs["result"]["encounterConditionValueMap"]>
    composites: {}
  }

  type EncounterConditionValueMapGetPayload<S extends boolean | null | undefined | EncounterConditionValueMapDefaultArgs> = $Result.GetResult<Prisma.$EncounterConditionValueMapPayload, S>

  type EncounterConditionValueMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EncounterConditionValueMapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EncounterConditionValueMapCountAggregateInputType | true
    }

  export interface EncounterConditionValueMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncounterConditionValueMap'], meta: { name: 'EncounterConditionValueMap' } }
    /**
     * Find zero or one EncounterConditionValueMap that matches the filter.
     * @param {EncounterConditionValueMapFindUniqueArgs} args - Arguments to find a EncounterConditionValueMap
     * @example
     * // Get one EncounterConditionValueMap
     * const encounterConditionValueMap = await prisma.encounterConditionValueMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncounterConditionValueMapFindUniqueArgs>(args: SelectSubset<T, EncounterConditionValueMapFindUniqueArgs<ExtArgs>>): Prisma__EncounterConditionValueMapClient<$Result.GetResult<Prisma.$EncounterConditionValueMapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EncounterConditionValueMap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EncounterConditionValueMapFindUniqueOrThrowArgs} args - Arguments to find a EncounterConditionValueMap
     * @example
     * // Get one EncounterConditionValueMap
     * const encounterConditionValueMap = await prisma.encounterConditionValueMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncounterConditionValueMapFindUniqueOrThrowArgs>(args: SelectSubset<T, EncounterConditionValueMapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncounterConditionValueMapClient<$Result.GetResult<Prisma.$EncounterConditionValueMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EncounterConditionValueMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionValueMapFindFirstArgs} args - Arguments to find a EncounterConditionValueMap
     * @example
     * // Get one EncounterConditionValueMap
     * const encounterConditionValueMap = await prisma.encounterConditionValueMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncounterConditionValueMapFindFirstArgs>(args?: SelectSubset<T, EncounterConditionValueMapFindFirstArgs<ExtArgs>>): Prisma__EncounterConditionValueMapClient<$Result.GetResult<Prisma.$EncounterConditionValueMapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EncounterConditionValueMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionValueMapFindFirstOrThrowArgs} args - Arguments to find a EncounterConditionValueMap
     * @example
     * // Get one EncounterConditionValueMap
     * const encounterConditionValueMap = await prisma.encounterConditionValueMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncounterConditionValueMapFindFirstOrThrowArgs>(args?: SelectSubset<T, EncounterConditionValueMapFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncounterConditionValueMapClient<$Result.GetResult<Prisma.$EncounterConditionValueMapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EncounterConditionValueMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionValueMapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncounterConditionValueMaps
     * const encounterConditionValueMaps = await prisma.encounterConditionValueMap.findMany()
     * 
     * // Get first 10 EncounterConditionValueMaps
     * const encounterConditionValueMaps = await prisma.encounterConditionValueMap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encounterConditionValueMapWithIdOnly = await prisma.encounterConditionValueMap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncounterConditionValueMapFindManyArgs>(args?: SelectSubset<T, EncounterConditionValueMapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterConditionValueMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EncounterConditionValueMap.
     * @param {EncounterConditionValueMapCreateArgs} args - Arguments to create a EncounterConditionValueMap.
     * @example
     * // Create one EncounterConditionValueMap
     * const EncounterConditionValueMap = await prisma.encounterConditionValueMap.create({
     *   data: {
     *     // ... data to create a EncounterConditionValueMap
     *   }
     * })
     * 
     */
    create<T extends EncounterConditionValueMapCreateArgs>(args: SelectSubset<T, EncounterConditionValueMapCreateArgs<ExtArgs>>): Prisma__EncounterConditionValueMapClient<$Result.GetResult<Prisma.$EncounterConditionValueMapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EncounterConditionValueMaps.
     * @param {EncounterConditionValueMapCreateManyArgs} args - Arguments to create many EncounterConditionValueMaps.
     * @example
     * // Create many EncounterConditionValueMaps
     * const encounterConditionValueMap = await prisma.encounterConditionValueMap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncounterConditionValueMapCreateManyArgs>(args?: SelectSubset<T, EncounterConditionValueMapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EncounterConditionValueMaps and returns the data saved in the database.
     * @param {EncounterConditionValueMapCreateManyAndReturnArgs} args - Arguments to create many EncounterConditionValueMaps.
     * @example
     * // Create many EncounterConditionValueMaps
     * const encounterConditionValueMap = await prisma.encounterConditionValueMap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EncounterConditionValueMaps and only return the `id`
     * const encounterConditionValueMapWithIdOnly = await prisma.encounterConditionValueMap.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncounterConditionValueMapCreateManyAndReturnArgs>(args?: SelectSubset<T, EncounterConditionValueMapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterConditionValueMapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EncounterConditionValueMap.
     * @param {EncounterConditionValueMapDeleteArgs} args - Arguments to delete one EncounterConditionValueMap.
     * @example
     * // Delete one EncounterConditionValueMap
     * const EncounterConditionValueMap = await prisma.encounterConditionValueMap.delete({
     *   where: {
     *     // ... filter to delete one EncounterConditionValueMap
     *   }
     * })
     * 
     */
    delete<T extends EncounterConditionValueMapDeleteArgs>(args: SelectSubset<T, EncounterConditionValueMapDeleteArgs<ExtArgs>>): Prisma__EncounterConditionValueMapClient<$Result.GetResult<Prisma.$EncounterConditionValueMapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EncounterConditionValueMap.
     * @param {EncounterConditionValueMapUpdateArgs} args - Arguments to update one EncounterConditionValueMap.
     * @example
     * // Update one EncounterConditionValueMap
     * const encounterConditionValueMap = await prisma.encounterConditionValueMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncounterConditionValueMapUpdateArgs>(args: SelectSubset<T, EncounterConditionValueMapUpdateArgs<ExtArgs>>): Prisma__EncounterConditionValueMapClient<$Result.GetResult<Prisma.$EncounterConditionValueMapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EncounterConditionValueMaps.
     * @param {EncounterConditionValueMapDeleteManyArgs} args - Arguments to filter EncounterConditionValueMaps to delete.
     * @example
     * // Delete a few EncounterConditionValueMaps
     * const { count } = await prisma.encounterConditionValueMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncounterConditionValueMapDeleteManyArgs>(args?: SelectSubset<T, EncounterConditionValueMapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterConditionValueMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionValueMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncounterConditionValueMaps
     * const encounterConditionValueMap = await prisma.encounterConditionValueMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncounterConditionValueMapUpdateManyArgs>(args: SelectSubset<T, EncounterConditionValueMapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncounterConditionValueMaps and returns the data updated in the database.
     * @param {EncounterConditionValueMapUpdateManyAndReturnArgs} args - Arguments to update many EncounterConditionValueMaps.
     * @example
     * // Update many EncounterConditionValueMaps
     * const encounterConditionValueMap = await prisma.encounterConditionValueMap.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EncounterConditionValueMaps and only return the `id`
     * const encounterConditionValueMapWithIdOnly = await prisma.encounterConditionValueMap.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EncounterConditionValueMapUpdateManyAndReturnArgs>(args: SelectSubset<T, EncounterConditionValueMapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncounterConditionValueMapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EncounterConditionValueMap.
     * @param {EncounterConditionValueMapUpsertArgs} args - Arguments to update or create a EncounterConditionValueMap.
     * @example
     * // Update or create a EncounterConditionValueMap
     * const encounterConditionValueMap = await prisma.encounterConditionValueMap.upsert({
     *   create: {
     *     // ... data to create a EncounterConditionValueMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncounterConditionValueMap we want to update
     *   }
     * })
     */
    upsert<T extends EncounterConditionValueMapUpsertArgs>(args: SelectSubset<T, EncounterConditionValueMapUpsertArgs<ExtArgs>>): Prisma__EncounterConditionValueMapClient<$Result.GetResult<Prisma.$EncounterConditionValueMapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EncounterConditionValueMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionValueMapCountArgs} args - Arguments to filter EncounterConditionValueMaps to count.
     * @example
     * // Count the number of EncounterConditionValueMaps
     * const count = await prisma.encounterConditionValueMap.count({
     *   where: {
     *     // ... the filter for the EncounterConditionValueMaps we want to count
     *   }
     * })
    **/
    count<T extends EncounterConditionValueMapCountArgs>(
      args?: Subset<T, EncounterConditionValueMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncounterConditionValueMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncounterConditionValueMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionValueMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncounterConditionValueMapAggregateArgs>(args: Subset<T, EncounterConditionValueMapAggregateArgs>): Prisma.PrismaPromise<GetEncounterConditionValueMapAggregateType<T>>

    /**
     * Group by EncounterConditionValueMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncounterConditionValueMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncounterConditionValueMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncounterConditionValueMapGroupByArgs['orderBy'] }
        : { orderBy?: EncounterConditionValueMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncounterConditionValueMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncounterConditionValueMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncounterConditionValueMap model
   */
  readonly fields: EncounterConditionValueMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncounterConditionValueMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncounterConditionValueMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    encounter<T extends EncounterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterDefaultArgs<ExtArgs>>): Prisma__EncounterClient<$Result.GetResult<Prisma.$EncounterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    value<T extends EncounterConditionValueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterConditionValueDefaultArgs<ExtArgs>>): Prisma__EncounterConditionValueClient<$Result.GetResult<Prisma.$EncounterConditionValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EncounterConditionValueMap model
   */
  interface EncounterConditionValueMapFieldRefs {
    readonly id: FieldRef<"EncounterConditionValueMap", 'Int'>
    readonly encounter_id: FieldRef<"EncounterConditionValueMap", 'Int'>
    readonly encounter_condition_value_id: FieldRef<"EncounterConditionValueMap", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EncounterConditionValueMap findUnique
   */
  export type EncounterConditionValueMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValueMap
     */
    select?: EncounterConditionValueMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValueMap
     */
    omit?: EncounterConditionValueMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueMapInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConditionValueMap to fetch.
     */
    where: EncounterConditionValueMapWhereUniqueInput
  }

  /**
   * EncounterConditionValueMap findUniqueOrThrow
   */
  export type EncounterConditionValueMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValueMap
     */
    select?: EncounterConditionValueMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValueMap
     */
    omit?: EncounterConditionValueMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueMapInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConditionValueMap to fetch.
     */
    where: EncounterConditionValueMapWhereUniqueInput
  }

  /**
   * EncounterConditionValueMap findFirst
   */
  export type EncounterConditionValueMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValueMap
     */
    select?: EncounterConditionValueMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValueMap
     */
    omit?: EncounterConditionValueMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueMapInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConditionValueMap to fetch.
     */
    where?: EncounterConditionValueMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConditionValueMaps to fetch.
     */
    orderBy?: EncounterConditionValueMapOrderByWithRelationInput | EncounterConditionValueMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterConditionValueMaps.
     */
    cursor?: EncounterConditionValueMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConditionValueMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConditionValueMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterConditionValueMaps.
     */
    distinct?: EncounterConditionValueMapScalarFieldEnum | EncounterConditionValueMapScalarFieldEnum[]
  }

  /**
   * EncounterConditionValueMap findFirstOrThrow
   */
  export type EncounterConditionValueMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValueMap
     */
    select?: EncounterConditionValueMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValueMap
     */
    omit?: EncounterConditionValueMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueMapInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConditionValueMap to fetch.
     */
    where?: EncounterConditionValueMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConditionValueMaps to fetch.
     */
    orderBy?: EncounterConditionValueMapOrderByWithRelationInput | EncounterConditionValueMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncounterConditionValueMaps.
     */
    cursor?: EncounterConditionValueMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConditionValueMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConditionValueMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncounterConditionValueMaps.
     */
    distinct?: EncounterConditionValueMapScalarFieldEnum | EncounterConditionValueMapScalarFieldEnum[]
  }

  /**
   * EncounterConditionValueMap findMany
   */
  export type EncounterConditionValueMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValueMap
     */
    select?: EncounterConditionValueMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValueMap
     */
    omit?: EncounterConditionValueMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueMapInclude<ExtArgs> | null
    /**
     * Filter, which EncounterConditionValueMaps to fetch.
     */
    where?: EncounterConditionValueMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncounterConditionValueMaps to fetch.
     */
    orderBy?: EncounterConditionValueMapOrderByWithRelationInput | EncounterConditionValueMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncounterConditionValueMaps.
     */
    cursor?: EncounterConditionValueMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncounterConditionValueMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncounterConditionValueMaps.
     */
    skip?: number
    distinct?: EncounterConditionValueMapScalarFieldEnum | EncounterConditionValueMapScalarFieldEnum[]
  }

  /**
   * EncounterConditionValueMap create
   */
  export type EncounterConditionValueMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValueMap
     */
    select?: EncounterConditionValueMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValueMap
     */
    omit?: EncounterConditionValueMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueMapInclude<ExtArgs> | null
    /**
     * The data needed to create a EncounterConditionValueMap.
     */
    data: XOR<EncounterConditionValueMapCreateInput, EncounterConditionValueMapUncheckedCreateInput>
  }

  /**
   * EncounterConditionValueMap createMany
   */
  export type EncounterConditionValueMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncounterConditionValueMaps.
     */
    data: EncounterConditionValueMapCreateManyInput | EncounterConditionValueMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EncounterConditionValueMap createManyAndReturn
   */
  export type EncounterConditionValueMapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValueMap
     */
    select?: EncounterConditionValueMapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValueMap
     */
    omit?: EncounterConditionValueMapOmit<ExtArgs> | null
    /**
     * The data used to create many EncounterConditionValueMaps.
     */
    data: EncounterConditionValueMapCreateManyInput | EncounterConditionValueMapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueMapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EncounterConditionValueMap update
   */
  export type EncounterConditionValueMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValueMap
     */
    select?: EncounterConditionValueMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValueMap
     */
    omit?: EncounterConditionValueMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueMapInclude<ExtArgs> | null
    /**
     * The data needed to update a EncounterConditionValueMap.
     */
    data: XOR<EncounterConditionValueMapUpdateInput, EncounterConditionValueMapUncheckedUpdateInput>
    /**
     * Choose, which EncounterConditionValueMap to update.
     */
    where: EncounterConditionValueMapWhereUniqueInput
  }

  /**
   * EncounterConditionValueMap updateMany
   */
  export type EncounterConditionValueMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncounterConditionValueMaps.
     */
    data: XOR<EncounterConditionValueMapUpdateManyMutationInput, EncounterConditionValueMapUncheckedUpdateManyInput>
    /**
     * Filter which EncounterConditionValueMaps to update
     */
    where?: EncounterConditionValueMapWhereInput
    /**
     * Limit how many EncounterConditionValueMaps to update.
     */
    limit?: number
  }

  /**
   * EncounterConditionValueMap updateManyAndReturn
   */
  export type EncounterConditionValueMapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValueMap
     */
    select?: EncounterConditionValueMapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValueMap
     */
    omit?: EncounterConditionValueMapOmit<ExtArgs> | null
    /**
     * The data used to update EncounterConditionValueMaps.
     */
    data: XOR<EncounterConditionValueMapUpdateManyMutationInput, EncounterConditionValueMapUncheckedUpdateManyInput>
    /**
     * Filter which EncounterConditionValueMaps to update
     */
    where?: EncounterConditionValueMapWhereInput
    /**
     * Limit how many EncounterConditionValueMaps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueMapIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EncounterConditionValueMap upsert
   */
  export type EncounterConditionValueMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValueMap
     */
    select?: EncounterConditionValueMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValueMap
     */
    omit?: EncounterConditionValueMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueMapInclude<ExtArgs> | null
    /**
     * The filter to search for the EncounterConditionValueMap to update in case it exists.
     */
    where: EncounterConditionValueMapWhereUniqueInput
    /**
     * In case the EncounterConditionValueMap found by the `where` argument doesn't exist, create a new EncounterConditionValueMap with this data.
     */
    create: XOR<EncounterConditionValueMapCreateInput, EncounterConditionValueMapUncheckedCreateInput>
    /**
     * In case the EncounterConditionValueMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncounterConditionValueMapUpdateInput, EncounterConditionValueMapUncheckedUpdateInput>
  }

  /**
   * EncounterConditionValueMap delete
   */
  export type EncounterConditionValueMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValueMap
     */
    select?: EncounterConditionValueMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValueMap
     */
    omit?: EncounterConditionValueMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueMapInclude<ExtArgs> | null
    /**
     * Filter which EncounterConditionValueMap to delete.
     */
    where: EncounterConditionValueMapWhereUniqueInput
  }

  /**
   * EncounterConditionValueMap deleteMany
   */
  export type EncounterConditionValueMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncounterConditionValueMaps to delete
     */
    where?: EncounterConditionValueMapWhereInput
    /**
     * Limit how many EncounterConditionValueMaps to delete.
     */
    limit?: number
  }

  /**
   * EncounterConditionValueMap without action
   */
  export type EncounterConditionValueMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncounterConditionValueMap
     */
    select?: EncounterConditionValueMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncounterConditionValueMap
     */
    omit?: EncounterConditionValueMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncounterConditionValueMapInclude<ExtArgs> | null
  }


  /**
   * Model LocationAreaEncounterRate
   */

  export type AggregateLocationAreaEncounterRate = {
    _count: LocationAreaEncounterRateCountAggregateOutputType | null
    _avg: LocationAreaEncounterRateAvgAggregateOutputType | null
    _sum: LocationAreaEncounterRateSumAggregateOutputType | null
    _min: LocationAreaEncounterRateMinAggregateOutputType | null
    _max: LocationAreaEncounterRateMaxAggregateOutputType | null
  }

  export type LocationAreaEncounterRateAvgAggregateOutputType = {
    id: number | null
    location_area_id: number | null
    encounter_method_id: number | null
    version_id: number | null
    rate: number | null
  }

  export type LocationAreaEncounterRateSumAggregateOutputType = {
    id: number | null
    location_area_id: number | null
    encounter_method_id: number | null
    version_id: number | null
    rate: number | null
  }

  export type LocationAreaEncounterRateMinAggregateOutputType = {
    id: number | null
    location_area_id: number | null
    encounter_method_id: number | null
    version_id: number | null
    rate: number | null
  }

  export type LocationAreaEncounterRateMaxAggregateOutputType = {
    id: number | null
    location_area_id: number | null
    encounter_method_id: number | null
    version_id: number | null
    rate: number | null
  }

  export type LocationAreaEncounterRateCountAggregateOutputType = {
    id: number
    location_area_id: number
    encounter_method_id: number
    version_id: number
    rate: number
    _all: number
  }


  export type LocationAreaEncounterRateAvgAggregateInputType = {
    id?: true
    location_area_id?: true
    encounter_method_id?: true
    version_id?: true
    rate?: true
  }

  export type LocationAreaEncounterRateSumAggregateInputType = {
    id?: true
    location_area_id?: true
    encounter_method_id?: true
    version_id?: true
    rate?: true
  }

  export type LocationAreaEncounterRateMinAggregateInputType = {
    id?: true
    location_area_id?: true
    encounter_method_id?: true
    version_id?: true
    rate?: true
  }

  export type LocationAreaEncounterRateMaxAggregateInputType = {
    id?: true
    location_area_id?: true
    encounter_method_id?: true
    version_id?: true
    rate?: true
  }

  export type LocationAreaEncounterRateCountAggregateInputType = {
    id?: true
    location_area_id?: true
    encounter_method_id?: true
    version_id?: true
    rate?: true
    _all?: true
  }

  export type LocationAreaEncounterRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationAreaEncounterRate to aggregate.
     */
    where?: LocationAreaEncounterRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationAreaEncounterRates to fetch.
     */
    orderBy?: LocationAreaEncounterRateOrderByWithRelationInput | LocationAreaEncounterRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationAreaEncounterRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationAreaEncounterRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationAreaEncounterRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocationAreaEncounterRates
    **/
    _count?: true | LocationAreaEncounterRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAreaEncounterRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationAreaEncounterRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationAreaEncounterRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationAreaEncounterRateMaxAggregateInputType
  }

  export type GetLocationAreaEncounterRateAggregateType<T extends LocationAreaEncounterRateAggregateArgs> = {
        [P in keyof T & keyof AggregateLocationAreaEncounterRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocationAreaEncounterRate[P]>
      : GetScalarType<T[P], AggregateLocationAreaEncounterRate[P]>
  }




  export type LocationAreaEncounterRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationAreaEncounterRateWhereInput
    orderBy?: LocationAreaEncounterRateOrderByWithAggregationInput | LocationAreaEncounterRateOrderByWithAggregationInput[]
    by: LocationAreaEncounterRateScalarFieldEnum[] | LocationAreaEncounterRateScalarFieldEnum
    having?: LocationAreaEncounterRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationAreaEncounterRateCountAggregateInputType | true
    _avg?: LocationAreaEncounterRateAvgAggregateInputType
    _sum?: LocationAreaEncounterRateSumAggregateInputType
    _min?: LocationAreaEncounterRateMinAggregateInputType
    _max?: LocationAreaEncounterRateMaxAggregateInputType
  }

  export type LocationAreaEncounterRateGroupByOutputType = {
    id: number
    location_area_id: number
    encounter_method_id: number
    version_id: number
    rate: number
    _count: LocationAreaEncounterRateCountAggregateOutputType | null
    _avg: LocationAreaEncounterRateAvgAggregateOutputType | null
    _sum: LocationAreaEncounterRateSumAggregateOutputType | null
    _min: LocationAreaEncounterRateMinAggregateOutputType | null
    _max: LocationAreaEncounterRateMaxAggregateOutputType | null
  }

  type GetLocationAreaEncounterRateGroupByPayload<T extends LocationAreaEncounterRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationAreaEncounterRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationAreaEncounterRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationAreaEncounterRateGroupByOutputType[P]>
            : GetScalarType<T[P], LocationAreaEncounterRateGroupByOutputType[P]>
        }
      >
    >


  export type LocationAreaEncounterRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    location_area_id?: boolean
    encounter_method_id?: boolean
    version_id?: boolean
    rate?: boolean
    location_area?: boolean | LocationAreaDefaultArgs<ExtArgs>
    encounter_method?: boolean | EncounterMethodDefaultArgs<ExtArgs>
    version?: boolean | VersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationAreaEncounterRate"]>

  export type LocationAreaEncounterRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    location_area_id?: boolean
    encounter_method_id?: boolean
    version_id?: boolean
    rate?: boolean
    location_area?: boolean | LocationAreaDefaultArgs<ExtArgs>
    encounter_method?: boolean | EncounterMethodDefaultArgs<ExtArgs>
    version?: boolean | VersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationAreaEncounterRate"]>

  export type LocationAreaEncounterRateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    location_area_id?: boolean
    encounter_method_id?: boolean
    version_id?: boolean
    rate?: boolean
    location_area?: boolean | LocationAreaDefaultArgs<ExtArgs>
    encounter_method?: boolean | EncounterMethodDefaultArgs<ExtArgs>
    version?: boolean | VersionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationAreaEncounterRate"]>

  export type LocationAreaEncounterRateSelectScalar = {
    id?: boolean
    location_area_id?: boolean
    encounter_method_id?: boolean
    version_id?: boolean
    rate?: boolean
  }

  export type LocationAreaEncounterRateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "location_area_id" | "encounter_method_id" | "version_id" | "rate", ExtArgs["result"]["locationAreaEncounterRate"]>
  export type LocationAreaEncounterRateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location_area?: boolean | LocationAreaDefaultArgs<ExtArgs>
    encounter_method?: boolean | EncounterMethodDefaultArgs<ExtArgs>
    version?: boolean | VersionDefaultArgs<ExtArgs>
  }
  export type LocationAreaEncounterRateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location_area?: boolean | LocationAreaDefaultArgs<ExtArgs>
    encounter_method?: boolean | EncounterMethodDefaultArgs<ExtArgs>
    version?: boolean | VersionDefaultArgs<ExtArgs>
  }
  export type LocationAreaEncounterRateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location_area?: boolean | LocationAreaDefaultArgs<ExtArgs>
    encounter_method?: boolean | EncounterMethodDefaultArgs<ExtArgs>
    version?: boolean | VersionDefaultArgs<ExtArgs>
  }

  export type $LocationAreaEncounterRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocationAreaEncounterRate"
    objects: {
      location_area: Prisma.$LocationAreaPayload<ExtArgs>
      encounter_method: Prisma.$EncounterMethodPayload<ExtArgs>
      version: Prisma.$VersionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      location_area_id: number
      encounter_method_id: number
      version_id: number
      rate: number
    }, ExtArgs["result"]["locationAreaEncounterRate"]>
    composites: {}
  }

  type LocationAreaEncounterRateGetPayload<S extends boolean | null | undefined | LocationAreaEncounterRateDefaultArgs> = $Result.GetResult<Prisma.$LocationAreaEncounterRatePayload, S>

  type LocationAreaEncounterRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationAreaEncounterRateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationAreaEncounterRateCountAggregateInputType | true
    }

  export interface LocationAreaEncounterRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocationAreaEncounterRate'], meta: { name: 'LocationAreaEncounterRate' } }
    /**
     * Find zero or one LocationAreaEncounterRate that matches the filter.
     * @param {LocationAreaEncounterRateFindUniqueArgs} args - Arguments to find a LocationAreaEncounterRate
     * @example
     * // Get one LocationAreaEncounterRate
     * const locationAreaEncounterRate = await prisma.locationAreaEncounterRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationAreaEncounterRateFindUniqueArgs>(args: SelectSubset<T, LocationAreaEncounterRateFindUniqueArgs<ExtArgs>>): Prisma__LocationAreaEncounterRateClient<$Result.GetResult<Prisma.$LocationAreaEncounterRatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LocationAreaEncounterRate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationAreaEncounterRateFindUniqueOrThrowArgs} args - Arguments to find a LocationAreaEncounterRate
     * @example
     * // Get one LocationAreaEncounterRate
     * const locationAreaEncounterRate = await prisma.locationAreaEncounterRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationAreaEncounterRateFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationAreaEncounterRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationAreaEncounterRateClient<$Result.GetResult<Prisma.$LocationAreaEncounterRatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocationAreaEncounterRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAreaEncounterRateFindFirstArgs} args - Arguments to find a LocationAreaEncounterRate
     * @example
     * // Get one LocationAreaEncounterRate
     * const locationAreaEncounterRate = await prisma.locationAreaEncounterRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationAreaEncounterRateFindFirstArgs>(args?: SelectSubset<T, LocationAreaEncounterRateFindFirstArgs<ExtArgs>>): Prisma__LocationAreaEncounterRateClient<$Result.GetResult<Prisma.$LocationAreaEncounterRatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocationAreaEncounterRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAreaEncounterRateFindFirstOrThrowArgs} args - Arguments to find a LocationAreaEncounterRate
     * @example
     * // Get one LocationAreaEncounterRate
     * const locationAreaEncounterRate = await prisma.locationAreaEncounterRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationAreaEncounterRateFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationAreaEncounterRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationAreaEncounterRateClient<$Result.GetResult<Prisma.$LocationAreaEncounterRatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LocationAreaEncounterRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAreaEncounterRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocationAreaEncounterRates
     * const locationAreaEncounterRates = await prisma.locationAreaEncounterRate.findMany()
     * 
     * // Get first 10 LocationAreaEncounterRates
     * const locationAreaEncounterRates = await prisma.locationAreaEncounterRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationAreaEncounterRateWithIdOnly = await prisma.locationAreaEncounterRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationAreaEncounterRateFindManyArgs>(args?: SelectSubset<T, LocationAreaEncounterRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationAreaEncounterRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LocationAreaEncounterRate.
     * @param {LocationAreaEncounterRateCreateArgs} args - Arguments to create a LocationAreaEncounterRate.
     * @example
     * // Create one LocationAreaEncounterRate
     * const LocationAreaEncounterRate = await prisma.locationAreaEncounterRate.create({
     *   data: {
     *     // ... data to create a LocationAreaEncounterRate
     *   }
     * })
     * 
     */
    create<T extends LocationAreaEncounterRateCreateArgs>(args: SelectSubset<T, LocationAreaEncounterRateCreateArgs<ExtArgs>>): Prisma__LocationAreaEncounterRateClient<$Result.GetResult<Prisma.$LocationAreaEncounterRatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LocationAreaEncounterRates.
     * @param {LocationAreaEncounterRateCreateManyArgs} args - Arguments to create many LocationAreaEncounterRates.
     * @example
     * // Create many LocationAreaEncounterRates
     * const locationAreaEncounterRate = await prisma.locationAreaEncounterRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationAreaEncounterRateCreateManyArgs>(args?: SelectSubset<T, LocationAreaEncounterRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LocationAreaEncounterRates and returns the data saved in the database.
     * @param {LocationAreaEncounterRateCreateManyAndReturnArgs} args - Arguments to create many LocationAreaEncounterRates.
     * @example
     * // Create many LocationAreaEncounterRates
     * const locationAreaEncounterRate = await prisma.locationAreaEncounterRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LocationAreaEncounterRates and only return the `id`
     * const locationAreaEncounterRateWithIdOnly = await prisma.locationAreaEncounterRate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationAreaEncounterRateCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationAreaEncounterRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationAreaEncounterRatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LocationAreaEncounterRate.
     * @param {LocationAreaEncounterRateDeleteArgs} args - Arguments to delete one LocationAreaEncounterRate.
     * @example
     * // Delete one LocationAreaEncounterRate
     * const LocationAreaEncounterRate = await prisma.locationAreaEncounterRate.delete({
     *   where: {
     *     // ... filter to delete one LocationAreaEncounterRate
     *   }
     * })
     * 
     */
    delete<T extends LocationAreaEncounterRateDeleteArgs>(args: SelectSubset<T, LocationAreaEncounterRateDeleteArgs<ExtArgs>>): Prisma__LocationAreaEncounterRateClient<$Result.GetResult<Prisma.$LocationAreaEncounterRatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LocationAreaEncounterRate.
     * @param {LocationAreaEncounterRateUpdateArgs} args - Arguments to update one LocationAreaEncounterRate.
     * @example
     * // Update one LocationAreaEncounterRate
     * const locationAreaEncounterRate = await prisma.locationAreaEncounterRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationAreaEncounterRateUpdateArgs>(args: SelectSubset<T, LocationAreaEncounterRateUpdateArgs<ExtArgs>>): Prisma__LocationAreaEncounterRateClient<$Result.GetResult<Prisma.$LocationAreaEncounterRatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LocationAreaEncounterRates.
     * @param {LocationAreaEncounterRateDeleteManyArgs} args - Arguments to filter LocationAreaEncounterRates to delete.
     * @example
     * // Delete a few LocationAreaEncounterRates
     * const { count } = await prisma.locationAreaEncounterRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationAreaEncounterRateDeleteManyArgs>(args?: SelectSubset<T, LocationAreaEncounterRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationAreaEncounterRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAreaEncounterRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocationAreaEncounterRates
     * const locationAreaEncounterRate = await prisma.locationAreaEncounterRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationAreaEncounterRateUpdateManyArgs>(args: SelectSubset<T, LocationAreaEncounterRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationAreaEncounterRates and returns the data updated in the database.
     * @param {LocationAreaEncounterRateUpdateManyAndReturnArgs} args - Arguments to update many LocationAreaEncounterRates.
     * @example
     * // Update many LocationAreaEncounterRates
     * const locationAreaEncounterRate = await prisma.locationAreaEncounterRate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LocationAreaEncounterRates and only return the `id`
     * const locationAreaEncounterRateWithIdOnly = await prisma.locationAreaEncounterRate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationAreaEncounterRateUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationAreaEncounterRateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationAreaEncounterRatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LocationAreaEncounterRate.
     * @param {LocationAreaEncounterRateUpsertArgs} args - Arguments to update or create a LocationAreaEncounterRate.
     * @example
     * // Update or create a LocationAreaEncounterRate
     * const locationAreaEncounterRate = await prisma.locationAreaEncounterRate.upsert({
     *   create: {
     *     // ... data to create a LocationAreaEncounterRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocationAreaEncounterRate we want to update
     *   }
     * })
     */
    upsert<T extends LocationAreaEncounterRateUpsertArgs>(args: SelectSubset<T, LocationAreaEncounterRateUpsertArgs<ExtArgs>>): Prisma__LocationAreaEncounterRateClient<$Result.GetResult<Prisma.$LocationAreaEncounterRatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LocationAreaEncounterRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAreaEncounterRateCountArgs} args - Arguments to filter LocationAreaEncounterRates to count.
     * @example
     * // Count the number of LocationAreaEncounterRates
     * const count = await prisma.locationAreaEncounterRate.count({
     *   where: {
     *     // ... the filter for the LocationAreaEncounterRates we want to count
     *   }
     * })
    **/
    count<T extends LocationAreaEncounterRateCountArgs>(
      args?: Subset<T, LocationAreaEncounterRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationAreaEncounterRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocationAreaEncounterRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAreaEncounterRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAreaEncounterRateAggregateArgs>(args: Subset<T, LocationAreaEncounterRateAggregateArgs>): Prisma.PrismaPromise<GetLocationAreaEncounterRateAggregateType<T>>

    /**
     * Group by LocationAreaEncounterRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAreaEncounterRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationAreaEncounterRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationAreaEncounterRateGroupByArgs['orderBy'] }
        : { orderBy?: LocationAreaEncounterRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationAreaEncounterRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationAreaEncounterRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocationAreaEncounterRate model
   */
  readonly fields: LocationAreaEncounterRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocationAreaEncounterRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationAreaEncounterRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location_area<T extends LocationAreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationAreaDefaultArgs<ExtArgs>>): Prisma__LocationAreaClient<$Result.GetResult<Prisma.$LocationAreaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    encounter_method<T extends EncounterMethodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EncounterMethodDefaultArgs<ExtArgs>>): Prisma__EncounterMethodClient<$Result.GetResult<Prisma.$EncounterMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    version<T extends VersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VersionDefaultArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocationAreaEncounterRate model
   */
  interface LocationAreaEncounterRateFieldRefs {
    readonly id: FieldRef<"LocationAreaEncounterRate", 'Int'>
    readonly location_area_id: FieldRef<"LocationAreaEncounterRate", 'Int'>
    readonly encounter_method_id: FieldRef<"LocationAreaEncounterRate", 'Int'>
    readonly version_id: FieldRef<"LocationAreaEncounterRate", 'Int'>
    readonly rate: FieldRef<"LocationAreaEncounterRate", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LocationAreaEncounterRate findUnique
   */
  export type LocationAreaEncounterRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAreaEncounterRate
     */
    select?: LocationAreaEncounterRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAreaEncounterRate
     */
    omit?: LocationAreaEncounterRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaEncounterRateInclude<ExtArgs> | null
    /**
     * Filter, which LocationAreaEncounterRate to fetch.
     */
    where: LocationAreaEncounterRateWhereUniqueInput
  }

  /**
   * LocationAreaEncounterRate findUniqueOrThrow
   */
  export type LocationAreaEncounterRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAreaEncounterRate
     */
    select?: LocationAreaEncounterRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAreaEncounterRate
     */
    omit?: LocationAreaEncounterRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaEncounterRateInclude<ExtArgs> | null
    /**
     * Filter, which LocationAreaEncounterRate to fetch.
     */
    where: LocationAreaEncounterRateWhereUniqueInput
  }

  /**
   * LocationAreaEncounterRate findFirst
   */
  export type LocationAreaEncounterRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAreaEncounterRate
     */
    select?: LocationAreaEncounterRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAreaEncounterRate
     */
    omit?: LocationAreaEncounterRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaEncounterRateInclude<ExtArgs> | null
    /**
     * Filter, which LocationAreaEncounterRate to fetch.
     */
    where?: LocationAreaEncounterRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationAreaEncounterRates to fetch.
     */
    orderBy?: LocationAreaEncounterRateOrderByWithRelationInput | LocationAreaEncounterRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationAreaEncounterRates.
     */
    cursor?: LocationAreaEncounterRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationAreaEncounterRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationAreaEncounterRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationAreaEncounterRates.
     */
    distinct?: LocationAreaEncounterRateScalarFieldEnum | LocationAreaEncounterRateScalarFieldEnum[]
  }

  /**
   * LocationAreaEncounterRate findFirstOrThrow
   */
  export type LocationAreaEncounterRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAreaEncounterRate
     */
    select?: LocationAreaEncounterRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAreaEncounterRate
     */
    omit?: LocationAreaEncounterRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaEncounterRateInclude<ExtArgs> | null
    /**
     * Filter, which LocationAreaEncounterRate to fetch.
     */
    where?: LocationAreaEncounterRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationAreaEncounterRates to fetch.
     */
    orderBy?: LocationAreaEncounterRateOrderByWithRelationInput | LocationAreaEncounterRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationAreaEncounterRates.
     */
    cursor?: LocationAreaEncounterRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationAreaEncounterRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationAreaEncounterRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationAreaEncounterRates.
     */
    distinct?: LocationAreaEncounterRateScalarFieldEnum | LocationAreaEncounterRateScalarFieldEnum[]
  }

  /**
   * LocationAreaEncounterRate findMany
   */
  export type LocationAreaEncounterRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAreaEncounterRate
     */
    select?: LocationAreaEncounterRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAreaEncounterRate
     */
    omit?: LocationAreaEncounterRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaEncounterRateInclude<ExtArgs> | null
    /**
     * Filter, which LocationAreaEncounterRates to fetch.
     */
    where?: LocationAreaEncounterRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationAreaEncounterRates to fetch.
     */
    orderBy?: LocationAreaEncounterRateOrderByWithRelationInput | LocationAreaEncounterRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocationAreaEncounterRates.
     */
    cursor?: LocationAreaEncounterRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationAreaEncounterRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationAreaEncounterRates.
     */
    skip?: number
    distinct?: LocationAreaEncounterRateScalarFieldEnum | LocationAreaEncounterRateScalarFieldEnum[]
  }

  /**
   * LocationAreaEncounterRate create
   */
  export type LocationAreaEncounterRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAreaEncounterRate
     */
    select?: LocationAreaEncounterRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAreaEncounterRate
     */
    omit?: LocationAreaEncounterRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaEncounterRateInclude<ExtArgs> | null
    /**
     * The data needed to create a LocationAreaEncounterRate.
     */
    data: XOR<LocationAreaEncounterRateCreateInput, LocationAreaEncounterRateUncheckedCreateInput>
  }

  /**
   * LocationAreaEncounterRate createMany
   */
  export type LocationAreaEncounterRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocationAreaEncounterRates.
     */
    data: LocationAreaEncounterRateCreateManyInput | LocationAreaEncounterRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LocationAreaEncounterRate createManyAndReturn
   */
  export type LocationAreaEncounterRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAreaEncounterRate
     */
    select?: LocationAreaEncounterRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAreaEncounterRate
     */
    omit?: LocationAreaEncounterRateOmit<ExtArgs> | null
    /**
     * The data used to create many LocationAreaEncounterRates.
     */
    data: LocationAreaEncounterRateCreateManyInput | LocationAreaEncounterRateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaEncounterRateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LocationAreaEncounterRate update
   */
  export type LocationAreaEncounterRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAreaEncounterRate
     */
    select?: LocationAreaEncounterRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAreaEncounterRate
     */
    omit?: LocationAreaEncounterRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaEncounterRateInclude<ExtArgs> | null
    /**
     * The data needed to update a LocationAreaEncounterRate.
     */
    data: XOR<LocationAreaEncounterRateUpdateInput, LocationAreaEncounterRateUncheckedUpdateInput>
    /**
     * Choose, which LocationAreaEncounterRate to update.
     */
    where: LocationAreaEncounterRateWhereUniqueInput
  }

  /**
   * LocationAreaEncounterRate updateMany
   */
  export type LocationAreaEncounterRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocationAreaEncounterRates.
     */
    data: XOR<LocationAreaEncounterRateUpdateManyMutationInput, LocationAreaEncounterRateUncheckedUpdateManyInput>
    /**
     * Filter which LocationAreaEncounterRates to update
     */
    where?: LocationAreaEncounterRateWhereInput
    /**
     * Limit how many LocationAreaEncounterRates to update.
     */
    limit?: number
  }

  /**
   * LocationAreaEncounterRate updateManyAndReturn
   */
  export type LocationAreaEncounterRateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAreaEncounterRate
     */
    select?: LocationAreaEncounterRateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAreaEncounterRate
     */
    omit?: LocationAreaEncounterRateOmit<ExtArgs> | null
    /**
     * The data used to update LocationAreaEncounterRates.
     */
    data: XOR<LocationAreaEncounterRateUpdateManyMutationInput, LocationAreaEncounterRateUncheckedUpdateManyInput>
    /**
     * Filter which LocationAreaEncounterRates to update
     */
    where?: LocationAreaEncounterRateWhereInput
    /**
     * Limit how many LocationAreaEncounterRates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaEncounterRateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LocationAreaEncounterRate upsert
   */
  export type LocationAreaEncounterRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAreaEncounterRate
     */
    select?: LocationAreaEncounterRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAreaEncounterRate
     */
    omit?: LocationAreaEncounterRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaEncounterRateInclude<ExtArgs> | null
    /**
     * The filter to search for the LocationAreaEncounterRate to update in case it exists.
     */
    where: LocationAreaEncounterRateWhereUniqueInput
    /**
     * In case the LocationAreaEncounterRate found by the `where` argument doesn't exist, create a new LocationAreaEncounterRate with this data.
     */
    create: XOR<LocationAreaEncounterRateCreateInput, LocationAreaEncounterRateUncheckedCreateInput>
    /**
     * In case the LocationAreaEncounterRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationAreaEncounterRateUpdateInput, LocationAreaEncounterRateUncheckedUpdateInput>
  }

  /**
   * LocationAreaEncounterRate delete
   */
  export type LocationAreaEncounterRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAreaEncounterRate
     */
    select?: LocationAreaEncounterRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAreaEncounterRate
     */
    omit?: LocationAreaEncounterRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaEncounterRateInclude<ExtArgs> | null
    /**
     * Filter which LocationAreaEncounterRate to delete.
     */
    where: LocationAreaEncounterRateWhereUniqueInput
  }

  /**
   * LocationAreaEncounterRate deleteMany
   */
  export type LocationAreaEncounterRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationAreaEncounterRates to delete
     */
    where?: LocationAreaEncounterRateWhereInput
    /**
     * Limit how many LocationAreaEncounterRates to delete.
     */
    limit?: number
  }

  /**
   * LocationAreaEncounterRate without action
   */
  export type LocationAreaEncounterRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAreaEncounterRate
     */
    select?: LocationAreaEncounterRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAreaEncounterRate
     */
    omit?: LocationAreaEncounterRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationAreaEncounterRateInclude<ExtArgs> | null
  }


  /**
   * Model MoveDamageClass
   */

  export type AggregateMoveDamageClass = {
    _count: MoveDamageClassCountAggregateOutputType | null
    _avg: MoveDamageClassAvgAggregateOutputType | null
    _sum: MoveDamageClassSumAggregateOutputType | null
    _min: MoveDamageClassMinAggregateOutputType | null
    _max: MoveDamageClassMaxAggregateOutputType | null
  }

  export type MoveDamageClassAvgAggregateOutputType = {
    id: number | null
  }

  export type MoveDamageClassSumAggregateOutputType = {
    id: number | null
  }

  export type MoveDamageClassMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type MoveDamageClassMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type MoveDamageClassCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type MoveDamageClassAvgAggregateInputType = {
    id?: true
  }

  export type MoveDamageClassSumAggregateInputType = {
    id?: true
  }

  export type MoveDamageClassMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type MoveDamageClassMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type MoveDamageClassCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type MoveDamageClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MoveDamageClass to aggregate.
     */
    where?: MoveDamageClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoveDamageClasses to fetch.
     */
    orderBy?: MoveDamageClassOrderByWithRelationInput | MoveDamageClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MoveDamageClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoveDamageClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoveDamageClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MoveDamageClasses
    **/
    _count?: true | MoveDamageClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MoveDamageClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MoveDamageClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MoveDamageClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MoveDamageClassMaxAggregateInputType
  }

  export type GetMoveDamageClassAggregateType<T extends MoveDamageClassAggregateArgs> = {
        [P in keyof T & keyof AggregateMoveDamageClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMoveDamageClass[P]>
      : GetScalarType<T[P], AggregateMoveDamageClass[P]>
  }




  export type MoveDamageClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoveDamageClassWhereInput
    orderBy?: MoveDamageClassOrderByWithAggregationInput | MoveDamageClassOrderByWithAggregationInput[]
    by: MoveDamageClassScalarFieldEnum[] | MoveDamageClassScalarFieldEnum
    having?: MoveDamageClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MoveDamageClassCountAggregateInputType | true
    _avg?: MoveDamageClassAvgAggregateInputType
    _sum?: MoveDamageClassSumAggregateInputType
    _min?: MoveDamageClassMinAggregateInputType
    _max?: MoveDamageClassMaxAggregateInputType
  }

  export type MoveDamageClassGroupByOutputType = {
    id: number
    name: string
    _count: MoveDamageClassCountAggregateOutputType | null
    _avg: MoveDamageClassAvgAggregateOutputType | null
    _sum: MoveDamageClassSumAggregateOutputType | null
    _min: MoveDamageClassMinAggregateOutputType | null
    _max: MoveDamageClassMaxAggregateOutputType | null
  }

  type GetMoveDamageClassGroupByPayload<T extends MoveDamageClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MoveDamageClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MoveDamageClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MoveDamageClassGroupByOutputType[P]>
            : GetScalarType<T[P], MoveDamageClassGroupByOutputType[P]>
        }
      >
    >


  export type MoveDamageClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    moves?: boolean | MoveDamageClass$movesArgs<ExtArgs>
    _count?: boolean | MoveDamageClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moveDamageClass"]>

  export type MoveDamageClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["moveDamageClass"]>

  export type MoveDamageClassSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["moveDamageClass"]>

  export type MoveDamageClassSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type MoveDamageClassOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["moveDamageClass"]>
  export type MoveDamageClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    moves?: boolean | MoveDamageClass$movesArgs<ExtArgs>
    _count?: boolean | MoveDamageClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MoveDamageClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MoveDamageClassIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MoveDamageClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MoveDamageClass"
    objects: {
      moves: Prisma.$MovePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["moveDamageClass"]>
    composites: {}
  }

  type MoveDamageClassGetPayload<S extends boolean | null | undefined | MoveDamageClassDefaultArgs> = $Result.GetResult<Prisma.$MoveDamageClassPayload, S>

  type MoveDamageClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MoveDamageClassFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MoveDamageClassCountAggregateInputType | true
    }

  export interface MoveDamageClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MoveDamageClass'], meta: { name: 'MoveDamageClass' } }
    /**
     * Find zero or one MoveDamageClass that matches the filter.
     * @param {MoveDamageClassFindUniqueArgs} args - Arguments to find a MoveDamageClass
     * @example
     * // Get one MoveDamageClass
     * const moveDamageClass = await prisma.moveDamageClass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MoveDamageClassFindUniqueArgs>(args: SelectSubset<T, MoveDamageClassFindUniqueArgs<ExtArgs>>): Prisma__MoveDamageClassClient<$Result.GetResult<Prisma.$MoveDamageClassPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MoveDamageClass that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MoveDamageClassFindUniqueOrThrowArgs} args - Arguments to find a MoveDamageClass
     * @example
     * // Get one MoveDamageClass
     * const moveDamageClass = await prisma.moveDamageClass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MoveDamageClassFindUniqueOrThrowArgs>(args: SelectSubset<T, MoveDamageClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MoveDamageClassClient<$Result.GetResult<Prisma.$MoveDamageClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MoveDamageClass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveDamageClassFindFirstArgs} args - Arguments to find a MoveDamageClass
     * @example
     * // Get one MoveDamageClass
     * const moveDamageClass = await prisma.moveDamageClass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MoveDamageClassFindFirstArgs>(args?: SelectSubset<T, MoveDamageClassFindFirstArgs<ExtArgs>>): Prisma__MoveDamageClassClient<$Result.GetResult<Prisma.$MoveDamageClassPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MoveDamageClass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveDamageClassFindFirstOrThrowArgs} args - Arguments to find a MoveDamageClass
     * @example
     * // Get one MoveDamageClass
     * const moveDamageClass = await prisma.moveDamageClass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MoveDamageClassFindFirstOrThrowArgs>(args?: SelectSubset<T, MoveDamageClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__MoveDamageClassClient<$Result.GetResult<Prisma.$MoveDamageClassPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MoveDamageClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveDamageClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MoveDamageClasses
     * const moveDamageClasses = await prisma.moveDamageClass.findMany()
     * 
     * // Get first 10 MoveDamageClasses
     * const moveDamageClasses = await prisma.moveDamageClass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moveDamageClassWithIdOnly = await prisma.moveDamageClass.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MoveDamageClassFindManyArgs>(args?: SelectSubset<T, MoveDamageClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoveDamageClassPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MoveDamageClass.
     * @param {MoveDamageClassCreateArgs} args - Arguments to create a MoveDamageClass.
     * @example
     * // Create one MoveDamageClass
     * const MoveDamageClass = await prisma.moveDamageClass.create({
     *   data: {
     *     // ... data to create a MoveDamageClass
     *   }
     * })
     * 
     */
    create<T extends MoveDamageClassCreateArgs>(args: SelectSubset<T, MoveDamageClassCreateArgs<ExtArgs>>): Prisma__MoveDamageClassClient<$Result.GetResult<Prisma.$MoveDamageClassPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MoveDamageClasses.
     * @param {MoveDamageClassCreateManyArgs} args - Arguments to create many MoveDamageClasses.
     * @example
     * // Create many MoveDamageClasses
     * const moveDamageClass = await prisma.moveDamageClass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MoveDamageClassCreateManyArgs>(args?: SelectSubset<T, MoveDamageClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MoveDamageClasses and returns the data saved in the database.
     * @param {MoveDamageClassCreateManyAndReturnArgs} args - Arguments to create many MoveDamageClasses.
     * @example
     * // Create many MoveDamageClasses
     * const moveDamageClass = await prisma.moveDamageClass.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MoveDamageClasses and only return the `id`
     * const moveDamageClassWithIdOnly = await prisma.moveDamageClass.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MoveDamageClassCreateManyAndReturnArgs>(args?: SelectSubset<T, MoveDamageClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoveDamageClassPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MoveDamageClass.
     * @param {MoveDamageClassDeleteArgs} args - Arguments to delete one MoveDamageClass.
     * @example
     * // Delete one MoveDamageClass
     * const MoveDamageClass = await prisma.moveDamageClass.delete({
     *   where: {
     *     // ... filter to delete one MoveDamageClass
     *   }
     * })
     * 
     */
    delete<T extends MoveDamageClassDeleteArgs>(args: SelectSubset<T, MoveDamageClassDeleteArgs<ExtArgs>>): Prisma__MoveDamageClassClient<$Result.GetResult<Prisma.$MoveDamageClassPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MoveDamageClass.
     * @param {MoveDamageClassUpdateArgs} args - Arguments to update one MoveDamageClass.
     * @example
     * // Update one MoveDamageClass
     * const moveDamageClass = await prisma.moveDamageClass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MoveDamageClassUpdateArgs>(args: SelectSubset<T, MoveDamageClassUpdateArgs<ExtArgs>>): Prisma__MoveDamageClassClient<$Result.GetResult<Prisma.$MoveDamageClassPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MoveDamageClasses.
     * @param {MoveDamageClassDeleteManyArgs} args - Arguments to filter MoveDamageClasses to delete.
     * @example
     * // Delete a few MoveDamageClasses
     * const { count } = await prisma.moveDamageClass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MoveDamageClassDeleteManyArgs>(args?: SelectSubset<T, MoveDamageClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MoveDamageClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveDamageClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MoveDamageClasses
     * const moveDamageClass = await prisma.moveDamageClass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MoveDamageClassUpdateManyArgs>(args: SelectSubset<T, MoveDamageClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MoveDamageClasses and returns the data updated in the database.
     * @param {MoveDamageClassUpdateManyAndReturnArgs} args - Arguments to update many MoveDamageClasses.
     * @example
     * // Update many MoveDamageClasses
     * const moveDamageClass = await prisma.moveDamageClass.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MoveDamageClasses and only return the `id`
     * const moveDamageClassWithIdOnly = await prisma.moveDamageClass.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MoveDamageClassUpdateManyAndReturnArgs>(args: SelectSubset<T, MoveDamageClassUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoveDamageClassPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MoveDamageClass.
     * @param {MoveDamageClassUpsertArgs} args - Arguments to update or create a MoveDamageClass.
     * @example
     * // Update or create a MoveDamageClass
     * const moveDamageClass = await prisma.moveDamageClass.upsert({
     *   create: {
     *     // ... data to create a MoveDamageClass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MoveDamageClass we want to update
     *   }
     * })
     */
    upsert<T extends MoveDamageClassUpsertArgs>(args: SelectSubset<T, MoveDamageClassUpsertArgs<ExtArgs>>): Prisma__MoveDamageClassClient<$Result.GetResult<Prisma.$MoveDamageClassPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MoveDamageClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveDamageClassCountArgs} args - Arguments to filter MoveDamageClasses to count.
     * @example
     * // Count the number of MoveDamageClasses
     * const count = await prisma.moveDamageClass.count({
     *   where: {
     *     // ... the filter for the MoveDamageClasses we want to count
     *   }
     * })
    **/
    count<T extends MoveDamageClassCountArgs>(
      args?: Subset<T, MoveDamageClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MoveDamageClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MoveDamageClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveDamageClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MoveDamageClassAggregateArgs>(args: Subset<T, MoveDamageClassAggregateArgs>): Prisma.PrismaPromise<GetMoveDamageClassAggregateType<T>>

    /**
     * Group by MoveDamageClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveDamageClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MoveDamageClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MoveDamageClassGroupByArgs['orderBy'] }
        : { orderBy?: MoveDamageClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MoveDamageClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMoveDamageClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MoveDamageClass model
   */
  readonly fields: MoveDamageClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MoveDamageClass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MoveDamageClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    moves<T extends MoveDamageClass$movesArgs<ExtArgs> = {}>(args?: Subset<T, MoveDamageClass$movesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MoveDamageClass model
   */
  interface MoveDamageClassFieldRefs {
    readonly id: FieldRef<"MoveDamageClass", 'Int'>
    readonly name: FieldRef<"MoveDamageClass", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MoveDamageClass findUnique
   */
  export type MoveDamageClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveDamageClass
     */
    select?: MoveDamageClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveDamageClass
     */
    omit?: MoveDamageClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveDamageClassInclude<ExtArgs> | null
    /**
     * Filter, which MoveDamageClass to fetch.
     */
    where: MoveDamageClassWhereUniqueInput
  }

  /**
   * MoveDamageClass findUniqueOrThrow
   */
  export type MoveDamageClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveDamageClass
     */
    select?: MoveDamageClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveDamageClass
     */
    omit?: MoveDamageClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveDamageClassInclude<ExtArgs> | null
    /**
     * Filter, which MoveDamageClass to fetch.
     */
    where: MoveDamageClassWhereUniqueInput
  }

  /**
   * MoveDamageClass findFirst
   */
  export type MoveDamageClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveDamageClass
     */
    select?: MoveDamageClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveDamageClass
     */
    omit?: MoveDamageClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveDamageClassInclude<ExtArgs> | null
    /**
     * Filter, which MoveDamageClass to fetch.
     */
    where?: MoveDamageClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoveDamageClasses to fetch.
     */
    orderBy?: MoveDamageClassOrderByWithRelationInput | MoveDamageClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MoveDamageClasses.
     */
    cursor?: MoveDamageClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoveDamageClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoveDamageClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MoveDamageClasses.
     */
    distinct?: MoveDamageClassScalarFieldEnum | MoveDamageClassScalarFieldEnum[]
  }

  /**
   * MoveDamageClass findFirstOrThrow
   */
  export type MoveDamageClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveDamageClass
     */
    select?: MoveDamageClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveDamageClass
     */
    omit?: MoveDamageClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveDamageClassInclude<ExtArgs> | null
    /**
     * Filter, which MoveDamageClass to fetch.
     */
    where?: MoveDamageClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoveDamageClasses to fetch.
     */
    orderBy?: MoveDamageClassOrderByWithRelationInput | MoveDamageClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MoveDamageClasses.
     */
    cursor?: MoveDamageClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoveDamageClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoveDamageClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MoveDamageClasses.
     */
    distinct?: MoveDamageClassScalarFieldEnum | MoveDamageClassScalarFieldEnum[]
  }

  /**
   * MoveDamageClass findMany
   */
  export type MoveDamageClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveDamageClass
     */
    select?: MoveDamageClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveDamageClass
     */
    omit?: MoveDamageClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveDamageClassInclude<ExtArgs> | null
    /**
     * Filter, which MoveDamageClasses to fetch.
     */
    where?: MoveDamageClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoveDamageClasses to fetch.
     */
    orderBy?: MoveDamageClassOrderByWithRelationInput | MoveDamageClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MoveDamageClasses.
     */
    cursor?: MoveDamageClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoveDamageClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoveDamageClasses.
     */
    skip?: number
    distinct?: MoveDamageClassScalarFieldEnum | MoveDamageClassScalarFieldEnum[]
  }

  /**
   * MoveDamageClass create
   */
  export type MoveDamageClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveDamageClass
     */
    select?: MoveDamageClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveDamageClass
     */
    omit?: MoveDamageClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveDamageClassInclude<ExtArgs> | null
    /**
     * The data needed to create a MoveDamageClass.
     */
    data: XOR<MoveDamageClassCreateInput, MoveDamageClassUncheckedCreateInput>
  }

  /**
   * MoveDamageClass createMany
   */
  export type MoveDamageClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MoveDamageClasses.
     */
    data: MoveDamageClassCreateManyInput | MoveDamageClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MoveDamageClass createManyAndReturn
   */
  export type MoveDamageClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveDamageClass
     */
    select?: MoveDamageClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MoveDamageClass
     */
    omit?: MoveDamageClassOmit<ExtArgs> | null
    /**
     * The data used to create many MoveDamageClasses.
     */
    data: MoveDamageClassCreateManyInput | MoveDamageClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MoveDamageClass update
   */
  export type MoveDamageClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveDamageClass
     */
    select?: MoveDamageClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveDamageClass
     */
    omit?: MoveDamageClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveDamageClassInclude<ExtArgs> | null
    /**
     * The data needed to update a MoveDamageClass.
     */
    data: XOR<MoveDamageClassUpdateInput, MoveDamageClassUncheckedUpdateInput>
    /**
     * Choose, which MoveDamageClass to update.
     */
    where: MoveDamageClassWhereUniqueInput
  }

  /**
   * MoveDamageClass updateMany
   */
  export type MoveDamageClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MoveDamageClasses.
     */
    data: XOR<MoveDamageClassUpdateManyMutationInput, MoveDamageClassUncheckedUpdateManyInput>
    /**
     * Filter which MoveDamageClasses to update
     */
    where?: MoveDamageClassWhereInput
    /**
     * Limit how many MoveDamageClasses to update.
     */
    limit?: number
  }

  /**
   * MoveDamageClass updateManyAndReturn
   */
  export type MoveDamageClassUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveDamageClass
     */
    select?: MoveDamageClassSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MoveDamageClass
     */
    omit?: MoveDamageClassOmit<ExtArgs> | null
    /**
     * The data used to update MoveDamageClasses.
     */
    data: XOR<MoveDamageClassUpdateManyMutationInput, MoveDamageClassUncheckedUpdateManyInput>
    /**
     * Filter which MoveDamageClasses to update
     */
    where?: MoveDamageClassWhereInput
    /**
     * Limit how many MoveDamageClasses to update.
     */
    limit?: number
  }

  /**
   * MoveDamageClass upsert
   */
  export type MoveDamageClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveDamageClass
     */
    select?: MoveDamageClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveDamageClass
     */
    omit?: MoveDamageClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveDamageClassInclude<ExtArgs> | null
    /**
     * The filter to search for the MoveDamageClass to update in case it exists.
     */
    where: MoveDamageClassWhereUniqueInput
    /**
     * In case the MoveDamageClass found by the `where` argument doesn't exist, create a new MoveDamageClass with this data.
     */
    create: XOR<MoveDamageClassCreateInput, MoveDamageClassUncheckedCreateInput>
    /**
     * In case the MoveDamageClass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MoveDamageClassUpdateInput, MoveDamageClassUncheckedUpdateInput>
  }

  /**
   * MoveDamageClass delete
   */
  export type MoveDamageClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveDamageClass
     */
    select?: MoveDamageClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveDamageClass
     */
    omit?: MoveDamageClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveDamageClassInclude<ExtArgs> | null
    /**
     * Filter which MoveDamageClass to delete.
     */
    where: MoveDamageClassWhereUniqueInput
  }

  /**
   * MoveDamageClass deleteMany
   */
  export type MoveDamageClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MoveDamageClasses to delete
     */
    where?: MoveDamageClassWhereInput
    /**
     * Limit how many MoveDamageClasses to delete.
     */
    limit?: number
  }

  /**
   * MoveDamageClass.moves
   */
  export type MoveDamageClass$movesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    where?: MoveWhereInput
    orderBy?: MoveOrderByWithRelationInput | MoveOrderByWithRelationInput[]
    cursor?: MoveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MoveScalarFieldEnum | MoveScalarFieldEnum[]
  }

  /**
   * MoveDamageClass without action
   */
  export type MoveDamageClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveDamageClass
     */
    select?: MoveDamageClassSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveDamageClass
     */
    omit?: MoveDamageClassOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveDamageClassInclude<ExtArgs> | null
  }


  /**
   * Model MoveEffect
   */

  export type AggregateMoveEffect = {
    _count: MoveEffectCountAggregateOutputType | null
    _avg: MoveEffectAvgAggregateOutputType | null
    _sum: MoveEffectSumAggregateOutputType | null
    _min: MoveEffectMinAggregateOutputType | null
    _max: MoveEffectMaxAggregateOutputType | null
  }

  export type MoveEffectAvgAggregateOutputType = {
    id: number | null
  }

  export type MoveEffectSumAggregateOutputType = {
    id: number | null
  }

  export type MoveEffectMinAggregateOutputType = {
    id: number | null
    description: string | null
  }

  export type MoveEffectMaxAggregateOutputType = {
    id: number | null
    description: string | null
  }

  export type MoveEffectCountAggregateOutputType = {
    id: number
    description: number
    _all: number
  }


  export type MoveEffectAvgAggregateInputType = {
    id?: true
  }

  export type MoveEffectSumAggregateInputType = {
    id?: true
  }

  export type MoveEffectMinAggregateInputType = {
    id?: true
    description?: true
  }

  export type MoveEffectMaxAggregateInputType = {
    id?: true
    description?: true
  }

  export type MoveEffectCountAggregateInputType = {
    id?: true
    description?: true
    _all?: true
  }

  export type MoveEffectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MoveEffect to aggregate.
     */
    where?: MoveEffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoveEffects to fetch.
     */
    orderBy?: MoveEffectOrderByWithRelationInput | MoveEffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MoveEffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoveEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoveEffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MoveEffects
    **/
    _count?: true | MoveEffectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MoveEffectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MoveEffectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MoveEffectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MoveEffectMaxAggregateInputType
  }

  export type GetMoveEffectAggregateType<T extends MoveEffectAggregateArgs> = {
        [P in keyof T & keyof AggregateMoveEffect]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMoveEffect[P]>
      : GetScalarType<T[P], AggregateMoveEffect[P]>
  }




  export type MoveEffectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoveEffectWhereInput
    orderBy?: MoveEffectOrderByWithAggregationInput | MoveEffectOrderByWithAggregationInput[]
    by: MoveEffectScalarFieldEnum[] | MoveEffectScalarFieldEnum
    having?: MoveEffectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MoveEffectCountAggregateInputType | true
    _avg?: MoveEffectAvgAggregateInputType
    _sum?: MoveEffectSumAggregateInputType
    _min?: MoveEffectMinAggregateInputType
    _max?: MoveEffectMaxAggregateInputType
  }

  export type MoveEffectGroupByOutputType = {
    id: number
    description: string
    _count: MoveEffectCountAggregateOutputType | null
    _avg: MoveEffectAvgAggregateOutputType | null
    _sum: MoveEffectSumAggregateOutputType | null
    _min: MoveEffectMinAggregateOutputType | null
    _max: MoveEffectMaxAggregateOutputType | null
  }

  type GetMoveEffectGroupByPayload<T extends MoveEffectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MoveEffectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MoveEffectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MoveEffectGroupByOutputType[P]>
            : GetScalarType<T[P], MoveEffectGroupByOutputType[P]>
        }
      >
    >


  export type MoveEffectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    moves?: boolean | MoveEffect$movesArgs<ExtArgs>
    _count?: boolean | MoveEffectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moveEffect"]>

  export type MoveEffectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
  }, ExtArgs["result"]["moveEffect"]>

  export type MoveEffectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
  }, ExtArgs["result"]["moveEffect"]>

  export type MoveEffectSelectScalar = {
    id?: boolean
    description?: boolean
  }

  export type MoveEffectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description", ExtArgs["result"]["moveEffect"]>
  export type MoveEffectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    moves?: boolean | MoveEffect$movesArgs<ExtArgs>
    _count?: boolean | MoveEffectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MoveEffectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MoveEffectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MoveEffectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MoveEffect"
    objects: {
      moves: Prisma.$MovePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      description: string
    }, ExtArgs["result"]["moveEffect"]>
    composites: {}
  }

  type MoveEffectGetPayload<S extends boolean | null | undefined | MoveEffectDefaultArgs> = $Result.GetResult<Prisma.$MoveEffectPayload, S>

  type MoveEffectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MoveEffectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MoveEffectCountAggregateInputType | true
    }

  export interface MoveEffectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MoveEffect'], meta: { name: 'MoveEffect' } }
    /**
     * Find zero or one MoveEffect that matches the filter.
     * @param {MoveEffectFindUniqueArgs} args - Arguments to find a MoveEffect
     * @example
     * // Get one MoveEffect
     * const moveEffect = await prisma.moveEffect.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MoveEffectFindUniqueArgs>(args: SelectSubset<T, MoveEffectFindUniqueArgs<ExtArgs>>): Prisma__MoveEffectClient<$Result.GetResult<Prisma.$MoveEffectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MoveEffect that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MoveEffectFindUniqueOrThrowArgs} args - Arguments to find a MoveEffect
     * @example
     * // Get one MoveEffect
     * const moveEffect = await prisma.moveEffect.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MoveEffectFindUniqueOrThrowArgs>(args: SelectSubset<T, MoveEffectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MoveEffectClient<$Result.GetResult<Prisma.$MoveEffectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MoveEffect that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveEffectFindFirstArgs} args - Arguments to find a MoveEffect
     * @example
     * // Get one MoveEffect
     * const moveEffect = await prisma.moveEffect.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MoveEffectFindFirstArgs>(args?: SelectSubset<T, MoveEffectFindFirstArgs<ExtArgs>>): Prisma__MoveEffectClient<$Result.GetResult<Prisma.$MoveEffectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MoveEffect that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveEffectFindFirstOrThrowArgs} args - Arguments to find a MoveEffect
     * @example
     * // Get one MoveEffect
     * const moveEffect = await prisma.moveEffect.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MoveEffectFindFirstOrThrowArgs>(args?: SelectSubset<T, MoveEffectFindFirstOrThrowArgs<ExtArgs>>): Prisma__MoveEffectClient<$Result.GetResult<Prisma.$MoveEffectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MoveEffects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveEffectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MoveEffects
     * const moveEffects = await prisma.moveEffect.findMany()
     * 
     * // Get first 10 MoveEffects
     * const moveEffects = await prisma.moveEffect.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moveEffectWithIdOnly = await prisma.moveEffect.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MoveEffectFindManyArgs>(args?: SelectSubset<T, MoveEffectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoveEffectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MoveEffect.
     * @param {MoveEffectCreateArgs} args - Arguments to create a MoveEffect.
     * @example
     * // Create one MoveEffect
     * const MoveEffect = await prisma.moveEffect.create({
     *   data: {
     *     // ... data to create a MoveEffect
     *   }
     * })
     * 
     */
    create<T extends MoveEffectCreateArgs>(args: SelectSubset<T, MoveEffectCreateArgs<ExtArgs>>): Prisma__MoveEffectClient<$Result.GetResult<Prisma.$MoveEffectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MoveEffects.
     * @param {MoveEffectCreateManyArgs} args - Arguments to create many MoveEffects.
     * @example
     * // Create many MoveEffects
     * const moveEffect = await prisma.moveEffect.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MoveEffectCreateManyArgs>(args?: SelectSubset<T, MoveEffectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MoveEffects and returns the data saved in the database.
     * @param {MoveEffectCreateManyAndReturnArgs} args - Arguments to create many MoveEffects.
     * @example
     * // Create many MoveEffects
     * const moveEffect = await prisma.moveEffect.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MoveEffects and only return the `id`
     * const moveEffectWithIdOnly = await prisma.moveEffect.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MoveEffectCreateManyAndReturnArgs>(args?: SelectSubset<T, MoveEffectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoveEffectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MoveEffect.
     * @param {MoveEffectDeleteArgs} args - Arguments to delete one MoveEffect.
     * @example
     * // Delete one MoveEffect
     * const MoveEffect = await prisma.moveEffect.delete({
     *   where: {
     *     // ... filter to delete one MoveEffect
     *   }
     * })
     * 
     */
    delete<T extends MoveEffectDeleteArgs>(args: SelectSubset<T, MoveEffectDeleteArgs<ExtArgs>>): Prisma__MoveEffectClient<$Result.GetResult<Prisma.$MoveEffectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MoveEffect.
     * @param {MoveEffectUpdateArgs} args - Arguments to update one MoveEffect.
     * @example
     * // Update one MoveEffect
     * const moveEffect = await prisma.moveEffect.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MoveEffectUpdateArgs>(args: SelectSubset<T, MoveEffectUpdateArgs<ExtArgs>>): Prisma__MoveEffectClient<$Result.GetResult<Prisma.$MoveEffectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MoveEffects.
     * @param {MoveEffectDeleteManyArgs} args - Arguments to filter MoveEffects to delete.
     * @example
     * // Delete a few MoveEffects
     * const { count } = await prisma.moveEffect.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MoveEffectDeleteManyArgs>(args?: SelectSubset<T, MoveEffectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MoveEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveEffectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MoveEffects
     * const moveEffect = await prisma.moveEffect.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MoveEffectUpdateManyArgs>(args: SelectSubset<T, MoveEffectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MoveEffects and returns the data updated in the database.
     * @param {MoveEffectUpdateManyAndReturnArgs} args - Arguments to update many MoveEffects.
     * @example
     * // Update many MoveEffects
     * const moveEffect = await prisma.moveEffect.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MoveEffects and only return the `id`
     * const moveEffectWithIdOnly = await prisma.moveEffect.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MoveEffectUpdateManyAndReturnArgs>(args: SelectSubset<T, MoveEffectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoveEffectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MoveEffect.
     * @param {MoveEffectUpsertArgs} args - Arguments to update or create a MoveEffect.
     * @example
     * // Update or create a MoveEffect
     * const moveEffect = await prisma.moveEffect.upsert({
     *   create: {
     *     // ... data to create a MoveEffect
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MoveEffect we want to update
     *   }
     * })
     */
    upsert<T extends MoveEffectUpsertArgs>(args: SelectSubset<T, MoveEffectUpsertArgs<ExtArgs>>): Prisma__MoveEffectClient<$Result.GetResult<Prisma.$MoveEffectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MoveEffects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveEffectCountArgs} args - Arguments to filter MoveEffects to count.
     * @example
     * // Count the number of MoveEffects
     * const count = await prisma.moveEffect.count({
     *   where: {
     *     // ... the filter for the MoveEffects we want to count
     *   }
     * })
    **/
    count<T extends MoveEffectCountArgs>(
      args?: Subset<T, MoveEffectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MoveEffectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MoveEffect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveEffectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MoveEffectAggregateArgs>(args: Subset<T, MoveEffectAggregateArgs>): Prisma.PrismaPromise<GetMoveEffectAggregateType<T>>

    /**
     * Group by MoveEffect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveEffectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MoveEffectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MoveEffectGroupByArgs['orderBy'] }
        : { orderBy?: MoveEffectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MoveEffectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMoveEffectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MoveEffect model
   */
  readonly fields: MoveEffectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MoveEffect.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MoveEffectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    moves<T extends MoveEffect$movesArgs<ExtArgs> = {}>(args?: Subset<T, MoveEffect$movesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MoveEffect model
   */
  interface MoveEffectFieldRefs {
    readonly id: FieldRef<"MoveEffect", 'Int'>
    readonly description: FieldRef<"MoveEffect", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MoveEffect findUnique
   */
  export type MoveEffectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveEffect
     */
    select?: MoveEffectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveEffect
     */
    omit?: MoveEffectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveEffectInclude<ExtArgs> | null
    /**
     * Filter, which MoveEffect to fetch.
     */
    where: MoveEffectWhereUniqueInput
  }

  /**
   * MoveEffect findUniqueOrThrow
   */
  export type MoveEffectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveEffect
     */
    select?: MoveEffectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveEffect
     */
    omit?: MoveEffectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveEffectInclude<ExtArgs> | null
    /**
     * Filter, which MoveEffect to fetch.
     */
    where: MoveEffectWhereUniqueInput
  }

  /**
   * MoveEffect findFirst
   */
  export type MoveEffectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveEffect
     */
    select?: MoveEffectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveEffect
     */
    omit?: MoveEffectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveEffectInclude<ExtArgs> | null
    /**
     * Filter, which MoveEffect to fetch.
     */
    where?: MoveEffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoveEffects to fetch.
     */
    orderBy?: MoveEffectOrderByWithRelationInput | MoveEffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MoveEffects.
     */
    cursor?: MoveEffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoveEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoveEffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MoveEffects.
     */
    distinct?: MoveEffectScalarFieldEnum | MoveEffectScalarFieldEnum[]
  }

  /**
   * MoveEffect findFirstOrThrow
   */
  export type MoveEffectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveEffect
     */
    select?: MoveEffectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveEffect
     */
    omit?: MoveEffectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveEffectInclude<ExtArgs> | null
    /**
     * Filter, which MoveEffect to fetch.
     */
    where?: MoveEffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoveEffects to fetch.
     */
    orderBy?: MoveEffectOrderByWithRelationInput | MoveEffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MoveEffects.
     */
    cursor?: MoveEffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoveEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoveEffects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MoveEffects.
     */
    distinct?: MoveEffectScalarFieldEnum | MoveEffectScalarFieldEnum[]
  }

  /**
   * MoveEffect findMany
   */
  export type MoveEffectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveEffect
     */
    select?: MoveEffectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveEffect
     */
    omit?: MoveEffectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveEffectInclude<ExtArgs> | null
    /**
     * Filter, which MoveEffects to fetch.
     */
    where?: MoveEffectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoveEffects to fetch.
     */
    orderBy?: MoveEffectOrderByWithRelationInput | MoveEffectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MoveEffects.
     */
    cursor?: MoveEffectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoveEffects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoveEffects.
     */
    skip?: number
    distinct?: MoveEffectScalarFieldEnum | MoveEffectScalarFieldEnum[]
  }

  /**
   * MoveEffect create
   */
  export type MoveEffectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveEffect
     */
    select?: MoveEffectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveEffect
     */
    omit?: MoveEffectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveEffectInclude<ExtArgs> | null
    /**
     * The data needed to create a MoveEffect.
     */
    data: XOR<MoveEffectCreateInput, MoveEffectUncheckedCreateInput>
  }

  /**
   * MoveEffect createMany
   */
  export type MoveEffectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MoveEffects.
     */
    data: MoveEffectCreateManyInput | MoveEffectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MoveEffect createManyAndReturn
   */
  export type MoveEffectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveEffect
     */
    select?: MoveEffectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MoveEffect
     */
    omit?: MoveEffectOmit<ExtArgs> | null
    /**
     * The data used to create many MoveEffects.
     */
    data: MoveEffectCreateManyInput | MoveEffectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MoveEffect update
   */
  export type MoveEffectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveEffect
     */
    select?: MoveEffectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveEffect
     */
    omit?: MoveEffectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveEffectInclude<ExtArgs> | null
    /**
     * The data needed to update a MoveEffect.
     */
    data: XOR<MoveEffectUpdateInput, MoveEffectUncheckedUpdateInput>
    /**
     * Choose, which MoveEffect to update.
     */
    where: MoveEffectWhereUniqueInput
  }

  /**
   * MoveEffect updateMany
   */
  export type MoveEffectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MoveEffects.
     */
    data: XOR<MoveEffectUpdateManyMutationInput, MoveEffectUncheckedUpdateManyInput>
    /**
     * Filter which MoveEffects to update
     */
    where?: MoveEffectWhereInput
    /**
     * Limit how many MoveEffects to update.
     */
    limit?: number
  }

  /**
   * MoveEffect updateManyAndReturn
   */
  export type MoveEffectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveEffect
     */
    select?: MoveEffectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MoveEffect
     */
    omit?: MoveEffectOmit<ExtArgs> | null
    /**
     * The data used to update MoveEffects.
     */
    data: XOR<MoveEffectUpdateManyMutationInput, MoveEffectUncheckedUpdateManyInput>
    /**
     * Filter which MoveEffects to update
     */
    where?: MoveEffectWhereInput
    /**
     * Limit how many MoveEffects to update.
     */
    limit?: number
  }

  /**
   * MoveEffect upsert
   */
  export type MoveEffectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveEffect
     */
    select?: MoveEffectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveEffect
     */
    omit?: MoveEffectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveEffectInclude<ExtArgs> | null
    /**
     * The filter to search for the MoveEffect to update in case it exists.
     */
    where: MoveEffectWhereUniqueInput
    /**
     * In case the MoveEffect found by the `where` argument doesn't exist, create a new MoveEffect with this data.
     */
    create: XOR<MoveEffectCreateInput, MoveEffectUncheckedCreateInput>
    /**
     * In case the MoveEffect was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MoveEffectUpdateInput, MoveEffectUncheckedUpdateInput>
  }

  /**
   * MoveEffect delete
   */
  export type MoveEffectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveEffect
     */
    select?: MoveEffectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveEffect
     */
    omit?: MoveEffectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveEffectInclude<ExtArgs> | null
    /**
     * Filter which MoveEffect to delete.
     */
    where: MoveEffectWhereUniqueInput
  }

  /**
   * MoveEffect deleteMany
   */
  export type MoveEffectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MoveEffects to delete
     */
    where?: MoveEffectWhereInput
    /**
     * Limit how many MoveEffects to delete.
     */
    limit?: number
  }

  /**
   * MoveEffect.moves
   */
  export type MoveEffect$movesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    where?: MoveWhereInput
    orderBy?: MoveOrderByWithRelationInput | MoveOrderByWithRelationInput[]
    cursor?: MoveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MoveScalarFieldEnum | MoveScalarFieldEnum[]
  }

  /**
   * MoveEffect without action
   */
  export type MoveEffectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveEffect
     */
    select?: MoveEffectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveEffect
     */
    omit?: MoveEffectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveEffectInclude<ExtArgs> | null
  }


  /**
   * Model MoveMethod
   */

  export type AggregateMoveMethod = {
    _count: MoveMethodCountAggregateOutputType | null
    _avg: MoveMethodAvgAggregateOutputType | null
    _sum: MoveMethodSumAggregateOutputType | null
    _min: MoveMethodMinAggregateOutputType | null
    _max: MoveMethodMaxAggregateOutputType | null
  }

  export type MoveMethodAvgAggregateOutputType = {
    id: number | null
  }

  export type MoveMethodSumAggregateOutputType = {
    id: number | null
  }

  export type MoveMethodMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type MoveMethodMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type MoveMethodCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type MoveMethodAvgAggregateInputType = {
    id?: true
  }

  export type MoveMethodSumAggregateInputType = {
    id?: true
  }

  export type MoveMethodMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type MoveMethodMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type MoveMethodCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type MoveMethodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MoveMethod to aggregate.
     */
    where?: MoveMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoveMethods to fetch.
     */
    orderBy?: MoveMethodOrderByWithRelationInput | MoveMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MoveMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoveMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoveMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MoveMethods
    **/
    _count?: true | MoveMethodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MoveMethodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MoveMethodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MoveMethodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MoveMethodMaxAggregateInputType
  }

  export type GetMoveMethodAggregateType<T extends MoveMethodAggregateArgs> = {
        [P in keyof T & keyof AggregateMoveMethod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMoveMethod[P]>
      : GetScalarType<T[P], AggregateMoveMethod[P]>
  }




  export type MoveMethodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoveMethodWhereInput
    orderBy?: MoveMethodOrderByWithAggregationInput | MoveMethodOrderByWithAggregationInput[]
    by: MoveMethodScalarFieldEnum[] | MoveMethodScalarFieldEnum
    having?: MoveMethodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MoveMethodCountAggregateInputType | true
    _avg?: MoveMethodAvgAggregateInputType
    _sum?: MoveMethodSumAggregateInputType
    _min?: MoveMethodMinAggregateInputType
    _max?: MoveMethodMaxAggregateInputType
  }

  export type MoveMethodGroupByOutputType = {
    id: number
    name: string
    _count: MoveMethodCountAggregateOutputType | null
    _avg: MoveMethodAvgAggregateOutputType | null
    _sum: MoveMethodSumAggregateOutputType | null
    _min: MoveMethodMinAggregateOutputType | null
    _max: MoveMethodMaxAggregateOutputType | null
  }

  type GetMoveMethodGroupByPayload<T extends MoveMethodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MoveMethodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MoveMethodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MoveMethodGroupByOutputType[P]>
            : GetScalarType<T[P], MoveMethodGroupByOutputType[P]>
        }
      >
    >


  export type MoveMethodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    moves?: boolean | MoveMethod$movesArgs<ExtArgs>
    _count?: boolean | MoveMethodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moveMethod"]>

  export type MoveMethodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["moveMethod"]>

  export type MoveMethodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["moveMethod"]>

  export type MoveMethodSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type MoveMethodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["moveMethod"]>
  export type MoveMethodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    moves?: boolean | MoveMethod$movesArgs<ExtArgs>
    _count?: boolean | MoveMethodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MoveMethodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MoveMethodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MoveMethodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MoveMethod"
    objects: {
      moves: Prisma.$PokemonMovePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["moveMethod"]>
    composites: {}
  }

  type MoveMethodGetPayload<S extends boolean | null | undefined | MoveMethodDefaultArgs> = $Result.GetResult<Prisma.$MoveMethodPayload, S>

  type MoveMethodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MoveMethodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MoveMethodCountAggregateInputType | true
    }

  export interface MoveMethodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MoveMethod'], meta: { name: 'MoveMethod' } }
    /**
     * Find zero or one MoveMethod that matches the filter.
     * @param {MoveMethodFindUniqueArgs} args - Arguments to find a MoveMethod
     * @example
     * // Get one MoveMethod
     * const moveMethod = await prisma.moveMethod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MoveMethodFindUniqueArgs>(args: SelectSubset<T, MoveMethodFindUniqueArgs<ExtArgs>>): Prisma__MoveMethodClient<$Result.GetResult<Prisma.$MoveMethodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MoveMethod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MoveMethodFindUniqueOrThrowArgs} args - Arguments to find a MoveMethod
     * @example
     * // Get one MoveMethod
     * const moveMethod = await prisma.moveMethod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MoveMethodFindUniqueOrThrowArgs>(args: SelectSubset<T, MoveMethodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MoveMethodClient<$Result.GetResult<Prisma.$MoveMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MoveMethod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveMethodFindFirstArgs} args - Arguments to find a MoveMethod
     * @example
     * // Get one MoveMethod
     * const moveMethod = await prisma.moveMethod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MoveMethodFindFirstArgs>(args?: SelectSubset<T, MoveMethodFindFirstArgs<ExtArgs>>): Prisma__MoveMethodClient<$Result.GetResult<Prisma.$MoveMethodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MoveMethod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveMethodFindFirstOrThrowArgs} args - Arguments to find a MoveMethod
     * @example
     * // Get one MoveMethod
     * const moveMethod = await prisma.moveMethod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MoveMethodFindFirstOrThrowArgs>(args?: SelectSubset<T, MoveMethodFindFirstOrThrowArgs<ExtArgs>>): Prisma__MoveMethodClient<$Result.GetResult<Prisma.$MoveMethodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MoveMethods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveMethodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MoveMethods
     * const moveMethods = await prisma.moveMethod.findMany()
     * 
     * // Get first 10 MoveMethods
     * const moveMethods = await prisma.moveMethod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moveMethodWithIdOnly = await prisma.moveMethod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MoveMethodFindManyArgs>(args?: SelectSubset<T, MoveMethodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoveMethodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MoveMethod.
     * @param {MoveMethodCreateArgs} args - Arguments to create a MoveMethod.
     * @example
     * // Create one MoveMethod
     * const MoveMethod = await prisma.moveMethod.create({
     *   data: {
     *     // ... data to create a MoveMethod
     *   }
     * })
     * 
     */
    create<T extends MoveMethodCreateArgs>(args: SelectSubset<T, MoveMethodCreateArgs<ExtArgs>>): Prisma__MoveMethodClient<$Result.GetResult<Prisma.$MoveMethodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MoveMethods.
     * @param {MoveMethodCreateManyArgs} args - Arguments to create many MoveMethods.
     * @example
     * // Create many MoveMethods
     * const moveMethod = await prisma.moveMethod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MoveMethodCreateManyArgs>(args?: SelectSubset<T, MoveMethodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MoveMethods and returns the data saved in the database.
     * @param {MoveMethodCreateManyAndReturnArgs} args - Arguments to create many MoveMethods.
     * @example
     * // Create many MoveMethods
     * const moveMethod = await prisma.moveMethod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MoveMethods and only return the `id`
     * const moveMethodWithIdOnly = await prisma.moveMethod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MoveMethodCreateManyAndReturnArgs>(args?: SelectSubset<T, MoveMethodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoveMethodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MoveMethod.
     * @param {MoveMethodDeleteArgs} args - Arguments to delete one MoveMethod.
     * @example
     * // Delete one MoveMethod
     * const MoveMethod = await prisma.moveMethod.delete({
     *   where: {
     *     // ... filter to delete one MoveMethod
     *   }
     * })
     * 
     */
    delete<T extends MoveMethodDeleteArgs>(args: SelectSubset<T, MoveMethodDeleteArgs<ExtArgs>>): Prisma__MoveMethodClient<$Result.GetResult<Prisma.$MoveMethodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MoveMethod.
     * @param {MoveMethodUpdateArgs} args - Arguments to update one MoveMethod.
     * @example
     * // Update one MoveMethod
     * const moveMethod = await prisma.moveMethod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MoveMethodUpdateArgs>(args: SelectSubset<T, MoveMethodUpdateArgs<ExtArgs>>): Prisma__MoveMethodClient<$Result.GetResult<Prisma.$MoveMethodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MoveMethods.
     * @param {MoveMethodDeleteManyArgs} args - Arguments to filter MoveMethods to delete.
     * @example
     * // Delete a few MoveMethods
     * const { count } = await prisma.moveMethod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MoveMethodDeleteManyArgs>(args?: SelectSubset<T, MoveMethodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MoveMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveMethodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MoveMethods
     * const moveMethod = await prisma.moveMethod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MoveMethodUpdateManyArgs>(args: SelectSubset<T, MoveMethodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MoveMethods and returns the data updated in the database.
     * @param {MoveMethodUpdateManyAndReturnArgs} args - Arguments to update many MoveMethods.
     * @example
     * // Update many MoveMethods
     * const moveMethod = await prisma.moveMethod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MoveMethods and only return the `id`
     * const moveMethodWithIdOnly = await prisma.moveMethod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MoveMethodUpdateManyAndReturnArgs>(args: SelectSubset<T, MoveMethodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MoveMethodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MoveMethod.
     * @param {MoveMethodUpsertArgs} args - Arguments to update or create a MoveMethod.
     * @example
     * // Update or create a MoveMethod
     * const moveMethod = await prisma.moveMethod.upsert({
     *   create: {
     *     // ... data to create a MoveMethod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MoveMethod we want to update
     *   }
     * })
     */
    upsert<T extends MoveMethodUpsertArgs>(args: SelectSubset<T, MoveMethodUpsertArgs<ExtArgs>>): Prisma__MoveMethodClient<$Result.GetResult<Prisma.$MoveMethodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MoveMethods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveMethodCountArgs} args - Arguments to filter MoveMethods to count.
     * @example
     * // Count the number of MoveMethods
     * const count = await prisma.moveMethod.count({
     *   where: {
     *     // ... the filter for the MoveMethods we want to count
     *   }
     * })
    **/
    count<T extends MoveMethodCountArgs>(
      args?: Subset<T, MoveMethodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MoveMethodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MoveMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveMethodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MoveMethodAggregateArgs>(args: Subset<T, MoveMethodAggregateArgs>): Prisma.PrismaPromise<GetMoveMethodAggregateType<T>>

    /**
     * Group by MoveMethod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveMethodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MoveMethodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MoveMethodGroupByArgs['orderBy'] }
        : { orderBy?: MoveMethodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MoveMethodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMoveMethodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MoveMethod model
   */
  readonly fields: MoveMethodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MoveMethod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MoveMethodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    moves<T extends MoveMethod$movesArgs<ExtArgs> = {}>(args?: Subset<T, MoveMethod$movesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonMovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MoveMethod model
   */
  interface MoveMethodFieldRefs {
    readonly id: FieldRef<"MoveMethod", 'Int'>
    readonly name: FieldRef<"MoveMethod", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MoveMethod findUnique
   */
  export type MoveMethodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveMethod
     */
    select?: MoveMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveMethod
     */
    omit?: MoveMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveMethodInclude<ExtArgs> | null
    /**
     * Filter, which MoveMethod to fetch.
     */
    where: MoveMethodWhereUniqueInput
  }

  /**
   * MoveMethod findUniqueOrThrow
   */
  export type MoveMethodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveMethod
     */
    select?: MoveMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveMethod
     */
    omit?: MoveMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveMethodInclude<ExtArgs> | null
    /**
     * Filter, which MoveMethod to fetch.
     */
    where: MoveMethodWhereUniqueInput
  }

  /**
   * MoveMethod findFirst
   */
  export type MoveMethodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveMethod
     */
    select?: MoveMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveMethod
     */
    omit?: MoveMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveMethodInclude<ExtArgs> | null
    /**
     * Filter, which MoveMethod to fetch.
     */
    where?: MoveMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoveMethods to fetch.
     */
    orderBy?: MoveMethodOrderByWithRelationInput | MoveMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MoveMethods.
     */
    cursor?: MoveMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoveMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoveMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MoveMethods.
     */
    distinct?: MoveMethodScalarFieldEnum | MoveMethodScalarFieldEnum[]
  }

  /**
   * MoveMethod findFirstOrThrow
   */
  export type MoveMethodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveMethod
     */
    select?: MoveMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveMethod
     */
    omit?: MoveMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveMethodInclude<ExtArgs> | null
    /**
     * Filter, which MoveMethod to fetch.
     */
    where?: MoveMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoveMethods to fetch.
     */
    orderBy?: MoveMethodOrderByWithRelationInput | MoveMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MoveMethods.
     */
    cursor?: MoveMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoveMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoveMethods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MoveMethods.
     */
    distinct?: MoveMethodScalarFieldEnum | MoveMethodScalarFieldEnum[]
  }

  /**
   * MoveMethod findMany
   */
  export type MoveMethodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveMethod
     */
    select?: MoveMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveMethod
     */
    omit?: MoveMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveMethodInclude<ExtArgs> | null
    /**
     * Filter, which MoveMethods to fetch.
     */
    where?: MoveMethodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MoveMethods to fetch.
     */
    orderBy?: MoveMethodOrderByWithRelationInput | MoveMethodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MoveMethods.
     */
    cursor?: MoveMethodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MoveMethods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MoveMethods.
     */
    skip?: number
    distinct?: MoveMethodScalarFieldEnum | MoveMethodScalarFieldEnum[]
  }

  /**
   * MoveMethod create
   */
  export type MoveMethodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveMethod
     */
    select?: MoveMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveMethod
     */
    omit?: MoveMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveMethodInclude<ExtArgs> | null
    /**
     * The data needed to create a MoveMethod.
     */
    data: XOR<MoveMethodCreateInput, MoveMethodUncheckedCreateInput>
  }

  /**
   * MoveMethod createMany
   */
  export type MoveMethodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MoveMethods.
     */
    data: MoveMethodCreateManyInput | MoveMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MoveMethod createManyAndReturn
   */
  export type MoveMethodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveMethod
     */
    select?: MoveMethodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MoveMethod
     */
    omit?: MoveMethodOmit<ExtArgs> | null
    /**
     * The data used to create many MoveMethods.
     */
    data: MoveMethodCreateManyInput | MoveMethodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MoveMethod update
   */
  export type MoveMethodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveMethod
     */
    select?: MoveMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveMethod
     */
    omit?: MoveMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveMethodInclude<ExtArgs> | null
    /**
     * The data needed to update a MoveMethod.
     */
    data: XOR<MoveMethodUpdateInput, MoveMethodUncheckedUpdateInput>
    /**
     * Choose, which MoveMethod to update.
     */
    where: MoveMethodWhereUniqueInput
  }

  /**
   * MoveMethod updateMany
   */
  export type MoveMethodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MoveMethods.
     */
    data: XOR<MoveMethodUpdateManyMutationInput, MoveMethodUncheckedUpdateManyInput>
    /**
     * Filter which MoveMethods to update
     */
    where?: MoveMethodWhereInput
    /**
     * Limit how many MoveMethods to update.
     */
    limit?: number
  }

  /**
   * MoveMethod updateManyAndReturn
   */
  export type MoveMethodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveMethod
     */
    select?: MoveMethodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MoveMethod
     */
    omit?: MoveMethodOmit<ExtArgs> | null
    /**
     * The data used to update MoveMethods.
     */
    data: XOR<MoveMethodUpdateManyMutationInput, MoveMethodUncheckedUpdateManyInput>
    /**
     * Filter which MoveMethods to update
     */
    where?: MoveMethodWhereInput
    /**
     * Limit how many MoveMethods to update.
     */
    limit?: number
  }

  /**
   * MoveMethod upsert
   */
  export type MoveMethodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveMethod
     */
    select?: MoveMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveMethod
     */
    omit?: MoveMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveMethodInclude<ExtArgs> | null
    /**
     * The filter to search for the MoveMethod to update in case it exists.
     */
    where: MoveMethodWhereUniqueInput
    /**
     * In case the MoveMethod found by the `where` argument doesn't exist, create a new MoveMethod with this data.
     */
    create: XOR<MoveMethodCreateInput, MoveMethodUncheckedCreateInput>
    /**
     * In case the MoveMethod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MoveMethodUpdateInput, MoveMethodUncheckedUpdateInput>
  }

  /**
   * MoveMethod delete
   */
  export type MoveMethodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveMethod
     */
    select?: MoveMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveMethod
     */
    omit?: MoveMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveMethodInclude<ExtArgs> | null
    /**
     * Filter which MoveMethod to delete.
     */
    where: MoveMethodWhereUniqueInput
  }

  /**
   * MoveMethod deleteMany
   */
  export type MoveMethodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MoveMethods to delete
     */
    where?: MoveMethodWhereInput
    /**
     * Limit how many MoveMethods to delete.
     */
    limit?: number
  }

  /**
   * MoveMethod.moves
   */
  export type MoveMethod$movesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonMove
     */
    select?: PokemonMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonMove
     */
    omit?: PokemonMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonMoveInclude<ExtArgs> | null
    where?: PokemonMoveWhereInput
    orderBy?: PokemonMoveOrderByWithRelationInput | PokemonMoveOrderByWithRelationInput[]
    cursor?: PokemonMoveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokemonMoveScalarFieldEnum | PokemonMoveScalarFieldEnum[]
  }

  /**
   * MoveMethod without action
   */
  export type MoveMethodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MoveMethod
     */
    select?: MoveMethodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MoveMethod
     */
    omit?: MoveMethodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveMethodInclude<ExtArgs> | null
  }


  /**
   * Model Move
   */

  export type AggregateMove = {
    _count: MoveCountAggregateOutputType | null
    _avg: MoveAvgAggregateOutputType | null
    _sum: MoveSumAggregateOutputType | null
    _min: MoveMinAggregateOutputType | null
    _max: MoveMaxAggregateOutputType | null
  }

  export type MoveAvgAggregateOutputType = {
    id: number | null
    generation_id: number | null
    type_id: number | null
    pp: number | null
    accuracy: number | null
    priority: number | null
    move_damage_class_id: number | null
    move_effect_id: number | null
  }

  export type MoveSumAggregateOutputType = {
    id: number | null
    generation_id: number | null
    type_id: number | null
    pp: number | null
    accuracy: number | null
    priority: number | null
    move_damage_class_id: number | null
    move_effect_id: number | null
  }

  export type MoveMinAggregateOutputType = {
    id: number | null
    name: string | null
    generation_id: number | null
    type_id: number | null
    pp: number | null
    accuracy: number | null
    priority: number | null
    move_damage_class_id: number | null
    move_effect_id: number | null
  }

  export type MoveMaxAggregateOutputType = {
    id: number | null
    name: string | null
    generation_id: number | null
    type_id: number | null
    pp: number | null
    accuracy: number | null
    priority: number | null
    move_damage_class_id: number | null
    move_effect_id: number | null
  }

  export type MoveCountAggregateOutputType = {
    id: number
    name: number
    generation_id: number
    type_id: number
    pp: number
    accuracy: number
    priority: number
    move_damage_class_id: number
    move_effect_id: number
    _all: number
  }


  export type MoveAvgAggregateInputType = {
    id?: true
    generation_id?: true
    type_id?: true
    pp?: true
    accuracy?: true
    priority?: true
    move_damage_class_id?: true
    move_effect_id?: true
  }

  export type MoveSumAggregateInputType = {
    id?: true
    generation_id?: true
    type_id?: true
    pp?: true
    accuracy?: true
    priority?: true
    move_damage_class_id?: true
    move_effect_id?: true
  }

  export type MoveMinAggregateInputType = {
    id?: true
    name?: true
    generation_id?: true
    type_id?: true
    pp?: true
    accuracy?: true
    priority?: true
    move_damage_class_id?: true
    move_effect_id?: true
  }

  export type MoveMaxAggregateInputType = {
    id?: true
    name?: true
    generation_id?: true
    type_id?: true
    pp?: true
    accuracy?: true
    priority?: true
    move_damage_class_id?: true
    move_effect_id?: true
  }

  export type MoveCountAggregateInputType = {
    id?: true
    name?: true
    generation_id?: true
    type_id?: true
    pp?: true
    accuracy?: true
    priority?: true
    move_damage_class_id?: true
    move_effect_id?: true
    _all?: true
  }

  export type MoveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Move to aggregate.
     */
    where?: MoveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Moves to fetch.
     */
    orderBy?: MoveOrderByWithRelationInput | MoveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MoveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Moves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Moves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Moves
    **/
    _count?: true | MoveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MoveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MoveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MoveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MoveMaxAggregateInputType
  }

  export type GetMoveAggregateType<T extends MoveAggregateArgs> = {
        [P in keyof T & keyof AggregateMove]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMove[P]>
      : GetScalarType<T[P], AggregateMove[P]>
  }




  export type MoveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MoveWhereInput
    orderBy?: MoveOrderByWithAggregationInput | MoveOrderByWithAggregationInput[]
    by: MoveScalarFieldEnum[] | MoveScalarFieldEnum
    having?: MoveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MoveCountAggregateInputType | true
    _avg?: MoveAvgAggregateInputType
    _sum?: MoveSumAggregateInputType
    _min?: MoveMinAggregateInputType
    _max?: MoveMaxAggregateInputType
  }

  export type MoveGroupByOutputType = {
    id: number
    name: string
    generation_id: number
    type_id: number
    pp: number
    accuracy: number | null
    priority: number
    move_damage_class_id: number
    move_effect_id: number
    _count: MoveCountAggregateOutputType | null
    _avg: MoveAvgAggregateOutputType | null
    _sum: MoveSumAggregateOutputType | null
    _min: MoveMinAggregateOutputType | null
    _max: MoveMaxAggregateOutputType | null
  }

  type GetMoveGroupByPayload<T extends MoveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MoveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MoveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MoveGroupByOutputType[P]>
            : GetScalarType<T[P], MoveGroupByOutputType[P]>
        }
      >
    >


  export type MoveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    generation_id?: boolean
    type_id?: boolean
    pp?: boolean
    accuracy?: boolean
    priority?: boolean
    move_damage_class_id?: boolean
    move_effect_id?: boolean
    type?: boolean | TypeDefaultArgs<ExtArgs>
    damage_class?: boolean | MoveDamageClassDefaultArgs<ExtArgs>
    effect?: boolean | MoveEffectDefaultArgs<ExtArgs>
    pokemon_moves?: boolean | Move$pokemon_movesArgs<ExtArgs>
    _count?: boolean | MoveCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["move"]>

  export type MoveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    generation_id?: boolean
    type_id?: boolean
    pp?: boolean
    accuracy?: boolean
    priority?: boolean
    move_damage_class_id?: boolean
    move_effect_id?: boolean
    type?: boolean | TypeDefaultArgs<ExtArgs>
    damage_class?: boolean | MoveDamageClassDefaultArgs<ExtArgs>
    effect?: boolean | MoveEffectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["move"]>

  export type MoveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    generation_id?: boolean
    type_id?: boolean
    pp?: boolean
    accuracy?: boolean
    priority?: boolean
    move_damage_class_id?: boolean
    move_effect_id?: boolean
    type?: boolean | TypeDefaultArgs<ExtArgs>
    damage_class?: boolean | MoveDamageClassDefaultArgs<ExtArgs>
    effect?: boolean | MoveEffectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["move"]>

  export type MoveSelectScalar = {
    id?: boolean
    name?: boolean
    generation_id?: boolean
    type_id?: boolean
    pp?: boolean
    accuracy?: boolean
    priority?: boolean
    move_damage_class_id?: boolean
    move_effect_id?: boolean
  }

  export type MoveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "generation_id" | "type_id" | "pp" | "accuracy" | "priority" | "move_damage_class_id" | "move_effect_id", ExtArgs["result"]["move"]>
  export type MoveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    type?: boolean | TypeDefaultArgs<ExtArgs>
    damage_class?: boolean | MoveDamageClassDefaultArgs<ExtArgs>
    effect?: boolean | MoveEffectDefaultArgs<ExtArgs>
    pokemon_moves?: boolean | Move$pokemon_movesArgs<ExtArgs>
    _count?: boolean | MoveCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MoveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    type?: boolean | TypeDefaultArgs<ExtArgs>
    damage_class?: boolean | MoveDamageClassDefaultArgs<ExtArgs>
    effect?: boolean | MoveEffectDefaultArgs<ExtArgs>
  }
  export type MoveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    type?: boolean | TypeDefaultArgs<ExtArgs>
    damage_class?: boolean | MoveDamageClassDefaultArgs<ExtArgs>
    effect?: boolean | MoveEffectDefaultArgs<ExtArgs>
  }

  export type $MovePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Move"
    objects: {
      type: Prisma.$TypePayload<ExtArgs>
      damage_class: Prisma.$MoveDamageClassPayload<ExtArgs>
      effect: Prisma.$MoveEffectPayload<ExtArgs>
      pokemon_moves: Prisma.$PokemonMovePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      generation_id: number
      type_id: number
      pp: number
      accuracy: number | null
      priority: number
      move_damage_class_id: number
      move_effect_id: number
    }, ExtArgs["result"]["move"]>
    composites: {}
  }

  type MoveGetPayload<S extends boolean | null | undefined | MoveDefaultArgs> = $Result.GetResult<Prisma.$MovePayload, S>

  type MoveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MoveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MoveCountAggregateInputType | true
    }

  export interface MoveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Move'], meta: { name: 'Move' } }
    /**
     * Find zero or one Move that matches the filter.
     * @param {MoveFindUniqueArgs} args - Arguments to find a Move
     * @example
     * // Get one Move
     * const move = await prisma.move.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MoveFindUniqueArgs>(args: SelectSubset<T, MoveFindUniqueArgs<ExtArgs>>): Prisma__MoveClient<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Move that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MoveFindUniqueOrThrowArgs} args - Arguments to find a Move
     * @example
     * // Get one Move
     * const move = await prisma.move.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MoveFindUniqueOrThrowArgs>(args: SelectSubset<T, MoveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MoveClient<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Move that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveFindFirstArgs} args - Arguments to find a Move
     * @example
     * // Get one Move
     * const move = await prisma.move.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MoveFindFirstArgs>(args?: SelectSubset<T, MoveFindFirstArgs<ExtArgs>>): Prisma__MoveClient<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Move that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveFindFirstOrThrowArgs} args - Arguments to find a Move
     * @example
     * // Get one Move
     * const move = await prisma.move.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MoveFindFirstOrThrowArgs>(args?: SelectSubset<T, MoveFindFirstOrThrowArgs<ExtArgs>>): Prisma__MoveClient<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Moves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Moves
     * const moves = await prisma.move.findMany()
     * 
     * // Get first 10 Moves
     * const moves = await prisma.move.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moveWithIdOnly = await prisma.move.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MoveFindManyArgs>(args?: SelectSubset<T, MoveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Move.
     * @param {MoveCreateArgs} args - Arguments to create a Move.
     * @example
     * // Create one Move
     * const Move = await prisma.move.create({
     *   data: {
     *     // ... data to create a Move
     *   }
     * })
     * 
     */
    create<T extends MoveCreateArgs>(args: SelectSubset<T, MoveCreateArgs<ExtArgs>>): Prisma__MoveClient<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Moves.
     * @param {MoveCreateManyArgs} args - Arguments to create many Moves.
     * @example
     * // Create many Moves
     * const move = await prisma.move.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MoveCreateManyArgs>(args?: SelectSubset<T, MoveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Moves and returns the data saved in the database.
     * @param {MoveCreateManyAndReturnArgs} args - Arguments to create many Moves.
     * @example
     * // Create many Moves
     * const move = await prisma.move.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Moves and only return the `id`
     * const moveWithIdOnly = await prisma.move.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MoveCreateManyAndReturnArgs>(args?: SelectSubset<T, MoveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Move.
     * @param {MoveDeleteArgs} args - Arguments to delete one Move.
     * @example
     * // Delete one Move
     * const Move = await prisma.move.delete({
     *   where: {
     *     // ... filter to delete one Move
     *   }
     * })
     * 
     */
    delete<T extends MoveDeleteArgs>(args: SelectSubset<T, MoveDeleteArgs<ExtArgs>>): Prisma__MoveClient<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Move.
     * @param {MoveUpdateArgs} args - Arguments to update one Move.
     * @example
     * // Update one Move
     * const move = await prisma.move.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MoveUpdateArgs>(args: SelectSubset<T, MoveUpdateArgs<ExtArgs>>): Prisma__MoveClient<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Moves.
     * @param {MoveDeleteManyArgs} args - Arguments to filter Moves to delete.
     * @example
     * // Delete a few Moves
     * const { count } = await prisma.move.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MoveDeleteManyArgs>(args?: SelectSubset<T, MoveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Moves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Moves
     * const move = await prisma.move.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MoveUpdateManyArgs>(args: SelectSubset<T, MoveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Moves and returns the data updated in the database.
     * @param {MoveUpdateManyAndReturnArgs} args - Arguments to update many Moves.
     * @example
     * // Update many Moves
     * const move = await prisma.move.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Moves and only return the `id`
     * const moveWithIdOnly = await prisma.move.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MoveUpdateManyAndReturnArgs>(args: SelectSubset<T, MoveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Move.
     * @param {MoveUpsertArgs} args - Arguments to update or create a Move.
     * @example
     * // Update or create a Move
     * const move = await prisma.move.upsert({
     *   create: {
     *     // ... data to create a Move
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Move we want to update
     *   }
     * })
     */
    upsert<T extends MoveUpsertArgs>(args: SelectSubset<T, MoveUpsertArgs<ExtArgs>>): Prisma__MoveClient<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Moves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveCountArgs} args - Arguments to filter Moves to count.
     * @example
     * // Count the number of Moves
     * const count = await prisma.move.count({
     *   where: {
     *     // ... the filter for the Moves we want to count
     *   }
     * })
    **/
    count<T extends MoveCountArgs>(
      args?: Subset<T, MoveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MoveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Move.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MoveAggregateArgs>(args: Subset<T, MoveAggregateArgs>): Prisma.PrismaPromise<GetMoveAggregateType<T>>

    /**
     * Group by Move.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MoveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MoveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MoveGroupByArgs['orderBy'] }
        : { orderBy?: MoveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MoveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMoveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Move model
   */
  readonly fields: MoveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Move.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MoveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    type<T extends TypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TypeDefaultArgs<ExtArgs>>): Prisma__TypeClient<$Result.GetResult<Prisma.$TypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    damage_class<T extends MoveDamageClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MoveDamageClassDefaultArgs<ExtArgs>>): Prisma__MoveDamageClassClient<$Result.GetResult<Prisma.$MoveDamageClassPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    effect<T extends MoveEffectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MoveEffectDefaultArgs<ExtArgs>>): Prisma__MoveEffectClient<$Result.GetResult<Prisma.$MoveEffectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemon_moves<T extends Move$pokemon_movesArgs<ExtArgs> = {}>(args?: Subset<T, Move$pokemon_movesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonMovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Move model
   */
  interface MoveFieldRefs {
    readonly id: FieldRef<"Move", 'Int'>
    readonly name: FieldRef<"Move", 'String'>
    readonly generation_id: FieldRef<"Move", 'Int'>
    readonly type_id: FieldRef<"Move", 'Int'>
    readonly pp: FieldRef<"Move", 'Int'>
    readonly accuracy: FieldRef<"Move", 'Int'>
    readonly priority: FieldRef<"Move", 'Int'>
    readonly move_damage_class_id: FieldRef<"Move", 'Int'>
    readonly move_effect_id: FieldRef<"Move", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Move findUnique
   */
  export type MoveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    /**
     * Filter, which Move to fetch.
     */
    where: MoveWhereUniqueInput
  }

  /**
   * Move findUniqueOrThrow
   */
  export type MoveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    /**
     * Filter, which Move to fetch.
     */
    where: MoveWhereUniqueInput
  }

  /**
   * Move findFirst
   */
  export type MoveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    /**
     * Filter, which Move to fetch.
     */
    where?: MoveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Moves to fetch.
     */
    orderBy?: MoveOrderByWithRelationInput | MoveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Moves.
     */
    cursor?: MoveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Moves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Moves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Moves.
     */
    distinct?: MoveScalarFieldEnum | MoveScalarFieldEnum[]
  }

  /**
   * Move findFirstOrThrow
   */
  export type MoveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    /**
     * Filter, which Move to fetch.
     */
    where?: MoveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Moves to fetch.
     */
    orderBy?: MoveOrderByWithRelationInput | MoveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Moves.
     */
    cursor?: MoveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Moves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Moves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Moves.
     */
    distinct?: MoveScalarFieldEnum | MoveScalarFieldEnum[]
  }

  /**
   * Move findMany
   */
  export type MoveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    /**
     * Filter, which Moves to fetch.
     */
    where?: MoveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Moves to fetch.
     */
    orderBy?: MoveOrderByWithRelationInput | MoveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Moves.
     */
    cursor?: MoveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Moves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Moves.
     */
    skip?: number
    distinct?: MoveScalarFieldEnum | MoveScalarFieldEnum[]
  }

  /**
   * Move create
   */
  export type MoveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    /**
     * The data needed to create a Move.
     */
    data: XOR<MoveCreateInput, MoveUncheckedCreateInput>
  }

  /**
   * Move createMany
   */
  export type MoveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Moves.
     */
    data: MoveCreateManyInput | MoveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Move createManyAndReturn
   */
  export type MoveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * The data used to create many Moves.
     */
    data: MoveCreateManyInput | MoveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Move update
   */
  export type MoveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    /**
     * The data needed to update a Move.
     */
    data: XOR<MoveUpdateInput, MoveUncheckedUpdateInput>
    /**
     * Choose, which Move to update.
     */
    where: MoveWhereUniqueInput
  }

  /**
   * Move updateMany
   */
  export type MoveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Moves.
     */
    data: XOR<MoveUpdateManyMutationInput, MoveUncheckedUpdateManyInput>
    /**
     * Filter which Moves to update
     */
    where?: MoveWhereInput
    /**
     * Limit how many Moves to update.
     */
    limit?: number
  }

  /**
   * Move updateManyAndReturn
   */
  export type MoveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * The data used to update Moves.
     */
    data: XOR<MoveUpdateManyMutationInput, MoveUncheckedUpdateManyInput>
    /**
     * Filter which Moves to update
     */
    where?: MoveWhereInput
    /**
     * Limit how many Moves to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Move upsert
   */
  export type MoveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    /**
     * The filter to search for the Move to update in case it exists.
     */
    where: MoveWhereUniqueInput
    /**
     * In case the Move found by the `where` argument doesn't exist, create a new Move with this data.
     */
    create: XOR<MoveCreateInput, MoveUncheckedCreateInput>
    /**
     * In case the Move was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MoveUpdateInput, MoveUncheckedUpdateInput>
  }

  /**
   * Move delete
   */
  export type MoveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
    /**
     * Filter which Move to delete.
     */
    where: MoveWhereUniqueInput
  }

  /**
   * Move deleteMany
   */
  export type MoveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Moves to delete
     */
    where?: MoveWhereInput
    /**
     * Limit how many Moves to delete.
     */
    limit?: number
  }

  /**
   * Move.pokemon_moves
   */
  export type Move$pokemon_movesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonMove
     */
    select?: PokemonMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonMove
     */
    omit?: PokemonMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonMoveInclude<ExtArgs> | null
    where?: PokemonMoveWhereInput
    orderBy?: PokemonMoveOrderByWithRelationInput | PokemonMoveOrderByWithRelationInput[]
    cursor?: PokemonMoveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokemonMoveScalarFieldEnum | PokemonMoveScalarFieldEnum[]
  }

  /**
   * Move without action
   */
  export type MoveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Move
     */
    select?: MoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Move
     */
    omit?: MoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MoveInclude<ExtArgs> | null
  }


  /**
   * Model PokemonMove
   */

  export type AggregatePokemonMove = {
    _count: PokemonMoveCountAggregateOutputType | null
    _avg: PokemonMoveAvgAggregateOutputType | null
    _sum: PokemonMoveSumAggregateOutputType | null
    _min: PokemonMoveMinAggregateOutputType | null
    _max: PokemonMoveMaxAggregateOutputType | null
  }

  export type PokemonMoveAvgAggregateOutputType = {
    id: number | null
    version_group_id: number | null
    move_method_id: number | null
    move_id: number | null
    pokemon_id: number | null
    level: number | null
  }

  export type PokemonMoveSumAggregateOutputType = {
    id: number | null
    version_group_id: number | null
    move_method_id: number | null
    move_id: number | null
    pokemon_id: number | null
    level: number | null
  }

  export type PokemonMoveMinAggregateOutputType = {
    id: number | null
    version_group_id: number | null
    move_method_id: number | null
    move_id: number | null
    pokemon_id: number | null
    level: number | null
  }

  export type PokemonMoveMaxAggregateOutputType = {
    id: number | null
    version_group_id: number | null
    move_method_id: number | null
    move_id: number | null
    pokemon_id: number | null
    level: number | null
  }

  export type PokemonMoveCountAggregateOutputType = {
    id: number
    version_group_id: number
    move_method_id: number
    move_id: number
    pokemon_id: number
    level: number
    _all: number
  }


  export type PokemonMoveAvgAggregateInputType = {
    id?: true
    version_group_id?: true
    move_method_id?: true
    move_id?: true
    pokemon_id?: true
    level?: true
  }

  export type PokemonMoveSumAggregateInputType = {
    id?: true
    version_group_id?: true
    move_method_id?: true
    move_id?: true
    pokemon_id?: true
    level?: true
  }

  export type PokemonMoveMinAggregateInputType = {
    id?: true
    version_group_id?: true
    move_method_id?: true
    move_id?: true
    pokemon_id?: true
    level?: true
  }

  export type PokemonMoveMaxAggregateInputType = {
    id?: true
    version_group_id?: true
    move_method_id?: true
    move_id?: true
    pokemon_id?: true
    level?: true
  }

  export type PokemonMoveCountAggregateInputType = {
    id?: true
    version_group_id?: true
    move_method_id?: true
    move_id?: true
    pokemon_id?: true
    level?: true
    _all?: true
  }

  export type PokemonMoveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PokemonMove to aggregate.
     */
    where?: PokemonMoveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonMoves to fetch.
     */
    orderBy?: PokemonMoveOrderByWithRelationInput | PokemonMoveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PokemonMoveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonMoves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonMoves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PokemonMoves
    **/
    _count?: true | PokemonMoveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PokemonMoveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PokemonMoveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PokemonMoveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PokemonMoveMaxAggregateInputType
  }

  export type GetPokemonMoveAggregateType<T extends PokemonMoveAggregateArgs> = {
        [P in keyof T & keyof AggregatePokemonMove]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePokemonMove[P]>
      : GetScalarType<T[P], AggregatePokemonMove[P]>
  }




  export type PokemonMoveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonMoveWhereInput
    orderBy?: PokemonMoveOrderByWithAggregationInput | PokemonMoveOrderByWithAggregationInput[]
    by: PokemonMoveScalarFieldEnum[] | PokemonMoveScalarFieldEnum
    having?: PokemonMoveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PokemonMoveCountAggregateInputType | true
    _avg?: PokemonMoveAvgAggregateInputType
    _sum?: PokemonMoveSumAggregateInputType
    _min?: PokemonMoveMinAggregateInputType
    _max?: PokemonMoveMaxAggregateInputType
  }

  export type PokemonMoveGroupByOutputType = {
    id: number
    version_group_id: number
    move_method_id: number
    move_id: number
    pokemon_id: number
    level: number
    _count: PokemonMoveCountAggregateOutputType | null
    _avg: PokemonMoveAvgAggregateOutputType | null
    _sum: PokemonMoveSumAggregateOutputType | null
    _min: PokemonMoveMinAggregateOutputType | null
    _max: PokemonMoveMaxAggregateOutputType | null
  }

  type GetPokemonMoveGroupByPayload<T extends PokemonMoveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PokemonMoveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PokemonMoveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PokemonMoveGroupByOutputType[P]>
            : GetScalarType<T[P], PokemonMoveGroupByOutputType[P]>
        }
      >
    >


  export type PokemonMoveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version_group_id?: boolean
    move_method_id?: boolean
    move_id?: boolean
    pokemon_id?: boolean
    level?: boolean
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
    method?: boolean | MoveMethodDefaultArgs<ExtArgs>
    move?: boolean | MoveDefaultArgs<ExtArgs>
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonMove"]>

  export type PokemonMoveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version_group_id?: boolean
    move_method_id?: boolean
    move_id?: boolean
    pokemon_id?: boolean
    level?: boolean
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
    method?: boolean | MoveMethodDefaultArgs<ExtArgs>
    move?: boolean | MoveDefaultArgs<ExtArgs>
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonMove"]>

  export type PokemonMoveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version_group_id?: boolean
    move_method_id?: boolean
    move_id?: boolean
    pokemon_id?: boolean
    level?: boolean
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
    method?: boolean | MoveMethodDefaultArgs<ExtArgs>
    move?: boolean | MoveDefaultArgs<ExtArgs>
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonMove"]>

  export type PokemonMoveSelectScalar = {
    id?: boolean
    version_group_id?: boolean
    move_method_id?: boolean
    move_id?: boolean
    pokemon_id?: boolean
    level?: boolean
  }

  export type PokemonMoveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "version_group_id" | "move_method_id" | "move_id" | "pokemon_id" | "level", ExtArgs["result"]["pokemonMove"]>
  export type PokemonMoveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
    method?: boolean | MoveMethodDefaultArgs<ExtArgs>
    move?: boolean | MoveDefaultArgs<ExtArgs>
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
  }
  export type PokemonMoveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
    method?: boolean | MoveMethodDefaultArgs<ExtArgs>
    move?: boolean | MoveDefaultArgs<ExtArgs>
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
  }
  export type PokemonMoveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
    method?: boolean | MoveMethodDefaultArgs<ExtArgs>
    move?: boolean | MoveDefaultArgs<ExtArgs>
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
  }

  export type $PokemonMovePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PokemonMove"
    objects: {
      version_group: Prisma.$VersionGroupPayload<ExtArgs>
      method: Prisma.$MoveMethodPayload<ExtArgs>
      move: Prisma.$MovePayload<ExtArgs>
      pokemon: Prisma.$PokemonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      version_group_id: number
      move_method_id: number
      move_id: number
      pokemon_id: number
      level: number
    }, ExtArgs["result"]["pokemonMove"]>
    composites: {}
  }

  type PokemonMoveGetPayload<S extends boolean | null | undefined | PokemonMoveDefaultArgs> = $Result.GetResult<Prisma.$PokemonMovePayload, S>

  type PokemonMoveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PokemonMoveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PokemonMoveCountAggregateInputType | true
    }

  export interface PokemonMoveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PokemonMove'], meta: { name: 'PokemonMove' } }
    /**
     * Find zero or one PokemonMove that matches the filter.
     * @param {PokemonMoveFindUniqueArgs} args - Arguments to find a PokemonMove
     * @example
     * // Get one PokemonMove
     * const pokemonMove = await prisma.pokemonMove.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PokemonMoveFindUniqueArgs>(args: SelectSubset<T, PokemonMoveFindUniqueArgs<ExtArgs>>): Prisma__PokemonMoveClient<$Result.GetResult<Prisma.$PokemonMovePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PokemonMove that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PokemonMoveFindUniqueOrThrowArgs} args - Arguments to find a PokemonMove
     * @example
     * // Get one PokemonMove
     * const pokemonMove = await prisma.pokemonMove.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PokemonMoveFindUniqueOrThrowArgs>(args: SelectSubset<T, PokemonMoveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PokemonMoveClient<$Result.GetResult<Prisma.$PokemonMovePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PokemonMove that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonMoveFindFirstArgs} args - Arguments to find a PokemonMove
     * @example
     * // Get one PokemonMove
     * const pokemonMove = await prisma.pokemonMove.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PokemonMoveFindFirstArgs>(args?: SelectSubset<T, PokemonMoveFindFirstArgs<ExtArgs>>): Prisma__PokemonMoveClient<$Result.GetResult<Prisma.$PokemonMovePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PokemonMove that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonMoveFindFirstOrThrowArgs} args - Arguments to find a PokemonMove
     * @example
     * // Get one PokemonMove
     * const pokemonMove = await prisma.pokemonMove.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PokemonMoveFindFirstOrThrowArgs>(args?: SelectSubset<T, PokemonMoveFindFirstOrThrowArgs<ExtArgs>>): Prisma__PokemonMoveClient<$Result.GetResult<Prisma.$PokemonMovePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PokemonMoves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonMoveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PokemonMoves
     * const pokemonMoves = await prisma.pokemonMove.findMany()
     * 
     * // Get first 10 PokemonMoves
     * const pokemonMoves = await prisma.pokemonMove.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pokemonMoveWithIdOnly = await prisma.pokemonMove.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PokemonMoveFindManyArgs>(args?: SelectSubset<T, PokemonMoveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonMovePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PokemonMove.
     * @param {PokemonMoveCreateArgs} args - Arguments to create a PokemonMove.
     * @example
     * // Create one PokemonMove
     * const PokemonMove = await prisma.pokemonMove.create({
     *   data: {
     *     // ... data to create a PokemonMove
     *   }
     * })
     * 
     */
    create<T extends PokemonMoveCreateArgs>(args: SelectSubset<T, PokemonMoveCreateArgs<ExtArgs>>): Prisma__PokemonMoveClient<$Result.GetResult<Prisma.$PokemonMovePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PokemonMoves.
     * @param {PokemonMoveCreateManyArgs} args - Arguments to create many PokemonMoves.
     * @example
     * // Create many PokemonMoves
     * const pokemonMove = await prisma.pokemonMove.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PokemonMoveCreateManyArgs>(args?: SelectSubset<T, PokemonMoveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PokemonMoves and returns the data saved in the database.
     * @param {PokemonMoveCreateManyAndReturnArgs} args - Arguments to create many PokemonMoves.
     * @example
     * // Create many PokemonMoves
     * const pokemonMove = await prisma.pokemonMove.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PokemonMoves and only return the `id`
     * const pokemonMoveWithIdOnly = await prisma.pokemonMove.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PokemonMoveCreateManyAndReturnArgs>(args?: SelectSubset<T, PokemonMoveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonMovePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PokemonMove.
     * @param {PokemonMoveDeleteArgs} args - Arguments to delete one PokemonMove.
     * @example
     * // Delete one PokemonMove
     * const PokemonMove = await prisma.pokemonMove.delete({
     *   where: {
     *     // ... filter to delete one PokemonMove
     *   }
     * })
     * 
     */
    delete<T extends PokemonMoveDeleteArgs>(args: SelectSubset<T, PokemonMoveDeleteArgs<ExtArgs>>): Prisma__PokemonMoveClient<$Result.GetResult<Prisma.$PokemonMovePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PokemonMove.
     * @param {PokemonMoveUpdateArgs} args - Arguments to update one PokemonMove.
     * @example
     * // Update one PokemonMove
     * const pokemonMove = await prisma.pokemonMove.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PokemonMoveUpdateArgs>(args: SelectSubset<T, PokemonMoveUpdateArgs<ExtArgs>>): Prisma__PokemonMoveClient<$Result.GetResult<Prisma.$PokemonMovePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PokemonMoves.
     * @param {PokemonMoveDeleteManyArgs} args - Arguments to filter PokemonMoves to delete.
     * @example
     * // Delete a few PokemonMoves
     * const { count } = await prisma.pokemonMove.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PokemonMoveDeleteManyArgs>(args?: SelectSubset<T, PokemonMoveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PokemonMoves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonMoveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PokemonMoves
     * const pokemonMove = await prisma.pokemonMove.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PokemonMoveUpdateManyArgs>(args: SelectSubset<T, PokemonMoveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PokemonMoves and returns the data updated in the database.
     * @param {PokemonMoveUpdateManyAndReturnArgs} args - Arguments to update many PokemonMoves.
     * @example
     * // Update many PokemonMoves
     * const pokemonMove = await prisma.pokemonMove.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PokemonMoves and only return the `id`
     * const pokemonMoveWithIdOnly = await prisma.pokemonMove.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PokemonMoveUpdateManyAndReturnArgs>(args: SelectSubset<T, PokemonMoveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonMovePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PokemonMove.
     * @param {PokemonMoveUpsertArgs} args - Arguments to update or create a PokemonMove.
     * @example
     * // Update or create a PokemonMove
     * const pokemonMove = await prisma.pokemonMove.upsert({
     *   create: {
     *     // ... data to create a PokemonMove
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PokemonMove we want to update
     *   }
     * })
     */
    upsert<T extends PokemonMoveUpsertArgs>(args: SelectSubset<T, PokemonMoveUpsertArgs<ExtArgs>>): Prisma__PokemonMoveClient<$Result.GetResult<Prisma.$PokemonMovePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PokemonMoves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonMoveCountArgs} args - Arguments to filter PokemonMoves to count.
     * @example
     * // Count the number of PokemonMoves
     * const count = await prisma.pokemonMove.count({
     *   where: {
     *     // ... the filter for the PokemonMoves we want to count
     *   }
     * })
    **/
    count<T extends PokemonMoveCountArgs>(
      args?: Subset<T, PokemonMoveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PokemonMoveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PokemonMove.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonMoveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PokemonMoveAggregateArgs>(args: Subset<T, PokemonMoveAggregateArgs>): Prisma.PrismaPromise<GetPokemonMoveAggregateType<T>>

    /**
     * Group by PokemonMove.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonMoveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PokemonMoveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PokemonMoveGroupByArgs['orderBy'] }
        : { orderBy?: PokemonMoveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PokemonMoveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPokemonMoveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PokemonMove model
   */
  readonly fields: PokemonMoveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PokemonMove.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PokemonMoveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    version_group<T extends VersionGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VersionGroupDefaultArgs<ExtArgs>>): Prisma__VersionGroupClient<$Result.GetResult<Prisma.$VersionGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    method<T extends MoveMethodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MoveMethodDefaultArgs<ExtArgs>>): Prisma__MoveMethodClient<$Result.GetResult<Prisma.$MoveMethodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    move<T extends MoveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MoveDefaultArgs<ExtArgs>>): Prisma__MoveClient<$Result.GetResult<Prisma.$MovePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokemon<T extends PokemonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PokemonDefaultArgs<ExtArgs>>): Prisma__PokemonClient<$Result.GetResult<Prisma.$PokemonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PokemonMove model
   */
  interface PokemonMoveFieldRefs {
    readonly id: FieldRef<"PokemonMove", 'Int'>
    readonly version_group_id: FieldRef<"PokemonMove", 'Int'>
    readonly move_method_id: FieldRef<"PokemonMove", 'Int'>
    readonly move_id: FieldRef<"PokemonMove", 'Int'>
    readonly pokemon_id: FieldRef<"PokemonMove", 'Int'>
    readonly level: FieldRef<"PokemonMove", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PokemonMove findUnique
   */
  export type PokemonMoveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonMove
     */
    select?: PokemonMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonMove
     */
    omit?: PokemonMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonMoveInclude<ExtArgs> | null
    /**
     * Filter, which PokemonMove to fetch.
     */
    where: PokemonMoveWhereUniqueInput
  }

  /**
   * PokemonMove findUniqueOrThrow
   */
  export type PokemonMoveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonMove
     */
    select?: PokemonMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonMove
     */
    omit?: PokemonMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonMoveInclude<ExtArgs> | null
    /**
     * Filter, which PokemonMove to fetch.
     */
    where: PokemonMoveWhereUniqueInput
  }

  /**
   * PokemonMove findFirst
   */
  export type PokemonMoveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonMove
     */
    select?: PokemonMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonMove
     */
    omit?: PokemonMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonMoveInclude<ExtArgs> | null
    /**
     * Filter, which PokemonMove to fetch.
     */
    where?: PokemonMoveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonMoves to fetch.
     */
    orderBy?: PokemonMoveOrderByWithRelationInput | PokemonMoveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PokemonMoves.
     */
    cursor?: PokemonMoveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonMoves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonMoves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PokemonMoves.
     */
    distinct?: PokemonMoveScalarFieldEnum | PokemonMoveScalarFieldEnum[]
  }

  /**
   * PokemonMove findFirstOrThrow
   */
  export type PokemonMoveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonMove
     */
    select?: PokemonMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonMove
     */
    omit?: PokemonMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonMoveInclude<ExtArgs> | null
    /**
     * Filter, which PokemonMove to fetch.
     */
    where?: PokemonMoveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonMoves to fetch.
     */
    orderBy?: PokemonMoveOrderByWithRelationInput | PokemonMoveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PokemonMoves.
     */
    cursor?: PokemonMoveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonMoves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonMoves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PokemonMoves.
     */
    distinct?: PokemonMoveScalarFieldEnum | PokemonMoveScalarFieldEnum[]
  }

  /**
   * PokemonMove findMany
   */
  export type PokemonMoveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonMove
     */
    select?: PokemonMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonMove
     */
    omit?: PokemonMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonMoveInclude<ExtArgs> | null
    /**
     * Filter, which PokemonMoves to fetch.
     */
    where?: PokemonMoveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonMoves to fetch.
     */
    orderBy?: PokemonMoveOrderByWithRelationInput | PokemonMoveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PokemonMoves.
     */
    cursor?: PokemonMoveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonMoves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonMoves.
     */
    skip?: number
    distinct?: PokemonMoveScalarFieldEnum | PokemonMoveScalarFieldEnum[]
  }

  /**
   * PokemonMove create
   */
  export type PokemonMoveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonMove
     */
    select?: PokemonMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonMove
     */
    omit?: PokemonMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonMoveInclude<ExtArgs> | null
    /**
     * The data needed to create a PokemonMove.
     */
    data: XOR<PokemonMoveCreateInput, PokemonMoveUncheckedCreateInput>
  }

  /**
   * PokemonMove createMany
   */
  export type PokemonMoveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PokemonMoves.
     */
    data: PokemonMoveCreateManyInput | PokemonMoveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PokemonMove createManyAndReturn
   */
  export type PokemonMoveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonMove
     */
    select?: PokemonMoveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonMove
     */
    omit?: PokemonMoveOmit<ExtArgs> | null
    /**
     * The data used to create many PokemonMoves.
     */
    data: PokemonMoveCreateManyInput | PokemonMoveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonMoveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PokemonMove update
   */
  export type PokemonMoveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonMove
     */
    select?: PokemonMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonMove
     */
    omit?: PokemonMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonMoveInclude<ExtArgs> | null
    /**
     * The data needed to update a PokemonMove.
     */
    data: XOR<PokemonMoveUpdateInput, PokemonMoveUncheckedUpdateInput>
    /**
     * Choose, which PokemonMove to update.
     */
    where: PokemonMoveWhereUniqueInput
  }

  /**
   * PokemonMove updateMany
   */
  export type PokemonMoveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PokemonMoves.
     */
    data: XOR<PokemonMoveUpdateManyMutationInput, PokemonMoveUncheckedUpdateManyInput>
    /**
     * Filter which PokemonMoves to update
     */
    where?: PokemonMoveWhereInput
    /**
     * Limit how many PokemonMoves to update.
     */
    limit?: number
  }

  /**
   * PokemonMove updateManyAndReturn
   */
  export type PokemonMoveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonMove
     */
    select?: PokemonMoveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonMove
     */
    omit?: PokemonMoveOmit<ExtArgs> | null
    /**
     * The data used to update PokemonMoves.
     */
    data: XOR<PokemonMoveUpdateManyMutationInput, PokemonMoveUncheckedUpdateManyInput>
    /**
     * Filter which PokemonMoves to update
     */
    where?: PokemonMoveWhereInput
    /**
     * Limit how many PokemonMoves to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonMoveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PokemonMove upsert
   */
  export type PokemonMoveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonMove
     */
    select?: PokemonMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonMove
     */
    omit?: PokemonMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonMoveInclude<ExtArgs> | null
    /**
     * The filter to search for the PokemonMove to update in case it exists.
     */
    where: PokemonMoveWhereUniqueInput
    /**
     * In case the PokemonMove found by the `where` argument doesn't exist, create a new PokemonMove with this data.
     */
    create: XOR<PokemonMoveCreateInput, PokemonMoveUncheckedCreateInput>
    /**
     * In case the PokemonMove was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PokemonMoveUpdateInput, PokemonMoveUncheckedUpdateInput>
  }

  /**
   * PokemonMove delete
   */
  export type PokemonMoveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonMove
     */
    select?: PokemonMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonMove
     */
    omit?: PokemonMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonMoveInclude<ExtArgs> | null
    /**
     * Filter which PokemonMove to delete.
     */
    where: PokemonMoveWhereUniqueInput
  }

  /**
   * PokemonMove deleteMany
   */
  export type PokemonMoveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PokemonMoves to delete
     */
    where?: PokemonMoveWhereInput
    /**
     * Limit how many PokemonMoves to delete.
     */
    limit?: number
  }

  /**
   * PokemonMove without action
   */
  export type PokemonMoveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonMove
     */
    select?: PokemonMoveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonMove
     */
    omit?: PokemonMoveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonMoveInclude<ExtArgs> | null
  }


  /**
   * Model Pokedex
   */

  export type AggregatePokedex = {
    _count: PokedexCountAggregateOutputType | null
    _avg: PokedexAvgAggregateOutputType | null
    _sum: PokedexSumAggregateOutputType | null
    _min: PokedexMinAggregateOutputType | null
    _max: PokedexMaxAggregateOutputType | null
  }

  export type PokedexAvgAggregateOutputType = {
    id: number | null
    region_id: number | null
  }

  export type PokedexSumAggregateOutputType = {
    id: number | null
    region_id: number | null
  }

  export type PokedexMinAggregateOutputType = {
    id: number | null
    name: string | null
    region_id: number | null
  }

  export type PokedexMaxAggregateOutputType = {
    id: number | null
    name: string | null
    region_id: number | null
  }

  export type PokedexCountAggregateOutputType = {
    id: number
    name: number
    region_id: number
    _all: number
  }


  export type PokedexAvgAggregateInputType = {
    id?: true
    region_id?: true
  }

  export type PokedexSumAggregateInputType = {
    id?: true
    region_id?: true
  }

  export type PokedexMinAggregateInputType = {
    id?: true
    name?: true
    region_id?: true
  }

  export type PokedexMaxAggregateInputType = {
    id?: true
    name?: true
    region_id?: true
  }

  export type PokedexCountAggregateInputType = {
    id?: true
    name?: true
    region_id?: true
    _all?: true
  }

  export type PokedexAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pokedex to aggregate.
     */
    where?: PokedexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pokedexes to fetch.
     */
    orderBy?: PokedexOrderByWithRelationInput | PokedexOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PokedexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pokedexes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pokedexes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pokedexes
    **/
    _count?: true | PokedexCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PokedexAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PokedexSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PokedexMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PokedexMaxAggregateInputType
  }

  export type GetPokedexAggregateType<T extends PokedexAggregateArgs> = {
        [P in keyof T & keyof AggregatePokedex]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePokedex[P]>
      : GetScalarType<T[P], AggregatePokedex[P]>
  }




  export type PokedexGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokedexWhereInput
    orderBy?: PokedexOrderByWithAggregationInput | PokedexOrderByWithAggregationInput[]
    by: PokedexScalarFieldEnum[] | PokedexScalarFieldEnum
    having?: PokedexScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PokedexCountAggregateInputType | true
    _avg?: PokedexAvgAggregateInputType
    _sum?: PokedexSumAggregateInputType
    _min?: PokedexMinAggregateInputType
    _max?: PokedexMaxAggregateInputType
  }

  export type PokedexGroupByOutputType = {
    id: number
    name: string
    region_id: number
    _count: PokedexCountAggregateOutputType | null
    _avg: PokedexAvgAggregateOutputType | null
    _sum: PokedexSumAggregateOutputType | null
    _min: PokedexMinAggregateOutputType | null
    _max: PokedexMaxAggregateOutputType | null
  }

  type GetPokedexGroupByPayload<T extends PokedexGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PokedexGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PokedexGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PokedexGroupByOutputType[P]>
            : GetScalarType<T[P], PokedexGroupByOutputType[P]>
        }
      >
    >


  export type PokedexSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    region_id?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
    pokedex_version_groups?: boolean | Pokedex$pokedex_version_groupsArgs<ExtArgs>
    pokemon_dex_numbers?: boolean | Pokedex$pokemon_dex_numbersArgs<ExtArgs>
    _count?: boolean | PokedexCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokedex"]>

  export type PokedexSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    region_id?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokedex"]>

  export type PokedexSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    region_id?: boolean
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokedex"]>

  export type PokedexSelectScalar = {
    id?: boolean
    name?: boolean
    region_id?: boolean
  }

  export type PokedexOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "region_id", ExtArgs["result"]["pokedex"]>
  export type PokedexInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
    pokedex_version_groups?: boolean | Pokedex$pokedex_version_groupsArgs<ExtArgs>
    pokemon_dex_numbers?: boolean | Pokedex$pokemon_dex_numbersArgs<ExtArgs>
    _count?: boolean | PokedexCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PokedexIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }
  export type PokedexIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    region?: boolean | RegionDefaultArgs<ExtArgs>
  }

  export type $PokedexPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pokedex"
    objects: {
      region: Prisma.$RegionPayload<ExtArgs>
      pokedex_version_groups: Prisma.$PokedexVersionGroupPayload<ExtArgs>[]
      pokemon_dex_numbers: Prisma.$PokemonDexNumberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      region_id: number
    }, ExtArgs["result"]["pokedex"]>
    composites: {}
  }

  type PokedexGetPayload<S extends boolean | null | undefined | PokedexDefaultArgs> = $Result.GetResult<Prisma.$PokedexPayload, S>

  type PokedexCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PokedexFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PokedexCountAggregateInputType | true
    }

  export interface PokedexDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pokedex'], meta: { name: 'Pokedex' } }
    /**
     * Find zero or one Pokedex that matches the filter.
     * @param {PokedexFindUniqueArgs} args - Arguments to find a Pokedex
     * @example
     * // Get one Pokedex
     * const pokedex = await prisma.pokedex.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PokedexFindUniqueArgs>(args: SelectSubset<T, PokedexFindUniqueArgs<ExtArgs>>): Prisma__PokedexClient<$Result.GetResult<Prisma.$PokedexPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pokedex that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PokedexFindUniqueOrThrowArgs} args - Arguments to find a Pokedex
     * @example
     * // Get one Pokedex
     * const pokedex = await prisma.pokedex.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PokedexFindUniqueOrThrowArgs>(args: SelectSubset<T, PokedexFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PokedexClient<$Result.GetResult<Prisma.$PokedexPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokedex that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokedexFindFirstArgs} args - Arguments to find a Pokedex
     * @example
     * // Get one Pokedex
     * const pokedex = await prisma.pokedex.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PokedexFindFirstArgs>(args?: SelectSubset<T, PokedexFindFirstArgs<ExtArgs>>): Prisma__PokedexClient<$Result.GetResult<Prisma.$PokedexPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pokedex that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokedexFindFirstOrThrowArgs} args - Arguments to find a Pokedex
     * @example
     * // Get one Pokedex
     * const pokedex = await prisma.pokedex.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PokedexFindFirstOrThrowArgs>(args?: SelectSubset<T, PokedexFindFirstOrThrowArgs<ExtArgs>>): Prisma__PokedexClient<$Result.GetResult<Prisma.$PokedexPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pokedexes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokedexFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pokedexes
     * const pokedexes = await prisma.pokedex.findMany()
     * 
     * // Get first 10 Pokedexes
     * const pokedexes = await prisma.pokedex.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pokedexWithIdOnly = await prisma.pokedex.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PokedexFindManyArgs>(args?: SelectSubset<T, PokedexFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokedexPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pokedex.
     * @param {PokedexCreateArgs} args - Arguments to create a Pokedex.
     * @example
     * // Create one Pokedex
     * const Pokedex = await prisma.pokedex.create({
     *   data: {
     *     // ... data to create a Pokedex
     *   }
     * })
     * 
     */
    create<T extends PokedexCreateArgs>(args: SelectSubset<T, PokedexCreateArgs<ExtArgs>>): Prisma__PokedexClient<$Result.GetResult<Prisma.$PokedexPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pokedexes.
     * @param {PokedexCreateManyArgs} args - Arguments to create many Pokedexes.
     * @example
     * // Create many Pokedexes
     * const pokedex = await prisma.pokedex.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PokedexCreateManyArgs>(args?: SelectSubset<T, PokedexCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pokedexes and returns the data saved in the database.
     * @param {PokedexCreateManyAndReturnArgs} args - Arguments to create many Pokedexes.
     * @example
     * // Create many Pokedexes
     * const pokedex = await prisma.pokedex.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pokedexes and only return the `id`
     * const pokedexWithIdOnly = await prisma.pokedex.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PokedexCreateManyAndReturnArgs>(args?: SelectSubset<T, PokedexCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokedexPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pokedex.
     * @param {PokedexDeleteArgs} args - Arguments to delete one Pokedex.
     * @example
     * // Delete one Pokedex
     * const Pokedex = await prisma.pokedex.delete({
     *   where: {
     *     // ... filter to delete one Pokedex
     *   }
     * })
     * 
     */
    delete<T extends PokedexDeleteArgs>(args: SelectSubset<T, PokedexDeleteArgs<ExtArgs>>): Prisma__PokedexClient<$Result.GetResult<Prisma.$PokedexPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pokedex.
     * @param {PokedexUpdateArgs} args - Arguments to update one Pokedex.
     * @example
     * // Update one Pokedex
     * const pokedex = await prisma.pokedex.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PokedexUpdateArgs>(args: SelectSubset<T, PokedexUpdateArgs<ExtArgs>>): Prisma__PokedexClient<$Result.GetResult<Prisma.$PokedexPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pokedexes.
     * @param {PokedexDeleteManyArgs} args - Arguments to filter Pokedexes to delete.
     * @example
     * // Delete a few Pokedexes
     * const { count } = await prisma.pokedex.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PokedexDeleteManyArgs>(args?: SelectSubset<T, PokedexDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pokedexes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokedexUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pokedexes
     * const pokedex = await prisma.pokedex.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PokedexUpdateManyArgs>(args: SelectSubset<T, PokedexUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pokedexes and returns the data updated in the database.
     * @param {PokedexUpdateManyAndReturnArgs} args - Arguments to update many Pokedexes.
     * @example
     * // Update many Pokedexes
     * const pokedex = await prisma.pokedex.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pokedexes and only return the `id`
     * const pokedexWithIdOnly = await prisma.pokedex.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PokedexUpdateManyAndReturnArgs>(args: SelectSubset<T, PokedexUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokedexPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pokedex.
     * @param {PokedexUpsertArgs} args - Arguments to update or create a Pokedex.
     * @example
     * // Update or create a Pokedex
     * const pokedex = await prisma.pokedex.upsert({
     *   create: {
     *     // ... data to create a Pokedex
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pokedex we want to update
     *   }
     * })
     */
    upsert<T extends PokedexUpsertArgs>(args: SelectSubset<T, PokedexUpsertArgs<ExtArgs>>): Prisma__PokedexClient<$Result.GetResult<Prisma.$PokedexPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pokedexes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokedexCountArgs} args - Arguments to filter Pokedexes to count.
     * @example
     * // Count the number of Pokedexes
     * const count = await prisma.pokedex.count({
     *   where: {
     *     // ... the filter for the Pokedexes we want to count
     *   }
     * })
    **/
    count<T extends PokedexCountArgs>(
      args?: Subset<T, PokedexCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PokedexCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pokedex.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokedexAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PokedexAggregateArgs>(args: Subset<T, PokedexAggregateArgs>): Prisma.PrismaPromise<GetPokedexAggregateType<T>>

    /**
     * Group by Pokedex.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokedexGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PokedexGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PokedexGroupByArgs['orderBy'] }
        : { orderBy?: PokedexGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PokedexGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPokedexGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pokedex model
   */
  readonly fields: PokedexFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pokedex.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PokedexClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    region<T extends RegionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RegionDefaultArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokedex_version_groups<T extends Pokedex$pokedex_version_groupsArgs<ExtArgs> = {}>(args?: Subset<T, Pokedex$pokedex_version_groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokedexVersionGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pokemon_dex_numbers<T extends Pokedex$pokemon_dex_numbersArgs<ExtArgs> = {}>(args?: Subset<T, Pokedex$pokemon_dex_numbersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonDexNumberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pokedex model
   */
  interface PokedexFieldRefs {
    readonly id: FieldRef<"Pokedex", 'Int'>
    readonly name: FieldRef<"Pokedex", 'String'>
    readonly region_id: FieldRef<"Pokedex", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Pokedex findUnique
   */
  export type PokedexFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokedex
     */
    select?: PokedexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokedex
     */
    omit?: PokedexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexInclude<ExtArgs> | null
    /**
     * Filter, which Pokedex to fetch.
     */
    where: PokedexWhereUniqueInput
  }

  /**
   * Pokedex findUniqueOrThrow
   */
  export type PokedexFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokedex
     */
    select?: PokedexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokedex
     */
    omit?: PokedexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexInclude<ExtArgs> | null
    /**
     * Filter, which Pokedex to fetch.
     */
    where: PokedexWhereUniqueInput
  }

  /**
   * Pokedex findFirst
   */
  export type PokedexFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokedex
     */
    select?: PokedexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokedex
     */
    omit?: PokedexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexInclude<ExtArgs> | null
    /**
     * Filter, which Pokedex to fetch.
     */
    where?: PokedexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pokedexes to fetch.
     */
    orderBy?: PokedexOrderByWithRelationInput | PokedexOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pokedexes.
     */
    cursor?: PokedexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pokedexes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pokedexes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pokedexes.
     */
    distinct?: PokedexScalarFieldEnum | PokedexScalarFieldEnum[]
  }

  /**
   * Pokedex findFirstOrThrow
   */
  export type PokedexFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokedex
     */
    select?: PokedexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokedex
     */
    omit?: PokedexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexInclude<ExtArgs> | null
    /**
     * Filter, which Pokedex to fetch.
     */
    where?: PokedexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pokedexes to fetch.
     */
    orderBy?: PokedexOrderByWithRelationInput | PokedexOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pokedexes.
     */
    cursor?: PokedexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pokedexes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pokedexes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pokedexes.
     */
    distinct?: PokedexScalarFieldEnum | PokedexScalarFieldEnum[]
  }

  /**
   * Pokedex findMany
   */
  export type PokedexFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokedex
     */
    select?: PokedexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokedex
     */
    omit?: PokedexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexInclude<ExtArgs> | null
    /**
     * Filter, which Pokedexes to fetch.
     */
    where?: PokedexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pokedexes to fetch.
     */
    orderBy?: PokedexOrderByWithRelationInput | PokedexOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pokedexes.
     */
    cursor?: PokedexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pokedexes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pokedexes.
     */
    skip?: number
    distinct?: PokedexScalarFieldEnum | PokedexScalarFieldEnum[]
  }

  /**
   * Pokedex create
   */
  export type PokedexCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokedex
     */
    select?: PokedexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokedex
     */
    omit?: PokedexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexInclude<ExtArgs> | null
    /**
     * The data needed to create a Pokedex.
     */
    data: XOR<PokedexCreateInput, PokedexUncheckedCreateInput>
  }

  /**
   * Pokedex createMany
   */
  export type PokedexCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pokedexes.
     */
    data: PokedexCreateManyInput | PokedexCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pokedex createManyAndReturn
   */
  export type PokedexCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokedex
     */
    select?: PokedexSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pokedex
     */
    omit?: PokedexOmit<ExtArgs> | null
    /**
     * The data used to create many Pokedexes.
     */
    data: PokedexCreateManyInput | PokedexCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pokedex update
   */
  export type PokedexUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokedex
     */
    select?: PokedexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokedex
     */
    omit?: PokedexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexInclude<ExtArgs> | null
    /**
     * The data needed to update a Pokedex.
     */
    data: XOR<PokedexUpdateInput, PokedexUncheckedUpdateInput>
    /**
     * Choose, which Pokedex to update.
     */
    where: PokedexWhereUniqueInput
  }

  /**
   * Pokedex updateMany
   */
  export type PokedexUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pokedexes.
     */
    data: XOR<PokedexUpdateManyMutationInput, PokedexUncheckedUpdateManyInput>
    /**
     * Filter which Pokedexes to update
     */
    where?: PokedexWhereInput
    /**
     * Limit how many Pokedexes to update.
     */
    limit?: number
  }

  /**
   * Pokedex updateManyAndReturn
   */
  export type PokedexUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokedex
     */
    select?: PokedexSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pokedex
     */
    omit?: PokedexOmit<ExtArgs> | null
    /**
     * The data used to update Pokedexes.
     */
    data: XOR<PokedexUpdateManyMutationInput, PokedexUncheckedUpdateManyInput>
    /**
     * Filter which Pokedexes to update
     */
    where?: PokedexWhereInput
    /**
     * Limit how many Pokedexes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pokedex upsert
   */
  export type PokedexUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokedex
     */
    select?: PokedexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokedex
     */
    omit?: PokedexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexInclude<ExtArgs> | null
    /**
     * The filter to search for the Pokedex to update in case it exists.
     */
    where: PokedexWhereUniqueInput
    /**
     * In case the Pokedex found by the `where` argument doesn't exist, create a new Pokedex with this data.
     */
    create: XOR<PokedexCreateInput, PokedexUncheckedCreateInput>
    /**
     * In case the Pokedex was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PokedexUpdateInput, PokedexUncheckedUpdateInput>
  }

  /**
   * Pokedex delete
   */
  export type PokedexDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokedex
     */
    select?: PokedexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokedex
     */
    omit?: PokedexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexInclude<ExtArgs> | null
    /**
     * Filter which Pokedex to delete.
     */
    where: PokedexWhereUniqueInput
  }

  /**
   * Pokedex deleteMany
   */
  export type PokedexDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pokedexes to delete
     */
    where?: PokedexWhereInput
    /**
     * Limit how many Pokedexes to delete.
     */
    limit?: number
  }

  /**
   * Pokedex.pokedex_version_groups
   */
  export type Pokedex$pokedex_version_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokedexVersionGroup
     */
    select?: PokedexVersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokedexVersionGroup
     */
    omit?: PokedexVersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexVersionGroupInclude<ExtArgs> | null
    where?: PokedexVersionGroupWhereInput
    orderBy?: PokedexVersionGroupOrderByWithRelationInput | PokedexVersionGroupOrderByWithRelationInput[]
    cursor?: PokedexVersionGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokedexVersionGroupScalarFieldEnum | PokedexVersionGroupScalarFieldEnum[]
  }

  /**
   * Pokedex.pokemon_dex_numbers
   */
  export type Pokedex$pokemon_dex_numbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonDexNumber
     */
    select?: PokemonDexNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonDexNumber
     */
    omit?: PokemonDexNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonDexNumberInclude<ExtArgs> | null
    where?: PokemonDexNumberWhereInput
    orderBy?: PokemonDexNumberOrderByWithRelationInput | PokemonDexNumberOrderByWithRelationInput[]
    cursor?: PokemonDexNumberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PokemonDexNumberScalarFieldEnum | PokemonDexNumberScalarFieldEnum[]
  }

  /**
   * Pokedex without action
   */
  export type PokedexDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pokedex
     */
    select?: PokedexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pokedex
     */
    omit?: PokedexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexInclude<ExtArgs> | null
  }


  /**
   * Model PokedexVersionGroup
   */

  export type AggregatePokedexVersionGroup = {
    _count: PokedexVersionGroupCountAggregateOutputType | null
    _avg: PokedexVersionGroupAvgAggregateOutputType | null
    _sum: PokedexVersionGroupSumAggregateOutputType | null
    _min: PokedexVersionGroupMinAggregateOutputType | null
    _max: PokedexVersionGroupMaxAggregateOutputType | null
  }

  export type PokedexVersionGroupAvgAggregateOutputType = {
    id: number | null
    version_group_id: number | null
    pokedex_id: number | null
  }

  export type PokedexVersionGroupSumAggregateOutputType = {
    id: number | null
    version_group_id: number | null
    pokedex_id: number | null
  }

  export type PokedexVersionGroupMinAggregateOutputType = {
    id: number | null
    version_group_id: number | null
    pokedex_id: number | null
  }

  export type PokedexVersionGroupMaxAggregateOutputType = {
    id: number | null
    version_group_id: number | null
    pokedex_id: number | null
  }

  export type PokedexVersionGroupCountAggregateOutputType = {
    id: number
    version_group_id: number
    pokedex_id: number
    _all: number
  }


  export type PokedexVersionGroupAvgAggregateInputType = {
    id?: true
    version_group_id?: true
    pokedex_id?: true
  }

  export type PokedexVersionGroupSumAggregateInputType = {
    id?: true
    version_group_id?: true
    pokedex_id?: true
  }

  export type PokedexVersionGroupMinAggregateInputType = {
    id?: true
    version_group_id?: true
    pokedex_id?: true
  }

  export type PokedexVersionGroupMaxAggregateInputType = {
    id?: true
    version_group_id?: true
    pokedex_id?: true
  }

  export type PokedexVersionGroupCountAggregateInputType = {
    id?: true
    version_group_id?: true
    pokedex_id?: true
    _all?: true
  }

  export type PokedexVersionGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PokedexVersionGroup to aggregate.
     */
    where?: PokedexVersionGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokedexVersionGroups to fetch.
     */
    orderBy?: PokedexVersionGroupOrderByWithRelationInput | PokedexVersionGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PokedexVersionGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokedexVersionGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokedexVersionGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PokedexVersionGroups
    **/
    _count?: true | PokedexVersionGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PokedexVersionGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PokedexVersionGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PokedexVersionGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PokedexVersionGroupMaxAggregateInputType
  }

  export type GetPokedexVersionGroupAggregateType<T extends PokedexVersionGroupAggregateArgs> = {
        [P in keyof T & keyof AggregatePokedexVersionGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePokedexVersionGroup[P]>
      : GetScalarType<T[P], AggregatePokedexVersionGroup[P]>
  }




  export type PokedexVersionGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokedexVersionGroupWhereInput
    orderBy?: PokedexVersionGroupOrderByWithAggregationInput | PokedexVersionGroupOrderByWithAggregationInput[]
    by: PokedexVersionGroupScalarFieldEnum[] | PokedexVersionGroupScalarFieldEnum
    having?: PokedexVersionGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PokedexVersionGroupCountAggregateInputType | true
    _avg?: PokedexVersionGroupAvgAggregateInputType
    _sum?: PokedexVersionGroupSumAggregateInputType
    _min?: PokedexVersionGroupMinAggregateInputType
    _max?: PokedexVersionGroupMaxAggregateInputType
  }

  export type PokedexVersionGroupGroupByOutputType = {
    id: number
    version_group_id: number
    pokedex_id: number
    _count: PokedexVersionGroupCountAggregateOutputType | null
    _avg: PokedexVersionGroupAvgAggregateOutputType | null
    _sum: PokedexVersionGroupSumAggregateOutputType | null
    _min: PokedexVersionGroupMinAggregateOutputType | null
    _max: PokedexVersionGroupMaxAggregateOutputType | null
  }

  type GetPokedexVersionGroupGroupByPayload<T extends PokedexVersionGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PokedexVersionGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PokedexVersionGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PokedexVersionGroupGroupByOutputType[P]>
            : GetScalarType<T[P], PokedexVersionGroupGroupByOutputType[P]>
        }
      >
    >


  export type PokedexVersionGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version_group_id?: boolean
    pokedex_id?: boolean
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
    pokedex?: boolean | PokedexDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokedexVersionGroup"]>

  export type PokedexVersionGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version_group_id?: boolean
    pokedex_id?: boolean
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
    pokedex?: boolean | PokedexDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokedexVersionGroup"]>

  export type PokedexVersionGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version_group_id?: boolean
    pokedex_id?: boolean
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
    pokedex?: boolean | PokedexDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokedexVersionGroup"]>

  export type PokedexVersionGroupSelectScalar = {
    id?: boolean
    version_group_id?: boolean
    pokedex_id?: boolean
  }

  export type PokedexVersionGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "version_group_id" | "pokedex_id", ExtArgs["result"]["pokedexVersionGroup"]>
  export type PokedexVersionGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
    pokedex?: boolean | PokedexDefaultArgs<ExtArgs>
  }
  export type PokedexVersionGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
    pokedex?: boolean | PokedexDefaultArgs<ExtArgs>
  }
  export type PokedexVersionGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    version_group?: boolean | VersionGroupDefaultArgs<ExtArgs>
    pokedex?: boolean | PokedexDefaultArgs<ExtArgs>
  }

  export type $PokedexVersionGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PokedexVersionGroup"
    objects: {
      version_group: Prisma.$VersionGroupPayload<ExtArgs>
      pokedex: Prisma.$PokedexPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      version_group_id: number
      pokedex_id: number
    }, ExtArgs["result"]["pokedexVersionGroup"]>
    composites: {}
  }

  type PokedexVersionGroupGetPayload<S extends boolean | null | undefined | PokedexVersionGroupDefaultArgs> = $Result.GetResult<Prisma.$PokedexVersionGroupPayload, S>

  type PokedexVersionGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PokedexVersionGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PokedexVersionGroupCountAggregateInputType | true
    }

  export interface PokedexVersionGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PokedexVersionGroup'], meta: { name: 'PokedexVersionGroup' } }
    /**
     * Find zero or one PokedexVersionGroup that matches the filter.
     * @param {PokedexVersionGroupFindUniqueArgs} args - Arguments to find a PokedexVersionGroup
     * @example
     * // Get one PokedexVersionGroup
     * const pokedexVersionGroup = await prisma.pokedexVersionGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PokedexVersionGroupFindUniqueArgs>(args: SelectSubset<T, PokedexVersionGroupFindUniqueArgs<ExtArgs>>): Prisma__PokedexVersionGroupClient<$Result.GetResult<Prisma.$PokedexVersionGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PokedexVersionGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PokedexVersionGroupFindUniqueOrThrowArgs} args - Arguments to find a PokedexVersionGroup
     * @example
     * // Get one PokedexVersionGroup
     * const pokedexVersionGroup = await prisma.pokedexVersionGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PokedexVersionGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, PokedexVersionGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PokedexVersionGroupClient<$Result.GetResult<Prisma.$PokedexVersionGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PokedexVersionGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokedexVersionGroupFindFirstArgs} args - Arguments to find a PokedexVersionGroup
     * @example
     * // Get one PokedexVersionGroup
     * const pokedexVersionGroup = await prisma.pokedexVersionGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PokedexVersionGroupFindFirstArgs>(args?: SelectSubset<T, PokedexVersionGroupFindFirstArgs<ExtArgs>>): Prisma__PokedexVersionGroupClient<$Result.GetResult<Prisma.$PokedexVersionGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PokedexVersionGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokedexVersionGroupFindFirstOrThrowArgs} args - Arguments to find a PokedexVersionGroup
     * @example
     * // Get one PokedexVersionGroup
     * const pokedexVersionGroup = await prisma.pokedexVersionGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PokedexVersionGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, PokedexVersionGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__PokedexVersionGroupClient<$Result.GetResult<Prisma.$PokedexVersionGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PokedexVersionGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokedexVersionGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PokedexVersionGroups
     * const pokedexVersionGroups = await prisma.pokedexVersionGroup.findMany()
     * 
     * // Get first 10 PokedexVersionGroups
     * const pokedexVersionGroups = await prisma.pokedexVersionGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pokedexVersionGroupWithIdOnly = await prisma.pokedexVersionGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PokedexVersionGroupFindManyArgs>(args?: SelectSubset<T, PokedexVersionGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokedexVersionGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PokedexVersionGroup.
     * @param {PokedexVersionGroupCreateArgs} args - Arguments to create a PokedexVersionGroup.
     * @example
     * // Create one PokedexVersionGroup
     * const PokedexVersionGroup = await prisma.pokedexVersionGroup.create({
     *   data: {
     *     // ... data to create a PokedexVersionGroup
     *   }
     * })
     * 
     */
    create<T extends PokedexVersionGroupCreateArgs>(args: SelectSubset<T, PokedexVersionGroupCreateArgs<ExtArgs>>): Prisma__PokedexVersionGroupClient<$Result.GetResult<Prisma.$PokedexVersionGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PokedexVersionGroups.
     * @param {PokedexVersionGroupCreateManyArgs} args - Arguments to create many PokedexVersionGroups.
     * @example
     * // Create many PokedexVersionGroups
     * const pokedexVersionGroup = await prisma.pokedexVersionGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PokedexVersionGroupCreateManyArgs>(args?: SelectSubset<T, PokedexVersionGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PokedexVersionGroups and returns the data saved in the database.
     * @param {PokedexVersionGroupCreateManyAndReturnArgs} args - Arguments to create many PokedexVersionGroups.
     * @example
     * // Create many PokedexVersionGroups
     * const pokedexVersionGroup = await prisma.pokedexVersionGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PokedexVersionGroups and only return the `id`
     * const pokedexVersionGroupWithIdOnly = await prisma.pokedexVersionGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PokedexVersionGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, PokedexVersionGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokedexVersionGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PokedexVersionGroup.
     * @param {PokedexVersionGroupDeleteArgs} args - Arguments to delete one PokedexVersionGroup.
     * @example
     * // Delete one PokedexVersionGroup
     * const PokedexVersionGroup = await prisma.pokedexVersionGroup.delete({
     *   where: {
     *     // ... filter to delete one PokedexVersionGroup
     *   }
     * })
     * 
     */
    delete<T extends PokedexVersionGroupDeleteArgs>(args: SelectSubset<T, PokedexVersionGroupDeleteArgs<ExtArgs>>): Prisma__PokedexVersionGroupClient<$Result.GetResult<Prisma.$PokedexVersionGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PokedexVersionGroup.
     * @param {PokedexVersionGroupUpdateArgs} args - Arguments to update one PokedexVersionGroup.
     * @example
     * // Update one PokedexVersionGroup
     * const pokedexVersionGroup = await prisma.pokedexVersionGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PokedexVersionGroupUpdateArgs>(args: SelectSubset<T, PokedexVersionGroupUpdateArgs<ExtArgs>>): Prisma__PokedexVersionGroupClient<$Result.GetResult<Prisma.$PokedexVersionGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PokedexVersionGroups.
     * @param {PokedexVersionGroupDeleteManyArgs} args - Arguments to filter PokedexVersionGroups to delete.
     * @example
     * // Delete a few PokedexVersionGroups
     * const { count } = await prisma.pokedexVersionGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PokedexVersionGroupDeleteManyArgs>(args?: SelectSubset<T, PokedexVersionGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PokedexVersionGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokedexVersionGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PokedexVersionGroups
     * const pokedexVersionGroup = await prisma.pokedexVersionGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PokedexVersionGroupUpdateManyArgs>(args: SelectSubset<T, PokedexVersionGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PokedexVersionGroups and returns the data updated in the database.
     * @param {PokedexVersionGroupUpdateManyAndReturnArgs} args - Arguments to update many PokedexVersionGroups.
     * @example
     * // Update many PokedexVersionGroups
     * const pokedexVersionGroup = await prisma.pokedexVersionGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PokedexVersionGroups and only return the `id`
     * const pokedexVersionGroupWithIdOnly = await prisma.pokedexVersionGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PokedexVersionGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, PokedexVersionGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokedexVersionGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PokedexVersionGroup.
     * @param {PokedexVersionGroupUpsertArgs} args - Arguments to update or create a PokedexVersionGroup.
     * @example
     * // Update or create a PokedexVersionGroup
     * const pokedexVersionGroup = await prisma.pokedexVersionGroup.upsert({
     *   create: {
     *     // ... data to create a PokedexVersionGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PokedexVersionGroup we want to update
     *   }
     * })
     */
    upsert<T extends PokedexVersionGroupUpsertArgs>(args: SelectSubset<T, PokedexVersionGroupUpsertArgs<ExtArgs>>): Prisma__PokedexVersionGroupClient<$Result.GetResult<Prisma.$PokedexVersionGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PokedexVersionGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokedexVersionGroupCountArgs} args - Arguments to filter PokedexVersionGroups to count.
     * @example
     * // Count the number of PokedexVersionGroups
     * const count = await prisma.pokedexVersionGroup.count({
     *   where: {
     *     // ... the filter for the PokedexVersionGroups we want to count
     *   }
     * })
    **/
    count<T extends PokedexVersionGroupCountArgs>(
      args?: Subset<T, PokedexVersionGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PokedexVersionGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PokedexVersionGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokedexVersionGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PokedexVersionGroupAggregateArgs>(args: Subset<T, PokedexVersionGroupAggregateArgs>): Prisma.PrismaPromise<GetPokedexVersionGroupAggregateType<T>>

    /**
     * Group by PokedexVersionGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokedexVersionGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PokedexVersionGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PokedexVersionGroupGroupByArgs['orderBy'] }
        : { orderBy?: PokedexVersionGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PokedexVersionGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPokedexVersionGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PokedexVersionGroup model
   */
  readonly fields: PokedexVersionGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PokedexVersionGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PokedexVersionGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    version_group<T extends VersionGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VersionGroupDefaultArgs<ExtArgs>>): Prisma__VersionGroupClient<$Result.GetResult<Prisma.$VersionGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokedex<T extends PokedexDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PokedexDefaultArgs<ExtArgs>>): Prisma__PokedexClient<$Result.GetResult<Prisma.$PokedexPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PokedexVersionGroup model
   */
  interface PokedexVersionGroupFieldRefs {
    readonly id: FieldRef<"PokedexVersionGroup", 'Int'>
    readonly version_group_id: FieldRef<"PokedexVersionGroup", 'Int'>
    readonly pokedex_id: FieldRef<"PokedexVersionGroup", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PokedexVersionGroup findUnique
   */
  export type PokedexVersionGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokedexVersionGroup
     */
    select?: PokedexVersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokedexVersionGroup
     */
    omit?: PokedexVersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexVersionGroupInclude<ExtArgs> | null
    /**
     * Filter, which PokedexVersionGroup to fetch.
     */
    where: PokedexVersionGroupWhereUniqueInput
  }

  /**
   * PokedexVersionGroup findUniqueOrThrow
   */
  export type PokedexVersionGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokedexVersionGroup
     */
    select?: PokedexVersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokedexVersionGroup
     */
    omit?: PokedexVersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexVersionGroupInclude<ExtArgs> | null
    /**
     * Filter, which PokedexVersionGroup to fetch.
     */
    where: PokedexVersionGroupWhereUniqueInput
  }

  /**
   * PokedexVersionGroup findFirst
   */
  export type PokedexVersionGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokedexVersionGroup
     */
    select?: PokedexVersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokedexVersionGroup
     */
    omit?: PokedexVersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexVersionGroupInclude<ExtArgs> | null
    /**
     * Filter, which PokedexVersionGroup to fetch.
     */
    where?: PokedexVersionGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokedexVersionGroups to fetch.
     */
    orderBy?: PokedexVersionGroupOrderByWithRelationInput | PokedexVersionGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PokedexVersionGroups.
     */
    cursor?: PokedexVersionGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokedexVersionGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokedexVersionGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PokedexVersionGroups.
     */
    distinct?: PokedexVersionGroupScalarFieldEnum | PokedexVersionGroupScalarFieldEnum[]
  }

  /**
   * PokedexVersionGroup findFirstOrThrow
   */
  export type PokedexVersionGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokedexVersionGroup
     */
    select?: PokedexVersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokedexVersionGroup
     */
    omit?: PokedexVersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexVersionGroupInclude<ExtArgs> | null
    /**
     * Filter, which PokedexVersionGroup to fetch.
     */
    where?: PokedexVersionGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokedexVersionGroups to fetch.
     */
    orderBy?: PokedexVersionGroupOrderByWithRelationInput | PokedexVersionGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PokedexVersionGroups.
     */
    cursor?: PokedexVersionGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokedexVersionGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokedexVersionGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PokedexVersionGroups.
     */
    distinct?: PokedexVersionGroupScalarFieldEnum | PokedexVersionGroupScalarFieldEnum[]
  }

  /**
   * PokedexVersionGroup findMany
   */
  export type PokedexVersionGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokedexVersionGroup
     */
    select?: PokedexVersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokedexVersionGroup
     */
    omit?: PokedexVersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexVersionGroupInclude<ExtArgs> | null
    /**
     * Filter, which PokedexVersionGroups to fetch.
     */
    where?: PokedexVersionGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokedexVersionGroups to fetch.
     */
    orderBy?: PokedexVersionGroupOrderByWithRelationInput | PokedexVersionGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PokedexVersionGroups.
     */
    cursor?: PokedexVersionGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokedexVersionGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokedexVersionGroups.
     */
    skip?: number
    distinct?: PokedexVersionGroupScalarFieldEnum | PokedexVersionGroupScalarFieldEnum[]
  }

  /**
   * PokedexVersionGroup create
   */
  export type PokedexVersionGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokedexVersionGroup
     */
    select?: PokedexVersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokedexVersionGroup
     */
    omit?: PokedexVersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexVersionGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a PokedexVersionGroup.
     */
    data: XOR<PokedexVersionGroupCreateInput, PokedexVersionGroupUncheckedCreateInput>
  }

  /**
   * PokedexVersionGroup createMany
   */
  export type PokedexVersionGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PokedexVersionGroups.
     */
    data: PokedexVersionGroupCreateManyInput | PokedexVersionGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PokedexVersionGroup createManyAndReturn
   */
  export type PokedexVersionGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokedexVersionGroup
     */
    select?: PokedexVersionGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PokedexVersionGroup
     */
    omit?: PokedexVersionGroupOmit<ExtArgs> | null
    /**
     * The data used to create many PokedexVersionGroups.
     */
    data: PokedexVersionGroupCreateManyInput | PokedexVersionGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexVersionGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PokedexVersionGroup update
   */
  export type PokedexVersionGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokedexVersionGroup
     */
    select?: PokedexVersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokedexVersionGroup
     */
    omit?: PokedexVersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexVersionGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a PokedexVersionGroup.
     */
    data: XOR<PokedexVersionGroupUpdateInput, PokedexVersionGroupUncheckedUpdateInput>
    /**
     * Choose, which PokedexVersionGroup to update.
     */
    where: PokedexVersionGroupWhereUniqueInput
  }

  /**
   * PokedexVersionGroup updateMany
   */
  export type PokedexVersionGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PokedexVersionGroups.
     */
    data: XOR<PokedexVersionGroupUpdateManyMutationInput, PokedexVersionGroupUncheckedUpdateManyInput>
    /**
     * Filter which PokedexVersionGroups to update
     */
    where?: PokedexVersionGroupWhereInput
    /**
     * Limit how many PokedexVersionGroups to update.
     */
    limit?: number
  }

  /**
   * PokedexVersionGroup updateManyAndReturn
   */
  export type PokedexVersionGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokedexVersionGroup
     */
    select?: PokedexVersionGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PokedexVersionGroup
     */
    omit?: PokedexVersionGroupOmit<ExtArgs> | null
    /**
     * The data used to update PokedexVersionGroups.
     */
    data: XOR<PokedexVersionGroupUpdateManyMutationInput, PokedexVersionGroupUncheckedUpdateManyInput>
    /**
     * Filter which PokedexVersionGroups to update
     */
    where?: PokedexVersionGroupWhereInput
    /**
     * Limit how many PokedexVersionGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexVersionGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PokedexVersionGroup upsert
   */
  export type PokedexVersionGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokedexVersionGroup
     */
    select?: PokedexVersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokedexVersionGroup
     */
    omit?: PokedexVersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexVersionGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the PokedexVersionGroup to update in case it exists.
     */
    where: PokedexVersionGroupWhereUniqueInput
    /**
     * In case the PokedexVersionGroup found by the `where` argument doesn't exist, create a new PokedexVersionGroup with this data.
     */
    create: XOR<PokedexVersionGroupCreateInput, PokedexVersionGroupUncheckedCreateInput>
    /**
     * In case the PokedexVersionGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PokedexVersionGroupUpdateInput, PokedexVersionGroupUncheckedUpdateInput>
  }

  /**
   * PokedexVersionGroup delete
   */
  export type PokedexVersionGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokedexVersionGroup
     */
    select?: PokedexVersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokedexVersionGroup
     */
    omit?: PokedexVersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexVersionGroupInclude<ExtArgs> | null
    /**
     * Filter which PokedexVersionGroup to delete.
     */
    where: PokedexVersionGroupWhereUniqueInput
  }

  /**
   * PokedexVersionGroup deleteMany
   */
  export type PokedexVersionGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PokedexVersionGroups to delete
     */
    where?: PokedexVersionGroupWhereInput
    /**
     * Limit how many PokedexVersionGroups to delete.
     */
    limit?: number
  }

  /**
   * PokedexVersionGroup without action
   */
  export type PokedexVersionGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokedexVersionGroup
     */
    select?: PokedexVersionGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokedexVersionGroup
     */
    omit?: PokedexVersionGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokedexVersionGroupInclude<ExtArgs> | null
  }


  /**
   * Model PokemonDexNumber
   */

  export type AggregatePokemonDexNumber = {
    _count: PokemonDexNumberCountAggregateOutputType | null
    _avg: PokemonDexNumberAvgAggregateOutputType | null
    _sum: PokemonDexNumberSumAggregateOutputType | null
    _min: PokemonDexNumberMinAggregateOutputType | null
    _max: PokemonDexNumberMaxAggregateOutputType | null
  }

  export type PokemonDexNumberAvgAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    pokedex_id: number | null
    pokedex_number: number | null
  }

  export type PokemonDexNumberSumAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    pokedex_id: number | null
    pokedex_number: number | null
  }

  export type PokemonDexNumberMinAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    pokedex_id: number | null
    pokedex_number: number | null
  }

  export type PokemonDexNumberMaxAggregateOutputType = {
    id: number | null
    pokemon_id: number | null
    pokedex_id: number | null
    pokedex_number: number | null
  }

  export type PokemonDexNumberCountAggregateOutputType = {
    id: number
    pokemon_id: number
    pokedex_id: number
    pokedex_number: number
    _all: number
  }


  export type PokemonDexNumberAvgAggregateInputType = {
    id?: true
    pokemon_id?: true
    pokedex_id?: true
    pokedex_number?: true
  }

  export type PokemonDexNumberSumAggregateInputType = {
    id?: true
    pokemon_id?: true
    pokedex_id?: true
    pokedex_number?: true
  }

  export type PokemonDexNumberMinAggregateInputType = {
    id?: true
    pokemon_id?: true
    pokedex_id?: true
    pokedex_number?: true
  }

  export type PokemonDexNumberMaxAggregateInputType = {
    id?: true
    pokemon_id?: true
    pokedex_id?: true
    pokedex_number?: true
  }

  export type PokemonDexNumberCountAggregateInputType = {
    id?: true
    pokemon_id?: true
    pokedex_id?: true
    pokedex_number?: true
    _all?: true
  }

  export type PokemonDexNumberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PokemonDexNumber to aggregate.
     */
    where?: PokemonDexNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonDexNumbers to fetch.
     */
    orderBy?: PokemonDexNumberOrderByWithRelationInput | PokemonDexNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PokemonDexNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonDexNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonDexNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PokemonDexNumbers
    **/
    _count?: true | PokemonDexNumberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PokemonDexNumberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PokemonDexNumberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PokemonDexNumberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PokemonDexNumberMaxAggregateInputType
  }

  export type GetPokemonDexNumberAggregateType<T extends PokemonDexNumberAggregateArgs> = {
        [P in keyof T & keyof AggregatePokemonDexNumber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePokemonDexNumber[P]>
      : GetScalarType<T[P], AggregatePokemonDexNumber[P]>
  }




  export type PokemonDexNumberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PokemonDexNumberWhereInput
    orderBy?: PokemonDexNumberOrderByWithAggregationInput | PokemonDexNumberOrderByWithAggregationInput[]
    by: PokemonDexNumberScalarFieldEnum[] | PokemonDexNumberScalarFieldEnum
    having?: PokemonDexNumberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PokemonDexNumberCountAggregateInputType | true
    _avg?: PokemonDexNumberAvgAggregateInputType
    _sum?: PokemonDexNumberSumAggregateInputType
    _min?: PokemonDexNumberMinAggregateInputType
    _max?: PokemonDexNumberMaxAggregateInputType
  }

  export type PokemonDexNumberGroupByOutputType = {
    id: number
    pokemon_id: number
    pokedex_id: number
    pokedex_number: number
    _count: PokemonDexNumberCountAggregateOutputType | null
    _avg: PokemonDexNumberAvgAggregateOutputType | null
    _sum: PokemonDexNumberSumAggregateOutputType | null
    _min: PokemonDexNumberMinAggregateOutputType | null
    _max: PokemonDexNumberMaxAggregateOutputType | null
  }

  type GetPokemonDexNumberGroupByPayload<T extends PokemonDexNumberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PokemonDexNumberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PokemonDexNumberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PokemonDexNumberGroupByOutputType[P]>
            : GetScalarType<T[P], PokemonDexNumberGroupByOutputType[P]>
        }
      >
    >


  export type PokemonDexNumberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pokemon_id?: boolean
    pokedex_id?: boolean
    pokedex_number?: boolean
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    pokedex?: boolean | PokedexDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonDexNumber"]>

  export type PokemonDexNumberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pokemon_id?: boolean
    pokedex_id?: boolean
    pokedex_number?: boolean
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    pokedex?: boolean | PokedexDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonDexNumber"]>

  export type PokemonDexNumberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pokemon_id?: boolean
    pokedex_id?: boolean
    pokedex_number?: boolean
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    pokedex?: boolean | PokedexDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pokemonDexNumber"]>

  export type PokemonDexNumberSelectScalar = {
    id?: boolean
    pokemon_id?: boolean
    pokedex_id?: boolean
    pokedex_number?: boolean
  }

  export type PokemonDexNumberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pokemon_id" | "pokedex_id" | "pokedex_number", ExtArgs["result"]["pokemonDexNumber"]>
  export type PokemonDexNumberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    pokedex?: boolean | PokedexDefaultArgs<ExtArgs>
  }
  export type PokemonDexNumberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    pokedex?: boolean | PokedexDefaultArgs<ExtArgs>
  }
  export type PokemonDexNumberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pokemon?: boolean | PokemonDefaultArgs<ExtArgs>
    pokedex?: boolean | PokedexDefaultArgs<ExtArgs>
  }

  export type $PokemonDexNumberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PokemonDexNumber"
    objects: {
      pokemon: Prisma.$PokemonPayload<ExtArgs>
      pokedex: Prisma.$PokedexPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pokemon_id: number
      pokedex_id: number
      pokedex_number: number
    }, ExtArgs["result"]["pokemonDexNumber"]>
    composites: {}
  }

  type PokemonDexNumberGetPayload<S extends boolean | null | undefined | PokemonDexNumberDefaultArgs> = $Result.GetResult<Prisma.$PokemonDexNumberPayload, S>

  type PokemonDexNumberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PokemonDexNumberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PokemonDexNumberCountAggregateInputType | true
    }

  export interface PokemonDexNumberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PokemonDexNumber'], meta: { name: 'PokemonDexNumber' } }
    /**
     * Find zero or one PokemonDexNumber that matches the filter.
     * @param {PokemonDexNumberFindUniqueArgs} args - Arguments to find a PokemonDexNumber
     * @example
     * // Get one PokemonDexNumber
     * const pokemonDexNumber = await prisma.pokemonDexNumber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PokemonDexNumberFindUniqueArgs>(args: SelectSubset<T, PokemonDexNumberFindUniqueArgs<ExtArgs>>): Prisma__PokemonDexNumberClient<$Result.GetResult<Prisma.$PokemonDexNumberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PokemonDexNumber that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PokemonDexNumberFindUniqueOrThrowArgs} args - Arguments to find a PokemonDexNumber
     * @example
     * // Get one PokemonDexNumber
     * const pokemonDexNumber = await prisma.pokemonDexNumber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PokemonDexNumberFindUniqueOrThrowArgs>(args: SelectSubset<T, PokemonDexNumberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PokemonDexNumberClient<$Result.GetResult<Prisma.$PokemonDexNumberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PokemonDexNumber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonDexNumberFindFirstArgs} args - Arguments to find a PokemonDexNumber
     * @example
     * // Get one PokemonDexNumber
     * const pokemonDexNumber = await prisma.pokemonDexNumber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PokemonDexNumberFindFirstArgs>(args?: SelectSubset<T, PokemonDexNumberFindFirstArgs<ExtArgs>>): Prisma__PokemonDexNumberClient<$Result.GetResult<Prisma.$PokemonDexNumberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PokemonDexNumber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonDexNumberFindFirstOrThrowArgs} args - Arguments to find a PokemonDexNumber
     * @example
     * // Get one PokemonDexNumber
     * const pokemonDexNumber = await prisma.pokemonDexNumber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PokemonDexNumberFindFirstOrThrowArgs>(args?: SelectSubset<T, PokemonDexNumberFindFirstOrThrowArgs<ExtArgs>>): Prisma__PokemonDexNumberClient<$Result.GetResult<Prisma.$PokemonDexNumberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PokemonDexNumbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonDexNumberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PokemonDexNumbers
     * const pokemonDexNumbers = await prisma.pokemonDexNumber.findMany()
     * 
     * // Get first 10 PokemonDexNumbers
     * const pokemonDexNumbers = await prisma.pokemonDexNumber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pokemonDexNumberWithIdOnly = await prisma.pokemonDexNumber.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PokemonDexNumberFindManyArgs>(args?: SelectSubset<T, PokemonDexNumberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonDexNumberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PokemonDexNumber.
     * @param {PokemonDexNumberCreateArgs} args - Arguments to create a PokemonDexNumber.
     * @example
     * // Create one PokemonDexNumber
     * const PokemonDexNumber = await prisma.pokemonDexNumber.create({
     *   data: {
     *     // ... data to create a PokemonDexNumber
     *   }
     * })
     * 
     */
    create<T extends PokemonDexNumberCreateArgs>(args: SelectSubset<T, PokemonDexNumberCreateArgs<ExtArgs>>): Prisma__PokemonDexNumberClient<$Result.GetResult<Prisma.$PokemonDexNumberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PokemonDexNumbers.
     * @param {PokemonDexNumberCreateManyArgs} args - Arguments to create many PokemonDexNumbers.
     * @example
     * // Create many PokemonDexNumbers
     * const pokemonDexNumber = await prisma.pokemonDexNumber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PokemonDexNumberCreateManyArgs>(args?: SelectSubset<T, PokemonDexNumberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PokemonDexNumbers and returns the data saved in the database.
     * @param {PokemonDexNumberCreateManyAndReturnArgs} args - Arguments to create many PokemonDexNumbers.
     * @example
     * // Create many PokemonDexNumbers
     * const pokemonDexNumber = await prisma.pokemonDexNumber.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PokemonDexNumbers and only return the `id`
     * const pokemonDexNumberWithIdOnly = await prisma.pokemonDexNumber.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PokemonDexNumberCreateManyAndReturnArgs>(args?: SelectSubset<T, PokemonDexNumberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonDexNumberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PokemonDexNumber.
     * @param {PokemonDexNumberDeleteArgs} args - Arguments to delete one PokemonDexNumber.
     * @example
     * // Delete one PokemonDexNumber
     * const PokemonDexNumber = await prisma.pokemonDexNumber.delete({
     *   where: {
     *     // ... filter to delete one PokemonDexNumber
     *   }
     * })
     * 
     */
    delete<T extends PokemonDexNumberDeleteArgs>(args: SelectSubset<T, PokemonDexNumberDeleteArgs<ExtArgs>>): Prisma__PokemonDexNumberClient<$Result.GetResult<Prisma.$PokemonDexNumberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PokemonDexNumber.
     * @param {PokemonDexNumberUpdateArgs} args - Arguments to update one PokemonDexNumber.
     * @example
     * // Update one PokemonDexNumber
     * const pokemonDexNumber = await prisma.pokemonDexNumber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PokemonDexNumberUpdateArgs>(args: SelectSubset<T, PokemonDexNumberUpdateArgs<ExtArgs>>): Prisma__PokemonDexNumberClient<$Result.GetResult<Prisma.$PokemonDexNumberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PokemonDexNumbers.
     * @param {PokemonDexNumberDeleteManyArgs} args - Arguments to filter PokemonDexNumbers to delete.
     * @example
     * // Delete a few PokemonDexNumbers
     * const { count } = await prisma.pokemonDexNumber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PokemonDexNumberDeleteManyArgs>(args?: SelectSubset<T, PokemonDexNumberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PokemonDexNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonDexNumberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PokemonDexNumbers
     * const pokemonDexNumber = await prisma.pokemonDexNumber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PokemonDexNumberUpdateManyArgs>(args: SelectSubset<T, PokemonDexNumberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PokemonDexNumbers and returns the data updated in the database.
     * @param {PokemonDexNumberUpdateManyAndReturnArgs} args - Arguments to update many PokemonDexNumbers.
     * @example
     * // Update many PokemonDexNumbers
     * const pokemonDexNumber = await prisma.pokemonDexNumber.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PokemonDexNumbers and only return the `id`
     * const pokemonDexNumberWithIdOnly = await prisma.pokemonDexNumber.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PokemonDexNumberUpdateManyAndReturnArgs>(args: SelectSubset<T, PokemonDexNumberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PokemonDexNumberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PokemonDexNumber.
     * @param {PokemonDexNumberUpsertArgs} args - Arguments to update or create a PokemonDexNumber.
     * @example
     * // Update or create a PokemonDexNumber
     * const pokemonDexNumber = await prisma.pokemonDexNumber.upsert({
     *   create: {
     *     // ... data to create a PokemonDexNumber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PokemonDexNumber we want to update
     *   }
     * })
     */
    upsert<T extends PokemonDexNumberUpsertArgs>(args: SelectSubset<T, PokemonDexNumberUpsertArgs<ExtArgs>>): Prisma__PokemonDexNumberClient<$Result.GetResult<Prisma.$PokemonDexNumberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PokemonDexNumbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonDexNumberCountArgs} args - Arguments to filter PokemonDexNumbers to count.
     * @example
     * // Count the number of PokemonDexNumbers
     * const count = await prisma.pokemonDexNumber.count({
     *   where: {
     *     // ... the filter for the PokemonDexNumbers we want to count
     *   }
     * })
    **/
    count<T extends PokemonDexNumberCountArgs>(
      args?: Subset<T, PokemonDexNumberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PokemonDexNumberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PokemonDexNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonDexNumberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PokemonDexNumberAggregateArgs>(args: Subset<T, PokemonDexNumberAggregateArgs>): Prisma.PrismaPromise<GetPokemonDexNumberAggregateType<T>>

    /**
     * Group by PokemonDexNumber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PokemonDexNumberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PokemonDexNumberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PokemonDexNumberGroupByArgs['orderBy'] }
        : { orderBy?: PokemonDexNumberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PokemonDexNumberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPokemonDexNumberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PokemonDexNumber model
   */
  readonly fields: PokemonDexNumberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PokemonDexNumber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PokemonDexNumberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pokemon<T extends PokemonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PokemonDefaultArgs<ExtArgs>>): Prisma__PokemonClient<$Result.GetResult<Prisma.$PokemonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pokedex<T extends PokedexDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PokedexDefaultArgs<ExtArgs>>): Prisma__PokedexClient<$Result.GetResult<Prisma.$PokedexPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PokemonDexNumber model
   */
  interface PokemonDexNumberFieldRefs {
    readonly id: FieldRef<"PokemonDexNumber", 'Int'>
    readonly pokemon_id: FieldRef<"PokemonDexNumber", 'Int'>
    readonly pokedex_id: FieldRef<"PokemonDexNumber", 'Int'>
    readonly pokedex_number: FieldRef<"PokemonDexNumber", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PokemonDexNumber findUnique
   */
  export type PokemonDexNumberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonDexNumber
     */
    select?: PokemonDexNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonDexNumber
     */
    omit?: PokemonDexNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonDexNumberInclude<ExtArgs> | null
    /**
     * Filter, which PokemonDexNumber to fetch.
     */
    where: PokemonDexNumberWhereUniqueInput
  }

  /**
   * PokemonDexNumber findUniqueOrThrow
   */
  export type PokemonDexNumberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonDexNumber
     */
    select?: PokemonDexNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonDexNumber
     */
    omit?: PokemonDexNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonDexNumberInclude<ExtArgs> | null
    /**
     * Filter, which PokemonDexNumber to fetch.
     */
    where: PokemonDexNumberWhereUniqueInput
  }

  /**
   * PokemonDexNumber findFirst
   */
  export type PokemonDexNumberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonDexNumber
     */
    select?: PokemonDexNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonDexNumber
     */
    omit?: PokemonDexNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonDexNumberInclude<ExtArgs> | null
    /**
     * Filter, which PokemonDexNumber to fetch.
     */
    where?: PokemonDexNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonDexNumbers to fetch.
     */
    orderBy?: PokemonDexNumberOrderByWithRelationInput | PokemonDexNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PokemonDexNumbers.
     */
    cursor?: PokemonDexNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonDexNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonDexNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PokemonDexNumbers.
     */
    distinct?: PokemonDexNumberScalarFieldEnum | PokemonDexNumberScalarFieldEnum[]
  }

  /**
   * PokemonDexNumber findFirstOrThrow
   */
  export type PokemonDexNumberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonDexNumber
     */
    select?: PokemonDexNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonDexNumber
     */
    omit?: PokemonDexNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonDexNumberInclude<ExtArgs> | null
    /**
     * Filter, which PokemonDexNumber to fetch.
     */
    where?: PokemonDexNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonDexNumbers to fetch.
     */
    orderBy?: PokemonDexNumberOrderByWithRelationInput | PokemonDexNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PokemonDexNumbers.
     */
    cursor?: PokemonDexNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonDexNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonDexNumbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PokemonDexNumbers.
     */
    distinct?: PokemonDexNumberScalarFieldEnum | PokemonDexNumberScalarFieldEnum[]
  }

  /**
   * PokemonDexNumber findMany
   */
  export type PokemonDexNumberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonDexNumber
     */
    select?: PokemonDexNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonDexNumber
     */
    omit?: PokemonDexNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonDexNumberInclude<ExtArgs> | null
    /**
     * Filter, which PokemonDexNumbers to fetch.
     */
    where?: PokemonDexNumberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PokemonDexNumbers to fetch.
     */
    orderBy?: PokemonDexNumberOrderByWithRelationInput | PokemonDexNumberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PokemonDexNumbers.
     */
    cursor?: PokemonDexNumberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PokemonDexNumbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PokemonDexNumbers.
     */
    skip?: number
    distinct?: PokemonDexNumberScalarFieldEnum | PokemonDexNumberScalarFieldEnum[]
  }

  /**
   * PokemonDexNumber create
   */
  export type PokemonDexNumberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonDexNumber
     */
    select?: PokemonDexNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonDexNumber
     */
    omit?: PokemonDexNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonDexNumberInclude<ExtArgs> | null
    /**
     * The data needed to create a PokemonDexNumber.
     */
    data: XOR<PokemonDexNumberCreateInput, PokemonDexNumberUncheckedCreateInput>
  }

  /**
   * PokemonDexNumber createMany
   */
  export type PokemonDexNumberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PokemonDexNumbers.
     */
    data: PokemonDexNumberCreateManyInput | PokemonDexNumberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PokemonDexNumber createManyAndReturn
   */
  export type PokemonDexNumberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonDexNumber
     */
    select?: PokemonDexNumberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonDexNumber
     */
    omit?: PokemonDexNumberOmit<ExtArgs> | null
    /**
     * The data used to create many PokemonDexNumbers.
     */
    data: PokemonDexNumberCreateManyInput | PokemonDexNumberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonDexNumberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PokemonDexNumber update
   */
  export type PokemonDexNumberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonDexNumber
     */
    select?: PokemonDexNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonDexNumber
     */
    omit?: PokemonDexNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonDexNumberInclude<ExtArgs> | null
    /**
     * The data needed to update a PokemonDexNumber.
     */
    data: XOR<PokemonDexNumberUpdateInput, PokemonDexNumberUncheckedUpdateInput>
    /**
     * Choose, which PokemonDexNumber to update.
     */
    where: PokemonDexNumberWhereUniqueInput
  }

  /**
   * PokemonDexNumber updateMany
   */
  export type PokemonDexNumberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PokemonDexNumbers.
     */
    data: XOR<PokemonDexNumberUpdateManyMutationInput, PokemonDexNumberUncheckedUpdateManyInput>
    /**
     * Filter which PokemonDexNumbers to update
     */
    where?: PokemonDexNumberWhereInput
    /**
     * Limit how many PokemonDexNumbers to update.
     */
    limit?: number
  }

  /**
   * PokemonDexNumber updateManyAndReturn
   */
  export type PokemonDexNumberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonDexNumber
     */
    select?: PokemonDexNumberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonDexNumber
     */
    omit?: PokemonDexNumberOmit<ExtArgs> | null
    /**
     * The data used to update PokemonDexNumbers.
     */
    data: XOR<PokemonDexNumberUpdateManyMutationInput, PokemonDexNumberUncheckedUpdateManyInput>
    /**
     * Filter which PokemonDexNumbers to update
     */
    where?: PokemonDexNumberWhereInput
    /**
     * Limit how many PokemonDexNumbers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonDexNumberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PokemonDexNumber upsert
   */
  export type PokemonDexNumberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonDexNumber
     */
    select?: PokemonDexNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonDexNumber
     */
    omit?: PokemonDexNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonDexNumberInclude<ExtArgs> | null
    /**
     * The filter to search for the PokemonDexNumber to update in case it exists.
     */
    where: PokemonDexNumberWhereUniqueInput
    /**
     * In case the PokemonDexNumber found by the `where` argument doesn't exist, create a new PokemonDexNumber with this data.
     */
    create: XOR<PokemonDexNumberCreateInput, PokemonDexNumberUncheckedCreateInput>
    /**
     * In case the PokemonDexNumber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PokemonDexNumberUpdateInput, PokemonDexNumberUncheckedUpdateInput>
  }

  /**
   * PokemonDexNumber delete
   */
  export type PokemonDexNumberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonDexNumber
     */
    select?: PokemonDexNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonDexNumber
     */
    omit?: PokemonDexNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonDexNumberInclude<ExtArgs> | null
    /**
     * Filter which PokemonDexNumber to delete.
     */
    where: PokemonDexNumberWhereUniqueInput
  }

  /**
   * PokemonDexNumber deleteMany
   */
  export type PokemonDexNumberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PokemonDexNumbers to delete
     */
    where?: PokemonDexNumberWhereInput
    /**
     * Limit how many PokemonDexNumbers to delete.
     */
    limit?: number
  }

  /**
   * PokemonDexNumber without action
   */
  export type PokemonDexNumberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PokemonDexNumber
     */
    select?: PokemonDexNumberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PokemonDexNumber
     */
    omit?: PokemonDexNumberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PokemonDexNumberInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    role: 'role',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PokemonScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type PokemonScalarFieldEnum = (typeof PokemonScalarFieldEnum)[keyof typeof PokemonScalarFieldEnum]


  export const AbilityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type AbilityScalarFieldEnum = (typeof AbilityScalarFieldEnum)[keyof typeof AbilityScalarFieldEnum]


  export const PokemonAbilityScalarFieldEnum: {
    id: 'id',
    pokemon_id: 'pokemon_id',
    ability_id: 'ability_id',
    is_hidden: 'is_hidden'
  };

  export type PokemonAbilityScalarFieldEnum = (typeof PokemonAbilityScalarFieldEnum)[keyof typeof PokemonAbilityScalarFieldEnum]


  export const NatureScalarFieldEnum: {
    id: 'id',
    name: 'name',
    increased_stat_id: 'increased_stat_id',
    decreased_stat_id: 'decreased_stat_id'
  };

  export type NatureScalarFieldEnum = (typeof NatureScalarFieldEnum)[keyof typeof NatureScalarFieldEnum]


  export const PokemonNatureScalarFieldEnum: {
    id: 'id',
    pokemon_id: 'pokemon_id',
    nature_id: 'nature_id'
  };

  export type PokemonNatureScalarFieldEnum = (typeof PokemonNatureScalarFieldEnum)[keyof typeof PokemonNatureScalarFieldEnum]


  export const StatScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type StatScalarFieldEnum = (typeof StatScalarFieldEnum)[keyof typeof StatScalarFieldEnum]


  export const PokemonStatScalarFieldEnum: {
    id: 'id',
    pokemon_id: 'pokemon_id',
    stat_id: 'stat_id',
    base_stat: 'base_stat'
  };

  export type PokemonStatScalarFieldEnum = (typeof PokemonStatScalarFieldEnum)[keyof typeof PokemonStatScalarFieldEnum]


  export const TypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    generation_id: 'generation_id'
  };

  export type TypeScalarFieldEnum = (typeof TypeScalarFieldEnum)[keyof typeof TypeScalarFieldEnum]


  export const TypeEffectivenessScalarFieldEnum: {
    id: 'id',
    type_id: 'type_id',
    target_type_id: 'target_type_id',
    damage_factor: 'damage_factor'
  };

  export type TypeEffectivenessScalarFieldEnum = (typeof TypeEffectivenessScalarFieldEnum)[keyof typeof TypeEffectivenessScalarFieldEnum]


  export const PokemonTypeScalarFieldEnum: {
    id: 'id',
    pokemon_id: 'pokemon_id',
    type_id: 'type_id'
  };

  export type PokemonTypeScalarFieldEnum = (typeof PokemonTypeScalarFieldEnum)[keyof typeof PokemonTypeScalarFieldEnum]


  export const EggGroupScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type EggGroupScalarFieldEnum = (typeof EggGroupScalarFieldEnum)[keyof typeof EggGroupScalarFieldEnum]


  export const PokemonEggGroupScalarFieldEnum: {
    id: 'id',
    pokemon_id: 'pokemon_id',
    egg_group_id: 'egg_group_id'
  };

  export type PokemonEggGroupScalarFieldEnum = (typeof PokemonEggGroupScalarFieldEnum)[keyof typeof PokemonEggGroupScalarFieldEnum]


  export const RegionScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RegionScalarFieldEnum = (typeof RegionScalarFieldEnum)[keyof typeof RegionScalarFieldEnum]


  export const GenerationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    region_id: 'region_id'
  };

  export type GenerationScalarFieldEnum = (typeof GenerationScalarFieldEnum)[keyof typeof GenerationScalarFieldEnum]


  export const VersionGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    generation_id: 'generation_id'
  };

  export type VersionGroupScalarFieldEnum = (typeof VersionGroupScalarFieldEnum)[keyof typeof VersionGroupScalarFieldEnum]


  export const VersionGroupRegionScalarFieldEnum: {
    id: 'id',
    version_group_id: 'version_group_id',
    region_id: 'region_id'
  };

  export type VersionGroupRegionScalarFieldEnum = (typeof VersionGroupRegionScalarFieldEnum)[keyof typeof VersionGroupRegionScalarFieldEnum]


  export const VersionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    version_group_id: 'version_group_id'
  };

  export type VersionScalarFieldEnum = (typeof VersionScalarFieldEnum)[keyof typeof VersionScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    region_id: 'region_id'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const LocationAreaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location_id: 'location_id'
  };

  export type LocationAreaScalarFieldEnum = (typeof LocationAreaScalarFieldEnum)[keyof typeof LocationAreaScalarFieldEnum]


  export const EncounterMethodScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type EncounterMethodScalarFieldEnum = (typeof EncounterMethodScalarFieldEnum)[keyof typeof EncounterMethodScalarFieldEnum]


  export const EncounterSlotScalarFieldEnum: {
    id: 'id',
    version_group_id: 'version_group_id',
    encounter_method_id: 'encounter_method_id',
    slot: 'slot',
    rarity: 'rarity'
  };

  export type EncounterSlotScalarFieldEnum = (typeof EncounterSlotScalarFieldEnum)[keyof typeof EncounterSlotScalarFieldEnum]


  export const EncounterScalarFieldEnum: {
    id: 'id',
    version_id: 'version_id',
    pokemon_id: 'pokemon_id',
    location_area_id: 'location_area_id',
    encounter_slot_id: 'encounter_slot_id',
    min_level: 'min_level',
    max_level: 'max_level'
  };

  export type EncounterScalarFieldEnum = (typeof EncounterScalarFieldEnum)[keyof typeof EncounterScalarFieldEnum]


  export const EncounterConditionScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type EncounterConditionScalarFieldEnum = (typeof EncounterConditionScalarFieldEnum)[keyof typeof EncounterConditionScalarFieldEnum]


  export const EncounterConditionValueScalarFieldEnum: {
    id: 'id',
    encounter_condition_id: 'encounter_condition_id',
    name: 'name',
    is_default: 'is_default'
  };

  export type EncounterConditionValueScalarFieldEnum = (typeof EncounterConditionValueScalarFieldEnum)[keyof typeof EncounterConditionValueScalarFieldEnum]


  export const EncounterConditionValueMapScalarFieldEnum: {
    id: 'id',
    encounter_id: 'encounter_id',
    encounter_condition_value_id: 'encounter_condition_value_id'
  };

  export type EncounterConditionValueMapScalarFieldEnum = (typeof EncounterConditionValueMapScalarFieldEnum)[keyof typeof EncounterConditionValueMapScalarFieldEnum]


  export const LocationAreaEncounterRateScalarFieldEnum: {
    id: 'id',
    location_area_id: 'location_area_id',
    encounter_method_id: 'encounter_method_id',
    version_id: 'version_id',
    rate: 'rate'
  };

  export type LocationAreaEncounterRateScalarFieldEnum = (typeof LocationAreaEncounterRateScalarFieldEnum)[keyof typeof LocationAreaEncounterRateScalarFieldEnum]


  export const MoveDamageClassScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type MoveDamageClassScalarFieldEnum = (typeof MoveDamageClassScalarFieldEnum)[keyof typeof MoveDamageClassScalarFieldEnum]


  export const MoveEffectScalarFieldEnum: {
    id: 'id',
    description: 'description'
  };

  export type MoveEffectScalarFieldEnum = (typeof MoveEffectScalarFieldEnum)[keyof typeof MoveEffectScalarFieldEnum]


  export const MoveMethodScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type MoveMethodScalarFieldEnum = (typeof MoveMethodScalarFieldEnum)[keyof typeof MoveMethodScalarFieldEnum]


  export const MoveScalarFieldEnum: {
    id: 'id',
    name: 'name',
    generation_id: 'generation_id',
    type_id: 'type_id',
    pp: 'pp',
    accuracy: 'accuracy',
    priority: 'priority',
    move_damage_class_id: 'move_damage_class_id',
    move_effect_id: 'move_effect_id'
  };

  export type MoveScalarFieldEnum = (typeof MoveScalarFieldEnum)[keyof typeof MoveScalarFieldEnum]


  export const PokemonMoveScalarFieldEnum: {
    id: 'id',
    version_group_id: 'version_group_id',
    move_method_id: 'move_method_id',
    move_id: 'move_id',
    pokemon_id: 'pokemon_id',
    level: 'level'
  };

  export type PokemonMoveScalarFieldEnum = (typeof PokemonMoveScalarFieldEnum)[keyof typeof PokemonMoveScalarFieldEnum]


  export const PokedexScalarFieldEnum: {
    id: 'id',
    name: 'name',
    region_id: 'region_id'
  };

  export type PokedexScalarFieldEnum = (typeof PokedexScalarFieldEnum)[keyof typeof PokedexScalarFieldEnum]


  export const PokedexVersionGroupScalarFieldEnum: {
    id: 'id',
    version_group_id: 'version_group_id',
    pokedex_id: 'pokedex_id'
  };

  export type PokedexVersionGroupScalarFieldEnum = (typeof PokedexVersionGroupScalarFieldEnum)[keyof typeof PokedexVersionGroupScalarFieldEnum]


  export const PokemonDexNumberScalarFieldEnum: {
    id: 'id',
    pokemon_id: 'pokemon_id',
    pokedex_id: 'pokedex_id',
    pokedex_number: 'pokedex_number'
  };

  export type PokemonDexNumberScalarFieldEnum = (typeof PokemonDexNumberScalarFieldEnum)[keyof typeof PokemonDexNumberScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type PokemonWhereInput = {
    AND?: PokemonWhereInput | PokemonWhereInput[]
    OR?: PokemonWhereInput[]
    NOT?: PokemonWhereInput | PokemonWhereInput[]
    id?: IntFilter<"Pokemon"> | number
    name?: StringFilter<"Pokemon"> | string
    abilities?: PokemonAbilityListRelationFilter
    natures?: PokemonNatureListRelationFilter
    stats?: PokemonStatListRelationFilter
    types?: PokemonTypeListRelationFilter
    egg_groups?: PokemonEggGroupListRelationFilter
    encounters?: EncounterListRelationFilter
    dex_numbers?: PokemonDexNumberListRelationFilter
    move?: PokemonMoveListRelationFilter
  }

  export type PokemonOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    abilities?: PokemonAbilityOrderByRelationAggregateInput
    natures?: PokemonNatureOrderByRelationAggregateInput
    stats?: PokemonStatOrderByRelationAggregateInput
    types?: PokemonTypeOrderByRelationAggregateInput
    egg_groups?: PokemonEggGroupOrderByRelationAggregateInput
    encounters?: EncounterOrderByRelationAggregateInput
    dex_numbers?: PokemonDexNumberOrderByRelationAggregateInput
    move?: PokemonMoveOrderByRelationAggregateInput
  }

  export type PokemonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: PokemonWhereInput | PokemonWhereInput[]
    OR?: PokemonWhereInput[]
    NOT?: PokemonWhereInput | PokemonWhereInput[]
    abilities?: PokemonAbilityListRelationFilter
    natures?: PokemonNatureListRelationFilter
    stats?: PokemonStatListRelationFilter
    types?: PokemonTypeListRelationFilter
    egg_groups?: PokemonEggGroupListRelationFilter
    encounters?: EncounterListRelationFilter
    dex_numbers?: PokemonDexNumberListRelationFilter
    move?: PokemonMoveListRelationFilter
  }, "id" | "name">

  export type PokemonOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: PokemonCountOrderByAggregateInput
    _avg?: PokemonAvgOrderByAggregateInput
    _max?: PokemonMaxOrderByAggregateInput
    _min?: PokemonMinOrderByAggregateInput
    _sum?: PokemonSumOrderByAggregateInput
  }

  export type PokemonScalarWhereWithAggregatesInput = {
    AND?: PokemonScalarWhereWithAggregatesInput | PokemonScalarWhereWithAggregatesInput[]
    OR?: PokemonScalarWhereWithAggregatesInput[]
    NOT?: PokemonScalarWhereWithAggregatesInput | PokemonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pokemon"> | number
    name?: StringWithAggregatesFilter<"Pokemon"> | string
  }

  export type AbilityWhereInput = {
    AND?: AbilityWhereInput | AbilityWhereInput[]
    OR?: AbilityWhereInput[]
    NOT?: AbilityWhereInput | AbilityWhereInput[]
    id?: IntFilter<"Ability"> | number
    name?: StringFilter<"Ability"> | string
    description?: StringFilter<"Ability"> | string
    pokemon?: PokemonAbilityListRelationFilter
  }

  export type AbilityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    pokemon?: PokemonAbilityOrderByRelationAggregateInput
  }

  export type AbilityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AbilityWhereInput | AbilityWhereInput[]
    OR?: AbilityWhereInput[]
    NOT?: AbilityWhereInput | AbilityWhereInput[]
    name?: StringFilter<"Ability"> | string
    description?: StringFilter<"Ability"> | string
    pokemon?: PokemonAbilityListRelationFilter
  }, "id">

  export type AbilityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: AbilityCountOrderByAggregateInput
    _avg?: AbilityAvgOrderByAggregateInput
    _max?: AbilityMaxOrderByAggregateInput
    _min?: AbilityMinOrderByAggregateInput
    _sum?: AbilitySumOrderByAggregateInput
  }

  export type AbilityScalarWhereWithAggregatesInput = {
    AND?: AbilityScalarWhereWithAggregatesInput | AbilityScalarWhereWithAggregatesInput[]
    OR?: AbilityScalarWhereWithAggregatesInput[]
    NOT?: AbilityScalarWhereWithAggregatesInput | AbilityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ability"> | number
    name?: StringWithAggregatesFilter<"Ability"> | string
    description?: StringWithAggregatesFilter<"Ability"> | string
  }

  export type PokemonAbilityWhereInput = {
    AND?: PokemonAbilityWhereInput | PokemonAbilityWhereInput[]
    OR?: PokemonAbilityWhereInput[]
    NOT?: PokemonAbilityWhereInput | PokemonAbilityWhereInput[]
    id?: IntFilter<"PokemonAbility"> | number
    pokemon_id?: IntFilter<"PokemonAbility"> | number
    ability_id?: IntFilter<"PokemonAbility"> | number
    is_hidden?: BoolFilter<"PokemonAbility"> | boolean
    pokemon?: XOR<PokemonScalarRelationFilter, PokemonWhereInput>
    ability?: XOR<AbilityScalarRelationFilter, AbilityWhereInput>
  }

  export type PokemonAbilityOrderByWithRelationInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    ability_id?: SortOrder
    is_hidden?: SortOrder
    pokemon?: PokemonOrderByWithRelationInput
    ability?: AbilityOrderByWithRelationInput
  }

  export type PokemonAbilityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PokemonAbilityWhereInput | PokemonAbilityWhereInput[]
    OR?: PokemonAbilityWhereInput[]
    NOT?: PokemonAbilityWhereInput | PokemonAbilityWhereInput[]
    pokemon_id?: IntFilter<"PokemonAbility"> | number
    ability_id?: IntFilter<"PokemonAbility"> | number
    is_hidden?: BoolFilter<"PokemonAbility"> | boolean
    pokemon?: XOR<PokemonScalarRelationFilter, PokemonWhereInput>
    ability?: XOR<AbilityScalarRelationFilter, AbilityWhereInput>
  }, "id">

  export type PokemonAbilityOrderByWithAggregationInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    ability_id?: SortOrder
    is_hidden?: SortOrder
    _count?: PokemonAbilityCountOrderByAggregateInput
    _avg?: PokemonAbilityAvgOrderByAggregateInput
    _max?: PokemonAbilityMaxOrderByAggregateInput
    _min?: PokemonAbilityMinOrderByAggregateInput
    _sum?: PokemonAbilitySumOrderByAggregateInput
  }

  export type PokemonAbilityScalarWhereWithAggregatesInput = {
    AND?: PokemonAbilityScalarWhereWithAggregatesInput | PokemonAbilityScalarWhereWithAggregatesInput[]
    OR?: PokemonAbilityScalarWhereWithAggregatesInput[]
    NOT?: PokemonAbilityScalarWhereWithAggregatesInput | PokemonAbilityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PokemonAbility"> | number
    pokemon_id?: IntWithAggregatesFilter<"PokemonAbility"> | number
    ability_id?: IntWithAggregatesFilter<"PokemonAbility"> | number
    is_hidden?: BoolWithAggregatesFilter<"PokemonAbility"> | boolean
  }

  export type NatureWhereInput = {
    AND?: NatureWhereInput | NatureWhereInput[]
    OR?: NatureWhereInput[]
    NOT?: NatureWhereInput | NatureWhereInput[]
    id?: IntFilter<"Nature"> | number
    name?: StringFilter<"Nature"> | string
    increased_stat_id?: IntFilter<"Nature"> | number
    decreased_stat_id?: IntFilter<"Nature"> | number
    stat_increased?: XOR<StatScalarRelationFilter, StatWhereInput>
    stat_decreased?: XOR<StatScalarRelationFilter, StatWhereInput>
    pokemon?: PokemonNatureListRelationFilter
  }

  export type NatureOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    increased_stat_id?: SortOrder
    decreased_stat_id?: SortOrder
    stat_increased?: StatOrderByWithRelationInput
    stat_decreased?: StatOrderByWithRelationInput
    pokemon?: PokemonNatureOrderByRelationAggregateInput
  }

  export type NatureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NatureWhereInput | NatureWhereInput[]
    OR?: NatureWhereInput[]
    NOT?: NatureWhereInput | NatureWhereInput[]
    name?: StringFilter<"Nature"> | string
    increased_stat_id?: IntFilter<"Nature"> | number
    decreased_stat_id?: IntFilter<"Nature"> | number
    stat_increased?: XOR<StatScalarRelationFilter, StatWhereInput>
    stat_decreased?: XOR<StatScalarRelationFilter, StatWhereInput>
    pokemon?: PokemonNatureListRelationFilter
  }, "id">

  export type NatureOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    increased_stat_id?: SortOrder
    decreased_stat_id?: SortOrder
    _count?: NatureCountOrderByAggregateInput
    _avg?: NatureAvgOrderByAggregateInput
    _max?: NatureMaxOrderByAggregateInput
    _min?: NatureMinOrderByAggregateInput
    _sum?: NatureSumOrderByAggregateInput
  }

  export type NatureScalarWhereWithAggregatesInput = {
    AND?: NatureScalarWhereWithAggregatesInput | NatureScalarWhereWithAggregatesInput[]
    OR?: NatureScalarWhereWithAggregatesInput[]
    NOT?: NatureScalarWhereWithAggregatesInput | NatureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Nature"> | number
    name?: StringWithAggregatesFilter<"Nature"> | string
    increased_stat_id?: IntWithAggregatesFilter<"Nature"> | number
    decreased_stat_id?: IntWithAggregatesFilter<"Nature"> | number
  }

  export type PokemonNatureWhereInput = {
    AND?: PokemonNatureWhereInput | PokemonNatureWhereInput[]
    OR?: PokemonNatureWhereInput[]
    NOT?: PokemonNatureWhereInput | PokemonNatureWhereInput[]
    id?: IntFilter<"PokemonNature"> | number
    pokemon_id?: IntFilter<"PokemonNature"> | number
    nature_id?: IntFilter<"PokemonNature"> | number
    pokemon?: XOR<PokemonScalarRelationFilter, PokemonWhereInput>
    nature?: XOR<NatureScalarRelationFilter, NatureWhereInput>
  }

  export type PokemonNatureOrderByWithRelationInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    nature_id?: SortOrder
    pokemon?: PokemonOrderByWithRelationInput
    nature?: NatureOrderByWithRelationInput
  }

  export type PokemonNatureWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PokemonNatureWhereInput | PokemonNatureWhereInput[]
    OR?: PokemonNatureWhereInput[]
    NOT?: PokemonNatureWhereInput | PokemonNatureWhereInput[]
    pokemon_id?: IntFilter<"PokemonNature"> | number
    nature_id?: IntFilter<"PokemonNature"> | number
    pokemon?: XOR<PokemonScalarRelationFilter, PokemonWhereInput>
    nature?: XOR<NatureScalarRelationFilter, NatureWhereInput>
  }, "id">

  export type PokemonNatureOrderByWithAggregationInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    nature_id?: SortOrder
    _count?: PokemonNatureCountOrderByAggregateInput
    _avg?: PokemonNatureAvgOrderByAggregateInput
    _max?: PokemonNatureMaxOrderByAggregateInput
    _min?: PokemonNatureMinOrderByAggregateInput
    _sum?: PokemonNatureSumOrderByAggregateInput
  }

  export type PokemonNatureScalarWhereWithAggregatesInput = {
    AND?: PokemonNatureScalarWhereWithAggregatesInput | PokemonNatureScalarWhereWithAggregatesInput[]
    OR?: PokemonNatureScalarWhereWithAggregatesInput[]
    NOT?: PokemonNatureScalarWhereWithAggregatesInput | PokemonNatureScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PokemonNature"> | number
    pokemon_id?: IntWithAggregatesFilter<"PokemonNature"> | number
    nature_id?: IntWithAggregatesFilter<"PokemonNature"> | number
  }

  export type StatWhereInput = {
    AND?: StatWhereInput | StatWhereInput[]
    OR?: StatWhereInput[]
    NOT?: StatWhereInput | StatWhereInput[]
    id?: IntFilter<"Stat"> | number
    name?: StringFilter<"Stat"> | string
    natures_increase?: NatureListRelationFilter
    natures_decrease?: NatureListRelationFilter
    pokemon_stats?: PokemonStatListRelationFilter
  }

  export type StatOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    natures_increase?: NatureOrderByRelationAggregateInput
    natures_decrease?: NatureOrderByRelationAggregateInput
    pokemon_stats?: PokemonStatOrderByRelationAggregateInput
  }

  export type StatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StatWhereInput | StatWhereInput[]
    OR?: StatWhereInput[]
    NOT?: StatWhereInput | StatWhereInput[]
    name?: StringFilter<"Stat"> | string
    natures_increase?: NatureListRelationFilter
    natures_decrease?: NatureListRelationFilter
    pokemon_stats?: PokemonStatListRelationFilter
  }, "id">

  export type StatOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: StatCountOrderByAggregateInput
    _avg?: StatAvgOrderByAggregateInput
    _max?: StatMaxOrderByAggregateInput
    _min?: StatMinOrderByAggregateInput
    _sum?: StatSumOrderByAggregateInput
  }

  export type StatScalarWhereWithAggregatesInput = {
    AND?: StatScalarWhereWithAggregatesInput | StatScalarWhereWithAggregatesInput[]
    OR?: StatScalarWhereWithAggregatesInput[]
    NOT?: StatScalarWhereWithAggregatesInput | StatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Stat"> | number
    name?: StringWithAggregatesFilter<"Stat"> | string
  }

  export type PokemonStatWhereInput = {
    AND?: PokemonStatWhereInput | PokemonStatWhereInput[]
    OR?: PokemonStatWhereInput[]
    NOT?: PokemonStatWhereInput | PokemonStatWhereInput[]
    id?: IntFilter<"PokemonStat"> | number
    pokemon_id?: IntFilter<"PokemonStat"> | number
    stat_id?: IntFilter<"PokemonStat"> | number
    base_stat?: IntFilter<"PokemonStat"> | number
    pokemon?: XOR<PokemonScalarRelationFilter, PokemonWhereInput>
    stat?: XOR<StatScalarRelationFilter, StatWhereInput>
  }

  export type PokemonStatOrderByWithRelationInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    stat_id?: SortOrder
    base_stat?: SortOrder
    pokemon?: PokemonOrderByWithRelationInput
    stat?: StatOrderByWithRelationInput
  }

  export type PokemonStatWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PokemonStatWhereInput | PokemonStatWhereInput[]
    OR?: PokemonStatWhereInput[]
    NOT?: PokemonStatWhereInput | PokemonStatWhereInput[]
    pokemon_id?: IntFilter<"PokemonStat"> | number
    stat_id?: IntFilter<"PokemonStat"> | number
    base_stat?: IntFilter<"PokemonStat"> | number
    pokemon?: XOR<PokemonScalarRelationFilter, PokemonWhereInput>
    stat?: XOR<StatScalarRelationFilter, StatWhereInput>
  }, "id">

  export type PokemonStatOrderByWithAggregationInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    stat_id?: SortOrder
    base_stat?: SortOrder
    _count?: PokemonStatCountOrderByAggregateInput
    _avg?: PokemonStatAvgOrderByAggregateInput
    _max?: PokemonStatMaxOrderByAggregateInput
    _min?: PokemonStatMinOrderByAggregateInput
    _sum?: PokemonStatSumOrderByAggregateInput
  }

  export type PokemonStatScalarWhereWithAggregatesInput = {
    AND?: PokemonStatScalarWhereWithAggregatesInput | PokemonStatScalarWhereWithAggregatesInput[]
    OR?: PokemonStatScalarWhereWithAggregatesInput[]
    NOT?: PokemonStatScalarWhereWithAggregatesInput | PokemonStatScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PokemonStat"> | number
    pokemon_id?: IntWithAggregatesFilter<"PokemonStat"> | number
    stat_id?: IntWithAggregatesFilter<"PokemonStat"> | number
    base_stat?: IntWithAggregatesFilter<"PokemonStat"> | number
  }

  export type TypeWhereInput = {
    AND?: TypeWhereInput | TypeWhereInput[]
    OR?: TypeWhereInput[]
    NOT?: TypeWhereInput | TypeWhereInput[]
    id?: IntFilter<"Type"> | number
    name?: StringFilter<"Type"> | string
    generation_id?: IntFilter<"Type"> | number
    generation?: XOR<GenerationScalarRelationFilter, GenerationWhereInput>
    pokemon?: PokemonTypeListRelationFilter
    attacking?: TypeEffectivenessListRelationFilter
    defending?: TypeEffectivenessListRelationFilter
    move?: MoveListRelationFilter
  }

  export type TypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    generation_id?: SortOrder
    generation?: GenerationOrderByWithRelationInput
    pokemon?: PokemonTypeOrderByRelationAggregateInput
    attacking?: TypeEffectivenessOrderByRelationAggregateInput
    defending?: TypeEffectivenessOrderByRelationAggregateInput
    move?: MoveOrderByRelationAggregateInput
  }

  export type TypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TypeWhereInput | TypeWhereInput[]
    OR?: TypeWhereInput[]
    NOT?: TypeWhereInput | TypeWhereInput[]
    name?: StringFilter<"Type"> | string
    generation_id?: IntFilter<"Type"> | number
    generation?: XOR<GenerationScalarRelationFilter, GenerationWhereInput>
    pokemon?: PokemonTypeListRelationFilter
    attacking?: TypeEffectivenessListRelationFilter
    defending?: TypeEffectivenessListRelationFilter
    move?: MoveListRelationFilter
  }, "id">

  export type TypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    generation_id?: SortOrder
    _count?: TypeCountOrderByAggregateInput
    _avg?: TypeAvgOrderByAggregateInput
    _max?: TypeMaxOrderByAggregateInput
    _min?: TypeMinOrderByAggregateInput
    _sum?: TypeSumOrderByAggregateInput
  }

  export type TypeScalarWhereWithAggregatesInput = {
    AND?: TypeScalarWhereWithAggregatesInput | TypeScalarWhereWithAggregatesInput[]
    OR?: TypeScalarWhereWithAggregatesInput[]
    NOT?: TypeScalarWhereWithAggregatesInput | TypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Type"> | number
    name?: StringWithAggregatesFilter<"Type"> | string
    generation_id?: IntWithAggregatesFilter<"Type"> | number
  }

  export type TypeEffectivenessWhereInput = {
    AND?: TypeEffectivenessWhereInput | TypeEffectivenessWhereInput[]
    OR?: TypeEffectivenessWhereInput[]
    NOT?: TypeEffectivenessWhereInput | TypeEffectivenessWhereInput[]
    id?: IntFilter<"TypeEffectiveness"> | number
    type_id?: IntFilter<"TypeEffectiveness"> | number
    target_type_id?: IntFilter<"TypeEffectiveness"> | number
    damage_factor?: IntFilter<"TypeEffectiveness"> | number
    attacker?: XOR<TypeScalarRelationFilter, TypeWhereInput>
    defender?: XOR<TypeScalarRelationFilter, TypeWhereInput>
  }

  export type TypeEffectivenessOrderByWithRelationInput = {
    id?: SortOrder
    type_id?: SortOrder
    target_type_id?: SortOrder
    damage_factor?: SortOrder
    attacker?: TypeOrderByWithRelationInput
    defender?: TypeOrderByWithRelationInput
  }

  export type TypeEffectivenessWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TypeEffectivenessWhereInput | TypeEffectivenessWhereInput[]
    OR?: TypeEffectivenessWhereInput[]
    NOT?: TypeEffectivenessWhereInput | TypeEffectivenessWhereInput[]
    type_id?: IntFilter<"TypeEffectiveness"> | number
    target_type_id?: IntFilter<"TypeEffectiveness"> | number
    damage_factor?: IntFilter<"TypeEffectiveness"> | number
    attacker?: XOR<TypeScalarRelationFilter, TypeWhereInput>
    defender?: XOR<TypeScalarRelationFilter, TypeWhereInput>
  }, "id">

  export type TypeEffectivenessOrderByWithAggregationInput = {
    id?: SortOrder
    type_id?: SortOrder
    target_type_id?: SortOrder
    damage_factor?: SortOrder
    _count?: TypeEffectivenessCountOrderByAggregateInput
    _avg?: TypeEffectivenessAvgOrderByAggregateInput
    _max?: TypeEffectivenessMaxOrderByAggregateInput
    _min?: TypeEffectivenessMinOrderByAggregateInput
    _sum?: TypeEffectivenessSumOrderByAggregateInput
  }

  export type TypeEffectivenessScalarWhereWithAggregatesInput = {
    AND?: TypeEffectivenessScalarWhereWithAggregatesInput | TypeEffectivenessScalarWhereWithAggregatesInput[]
    OR?: TypeEffectivenessScalarWhereWithAggregatesInput[]
    NOT?: TypeEffectivenessScalarWhereWithAggregatesInput | TypeEffectivenessScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TypeEffectiveness"> | number
    type_id?: IntWithAggregatesFilter<"TypeEffectiveness"> | number
    target_type_id?: IntWithAggregatesFilter<"TypeEffectiveness"> | number
    damage_factor?: IntWithAggregatesFilter<"TypeEffectiveness"> | number
  }

  export type PokemonTypeWhereInput = {
    AND?: PokemonTypeWhereInput | PokemonTypeWhereInput[]
    OR?: PokemonTypeWhereInput[]
    NOT?: PokemonTypeWhereInput | PokemonTypeWhereInput[]
    id?: IntFilter<"PokemonType"> | number
    pokemon_id?: IntFilter<"PokemonType"> | number
    type_id?: IntFilter<"PokemonType"> | number
    pokemon?: XOR<PokemonScalarRelationFilter, PokemonWhereInput>
    type?: XOR<TypeScalarRelationFilter, TypeWhereInput>
  }

  export type PokemonTypeOrderByWithRelationInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    type_id?: SortOrder
    pokemon?: PokemonOrderByWithRelationInput
    type?: TypeOrderByWithRelationInput
  }

  export type PokemonTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PokemonTypeWhereInput | PokemonTypeWhereInput[]
    OR?: PokemonTypeWhereInput[]
    NOT?: PokemonTypeWhereInput | PokemonTypeWhereInput[]
    pokemon_id?: IntFilter<"PokemonType"> | number
    type_id?: IntFilter<"PokemonType"> | number
    pokemon?: XOR<PokemonScalarRelationFilter, PokemonWhereInput>
    type?: XOR<TypeScalarRelationFilter, TypeWhereInput>
  }, "id">

  export type PokemonTypeOrderByWithAggregationInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    type_id?: SortOrder
    _count?: PokemonTypeCountOrderByAggregateInput
    _avg?: PokemonTypeAvgOrderByAggregateInput
    _max?: PokemonTypeMaxOrderByAggregateInput
    _min?: PokemonTypeMinOrderByAggregateInput
    _sum?: PokemonTypeSumOrderByAggregateInput
  }

  export type PokemonTypeScalarWhereWithAggregatesInput = {
    AND?: PokemonTypeScalarWhereWithAggregatesInput | PokemonTypeScalarWhereWithAggregatesInput[]
    OR?: PokemonTypeScalarWhereWithAggregatesInput[]
    NOT?: PokemonTypeScalarWhereWithAggregatesInput | PokemonTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PokemonType"> | number
    pokemon_id?: IntWithAggregatesFilter<"PokemonType"> | number
    type_id?: IntWithAggregatesFilter<"PokemonType"> | number
  }

  export type EggGroupWhereInput = {
    AND?: EggGroupWhereInput | EggGroupWhereInput[]
    OR?: EggGroupWhereInput[]
    NOT?: EggGroupWhereInput | EggGroupWhereInput[]
    id?: IntFilter<"EggGroup"> | number
    name?: StringFilter<"EggGroup"> | string
    pokemon_egg_group?: PokemonEggGroupListRelationFilter
  }

  export type EggGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    pokemon_egg_group?: PokemonEggGroupOrderByRelationAggregateInput
  }

  export type EggGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EggGroupWhereInput | EggGroupWhereInput[]
    OR?: EggGroupWhereInput[]
    NOT?: EggGroupWhereInput | EggGroupWhereInput[]
    name?: StringFilter<"EggGroup"> | string
    pokemon_egg_group?: PokemonEggGroupListRelationFilter
  }, "id">

  export type EggGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: EggGroupCountOrderByAggregateInput
    _avg?: EggGroupAvgOrderByAggregateInput
    _max?: EggGroupMaxOrderByAggregateInput
    _min?: EggGroupMinOrderByAggregateInput
    _sum?: EggGroupSumOrderByAggregateInput
  }

  export type EggGroupScalarWhereWithAggregatesInput = {
    AND?: EggGroupScalarWhereWithAggregatesInput | EggGroupScalarWhereWithAggregatesInput[]
    OR?: EggGroupScalarWhereWithAggregatesInput[]
    NOT?: EggGroupScalarWhereWithAggregatesInput | EggGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EggGroup"> | number
    name?: StringWithAggregatesFilter<"EggGroup"> | string
  }

  export type PokemonEggGroupWhereInput = {
    AND?: PokemonEggGroupWhereInput | PokemonEggGroupWhereInput[]
    OR?: PokemonEggGroupWhereInput[]
    NOT?: PokemonEggGroupWhereInput | PokemonEggGroupWhereInput[]
    id?: IntFilter<"PokemonEggGroup"> | number
    pokemon_id?: IntFilter<"PokemonEggGroup"> | number
    egg_group_id?: IntFilter<"PokemonEggGroup"> | number
    pokemon?: XOR<PokemonScalarRelationFilter, PokemonWhereInput>
    egg_group?: XOR<EggGroupScalarRelationFilter, EggGroupWhereInput>
  }

  export type PokemonEggGroupOrderByWithRelationInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    egg_group_id?: SortOrder
    pokemon?: PokemonOrderByWithRelationInput
    egg_group?: EggGroupOrderByWithRelationInput
  }

  export type PokemonEggGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PokemonEggGroupWhereInput | PokemonEggGroupWhereInput[]
    OR?: PokemonEggGroupWhereInput[]
    NOT?: PokemonEggGroupWhereInput | PokemonEggGroupWhereInput[]
    pokemon_id?: IntFilter<"PokemonEggGroup"> | number
    egg_group_id?: IntFilter<"PokemonEggGroup"> | number
    pokemon?: XOR<PokemonScalarRelationFilter, PokemonWhereInput>
    egg_group?: XOR<EggGroupScalarRelationFilter, EggGroupWhereInput>
  }, "id">

  export type PokemonEggGroupOrderByWithAggregationInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    egg_group_id?: SortOrder
    _count?: PokemonEggGroupCountOrderByAggregateInput
    _avg?: PokemonEggGroupAvgOrderByAggregateInput
    _max?: PokemonEggGroupMaxOrderByAggregateInput
    _min?: PokemonEggGroupMinOrderByAggregateInput
    _sum?: PokemonEggGroupSumOrderByAggregateInput
  }

  export type PokemonEggGroupScalarWhereWithAggregatesInput = {
    AND?: PokemonEggGroupScalarWhereWithAggregatesInput | PokemonEggGroupScalarWhereWithAggregatesInput[]
    OR?: PokemonEggGroupScalarWhereWithAggregatesInput[]
    NOT?: PokemonEggGroupScalarWhereWithAggregatesInput | PokemonEggGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PokemonEggGroup"> | number
    pokemon_id?: IntWithAggregatesFilter<"PokemonEggGroup"> | number
    egg_group_id?: IntWithAggregatesFilter<"PokemonEggGroup"> | number
  }

  export type RegionWhereInput = {
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    id?: IntFilter<"Region"> | number
    name?: StringFilter<"Region"> | string
    locations?: LocationListRelationFilter
    version_groups?: VersionGroupRegionListRelationFilter
    generations?: XOR<GenerationNullableScalarRelationFilter, GenerationWhereInput> | null
    pokedex?: PokedexListRelationFilter
  }

  export type RegionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    locations?: LocationOrderByRelationAggregateInput
    version_groups?: VersionGroupRegionOrderByRelationAggregateInput
    generations?: GenerationOrderByWithRelationInput
    pokedex?: PokedexOrderByRelationAggregateInput
  }

  export type RegionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    name?: StringFilter<"Region"> | string
    locations?: LocationListRelationFilter
    version_groups?: VersionGroupRegionListRelationFilter
    generations?: XOR<GenerationNullableScalarRelationFilter, GenerationWhereInput> | null
    pokedex?: PokedexListRelationFilter
  }, "id">

  export type RegionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RegionCountOrderByAggregateInput
    _avg?: RegionAvgOrderByAggregateInput
    _max?: RegionMaxOrderByAggregateInput
    _min?: RegionMinOrderByAggregateInput
    _sum?: RegionSumOrderByAggregateInput
  }

  export type RegionScalarWhereWithAggregatesInput = {
    AND?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    OR?: RegionScalarWhereWithAggregatesInput[]
    NOT?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Region"> | number
    name?: StringWithAggregatesFilter<"Region"> | string
  }

  export type GenerationWhereInput = {
    AND?: GenerationWhereInput | GenerationWhereInput[]
    OR?: GenerationWhereInput[]
    NOT?: GenerationWhereInput | GenerationWhereInput[]
    id?: IntFilter<"Generation"> | number
    name?: StringFilter<"Generation"> | string
    region_id?: IntFilter<"Generation"> | number
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    types?: TypeListRelationFilter
    versionGroups?: VersionGroupListRelationFilter
  }

  export type GenerationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
    region?: RegionOrderByWithRelationInput
    types?: TypeOrderByRelationAggregateInput
    versionGroups?: VersionGroupOrderByRelationAggregateInput
  }

  export type GenerationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    region_id?: number
    AND?: GenerationWhereInput | GenerationWhereInput[]
    OR?: GenerationWhereInput[]
    NOT?: GenerationWhereInput | GenerationWhereInput[]
    name?: StringFilter<"Generation"> | string
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    types?: TypeListRelationFilter
    versionGroups?: VersionGroupListRelationFilter
  }, "id" | "region_id">

  export type GenerationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
    _count?: GenerationCountOrderByAggregateInput
    _avg?: GenerationAvgOrderByAggregateInput
    _max?: GenerationMaxOrderByAggregateInput
    _min?: GenerationMinOrderByAggregateInput
    _sum?: GenerationSumOrderByAggregateInput
  }

  export type GenerationScalarWhereWithAggregatesInput = {
    AND?: GenerationScalarWhereWithAggregatesInput | GenerationScalarWhereWithAggregatesInput[]
    OR?: GenerationScalarWhereWithAggregatesInput[]
    NOT?: GenerationScalarWhereWithAggregatesInput | GenerationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Generation"> | number
    name?: StringWithAggregatesFilter<"Generation"> | string
    region_id?: IntWithAggregatesFilter<"Generation"> | number
  }

  export type VersionGroupWhereInput = {
    AND?: VersionGroupWhereInput | VersionGroupWhereInput[]
    OR?: VersionGroupWhereInput[]
    NOT?: VersionGroupWhereInput | VersionGroupWhereInput[]
    id?: IntFilter<"VersionGroup"> | number
    name?: StringFilter<"VersionGroup"> | string
    generation_id?: IntFilter<"VersionGroup"> | number
    generation?: XOR<GenerationScalarRelationFilter, GenerationWhereInput>
    versions?: VersionListRelationFilter
    regions?: VersionGroupRegionListRelationFilter
    slots?: EncounterSlotListRelationFilter
    moves?: PokemonMoveListRelationFilter
    pokedex_version_groups?: PokedexVersionGroupListRelationFilter
  }

  export type VersionGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    generation_id?: SortOrder
    generation?: GenerationOrderByWithRelationInput
    versions?: VersionOrderByRelationAggregateInput
    regions?: VersionGroupRegionOrderByRelationAggregateInput
    slots?: EncounterSlotOrderByRelationAggregateInput
    moves?: PokemonMoveOrderByRelationAggregateInput
    pokedex_version_groups?: PokedexVersionGroupOrderByRelationAggregateInput
  }

  export type VersionGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VersionGroupWhereInput | VersionGroupWhereInput[]
    OR?: VersionGroupWhereInput[]
    NOT?: VersionGroupWhereInput | VersionGroupWhereInput[]
    name?: StringFilter<"VersionGroup"> | string
    generation_id?: IntFilter<"VersionGroup"> | number
    generation?: XOR<GenerationScalarRelationFilter, GenerationWhereInput>
    versions?: VersionListRelationFilter
    regions?: VersionGroupRegionListRelationFilter
    slots?: EncounterSlotListRelationFilter
    moves?: PokemonMoveListRelationFilter
    pokedex_version_groups?: PokedexVersionGroupListRelationFilter
  }, "id">

  export type VersionGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    generation_id?: SortOrder
    _count?: VersionGroupCountOrderByAggregateInput
    _avg?: VersionGroupAvgOrderByAggregateInput
    _max?: VersionGroupMaxOrderByAggregateInput
    _min?: VersionGroupMinOrderByAggregateInput
    _sum?: VersionGroupSumOrderByAggregateInput
  }

  export type VersionGroupScalarWhereWithAggregatesInput = {
    AND?: VersionGroupScalarWhereWithAggregatesInput | VersionGroupScalarWhereWithAggregatesInput[]
    OR?: VersionGroupScalarWhereWithAggregatesInput[]
    NOT?: VersionGroupScalarWhereWithAggregatesInput | VersionGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VersionGroup"> | number
    name?: StringWithAggregatesFilter<"VersionGroup"> | string
    generation_id?: IntWithAggregatesFilter<"VersionGroup"> | number
  }

  export type VersionGroupRegionWhereInput = {
    AND?: VersionGroupRegionWhereInput | VersionGroupRegionWhereInput[]
    OR?: VersionGroupRegionWhereInput[]
    NOT?: VersionGroupRegionWhereInput | VersionGroupRegionWhereInput[]
    id?: IntFilter<"VersionGroupRegion"> | number
    version_group_id?: IntFilter<"VersionGroupRegion"> | number
    region_id?: IntFilter<"VersionGroupRegion"> | number
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    version_group?: XOR<VersionGroupScalarRelationFilter, VersionGroupWhereInput>
  }

  export type VersionGroupRegionOrderByWithRelationInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    region_id?: SortOrder
    region?: RegionOrderByWithRelationInput
    version_group?: VersionGroupOrderByWithRelationInput
  }

  export type VersionGroupRegionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VersionGroupRegionWhereInput | VersionGroupRegionWhereInput[]
    OR?: VersionGroupRegionWhereInput[]
    NOT?: VersionGroupRegionWhereInput | VersionGroupRegionWhereInput[]
    version_group_id?: IntFilter<"VersionGroupRegion"> | number
    region_id?: IntFilter<"VersionGroupRegion"> | number
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    version_group?: XOR<VersionGroupScalarRelationFilter, VersionGroupWhereInput>
  }, "id">

  export type VersionGroupRegionOrderByWithAggregationInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    region_id?: SortOrder
    _count?: VersionGroupRegionCountOrderByAggregateInput
    _avg?: VersionGroupRegionAvgOrderByAggregateInput
    _max?: VersionGroupRegionMaxOrderByAggregateInput
    _min?: VersionGroupRegionMinOrderByAggregateInput
    _sum?: VersionGroupRegionSumOrderByAggregateInput
  }

  export type VersionGroupRegionScalarWhereWithAggregatesInput = {
    AND?: VersionGroupRegionScalarWhereWithAggregatesInput | VersionGroupRegionScalarWhereWithAggregatesInput[]
    OR?: VersionGroupRegionScalarWhereWithAggregatesInput[]
    NOT?: VersionGroupRegionScalarWhereWithAggregatesInput | VersionGroupRegionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VersionGroupRegion"> | number
    version_group_id?: IntWithAggregatesFilter<"VersionGroupRegion"> | number
    region_id?: IntWithAggregatesFilter<"VersionGroupRegion"> | number
  }

  export type VersionWhereInput = {
    AND?: VersionWhereInput | VersionWhereInput[]
    OR?: VersionWhereInput[]
    NOT?: VersionWhereInput | VersionWhereInput[]
    id?: IntFilter<"Version"> | number
    name?: StringFilter<"Version"> | string
    version_group_id?: IntFilter<"Version"> | number
    versionGroup?: XOR<VersionGroupScalarRelationFilter, VersionGroupWhereInput>
    encounters?: EncounterListRelationFilter
    encounterRates?: LocationAreaEncounterRateListRelationFilter
  }

  export type VersionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    version_group_id?: SortOrder
    versionGroup?: VersionGroupOrderByWithRelationInput
    encounters?: EncounterOrderByRelationAggregateInput
    encounterRates?: LocationAreaEncounterRateOrderByRelationAggregateInput
  }

  export type VersionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VersionWhereInput | VersionWhereInput[]
    OR?: VersionWhereInput[]
    NOT?: VersionWhereInput | VersionWhereInput[]
    name?: StringFilter<"Version"> | string
    version_group_id?: IntFilter<"Version"> | number
    versionGroup?: XOR<VersionGroupScalarRelationFilter, VersionGroupWhereInput>
    encounters?: EncounterListRelationFilter
    encounterRates?: LocationAreaEncounterRateListRelationFilter
  }, "id">

  export type VersionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    version_group_id?: SortOrder
    _count?: VersionCountOrderByAggregateInput
    _avg?: VersionAvgOrderByAggregateInput
    _max?: VersionMaxOrderByAggregateInput
    _min?: VersionMinOrderByAggregateInput
    _sum?: VersionSumOrderByAggregateInput
  }

  export type VersionScalarWhereWithAggregatesInput = {
    AND?: VersionScalarWhereWithAggregatesInput | VersionScalarWhereWithAggregatesInput[]
    OR?: VersionScalarWhereWithAggregatesInput[]
    NOT?: VersionScalarWhereWithAggregatesInput | VersionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Version"> | number
    name?: StringWithAggregatesFilter<"Version"> | string
    version_group_id?: IntWithAggregatesFilter<"Version"> | number
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: IntFilter<"Location"> | number
    name?: StringFilter<"Location"> | string
    region_id?: IntFilter<"Location"> | number
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    areas?: LocationAreaListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
    region?: RegionOrderByWithRelationInput
    areas?: LocationAreaOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    name?: StringFilter<"Location"> | string
    region_id?: IntFilter<"Location"> | number
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    areas?: LocationAreaListRelationFilter
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Location"> | number
    name?: StringWithAggregatesFilter<"Location"> | string
    region_id?: IntWithAggregatesFilter<"Location"> | number
  }

  export type LocationAreaWhereInput = {
    AND?: LocationAreaWhereInput | LocationAreaWhereInput[]
    OR?: LocationAreaWhereInput[]
    NOT?: LocationAreaWhereInput | LocationAreaWhereInput[]
    id?: IntFilter<"LocationArea"> | number
    name?: StringFilter<"LocationArea"> | string
    location_id?: IntFilter<"LocationArea"> | number
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    encounters?: EncounterListRelationFilter
    encounterRates?: LocationAreaEncounterRateListRelationFilter
  }

  export type LocationAreaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location_id?: SortOrder
    location?: LocationOrderByWithRelationInput
    encounters?: EncounterOrderByRelationAggregateInput
    encounterRates?: LocationAreaEncounterRateOrderByRelationAggregateInput
  }

  export type LocationAreaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LocationAreaWhereInput | LocationAreaWhereInput[]
    OR?: LocationAreaWhereInput[]
    NOT?: LocationAreaWhereInput | LocationAreaWhereInput[]
    name?: StringFilter<"LocationArea"> | string
    location_id?: IntFilter<"LocationArea"> | number
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    encounters?: EncounterListRelationFilter
    encounterRates?: LocationAreaEncounterRateListRelationFilter
  }, "id">

  export type LocationAreaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location_id?: SortOrder
    _count?: LocationAreaCountOrderByAggregateInput
    _avg?: LocationAreaAvgOrderByAggregateInput
    _max?: LocationAreaMaxOrderByAggregateInput
    _min?: LocationAreaMinOrderByAggregateInput
    _sum?: LocationAreaSumOrderByAggregateInput
  }

  export type LocationAreaScalarWhereWithAggregatesInput = {
    AND?: LocationAreaScalarWhereWithAggregatesInput | LocationAreaScalarWhereWithAggregatesInput[]
    OR?: LocationAreaScalarWhereWithAggregatesInput[]
    NOT?: LocationAreaScalarWhereWithAggregatesInput | LocationAreaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LocationArea"> | number
    name?: StringWithAggregatesFilter<"LocationArea"> | string
    location_id?: IntWithAggregatesFilter<"LocationArea"> | number
  }

  export type EncounterMethodWhereInput = {
    AND?: EncounterMethodWhereInput | EncounterMethodWhereInput[]
    OR?: EncounterMethodWhereInput[]
    NOT?: EncounterMethodWhereInput | EncounterMethodWhereInput[]
    id?: IntFilter<"EncounterMethod"> | number
    name?: StringFilter<"EncounterMethod"> | string
    slots?: EncounterSlotListRelationFilter
    location_area_encounter_rates?: LocationAreaEncounterRateListRelationFilter
  }

  export type EncounterMethodOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slots?: EncounterSlotOrderByRelationAggregateInput
    location_area_encounter_rates?: LocationAreaEncounterRateOrderByRelationAggregateInput
  }

  export type EncounterMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EncounterMethodWhereInput | EncounterMethodWhereInput[]
    OR?: EncounterMethodWhereInput[]
    NOT?: EncounterMethodWhereInput | EncounterMethodWhereInput[]
    name?: StringFilter<"EncounterMethod"> | string
    slots?: EncounterSlotListRelationFilter
    location_area_encounter_rates?: LocationAreaEncounterRateListRelationFilter
  }, "id">

  export type EncounterMethodOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: EncounterMethodCountOrderByAggregateInput
    _avg?: EncounterMethodAvgOrderByAggregateInput
    _max?: EncounterMethodMaxOrderByAggregateInput
    _min?: EncounterMethodMinOrderByAggregateInput
    _sum?: EncounterMethodSumOrderByAggregateInput
  }

  export type EncounterMethodScalarWhereWithAggregatesInput = {
    AND?: EncounterMethodScalarWhereWithAggregatesInput | EncounterMethodScalarWhereWithAggregatesInput[]
    OR?: EncounterMethodScalarWhereWithAggregatesInput[]
    NOT?: EncounterMethodScalarWhereWithAggregatesInput | EncounterMethodScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EncounterMethod"> | number
    name?: StringWithAggregatesFilter<"EncounterMethod"> | string
  }

  export type EncounterSlotWhereInput = {
    AND?: EncounterSlotWhereInput | EncounterSlotWhereInput[]
    OR?: EncounterSlotWhereInput[]
    NOT?: EncounterSlotWhereInput | EncounterSlotWhereInput[]
    id?: IntFilter<"EncounterSlot"> | number
    version_group_id?: IntFilter<"EncounterSlot"> | number
    encounter_method_id?: IntFilter<"EncounterSlot"> | number
    slot?: IntFilter<"EncounterSlot"> | number
    rarity?: IntFilter<"EncounterSlot"> | number
    version_group?: XOR<VersionGroupScalarRelationFilter, VersionGroupWhereInput>
    method?: XOR<EncounterMethodScalarRelationFilter, EncounterMethodWhereInput>
    encounters?: EncounterListRelationFilter
  }

  export type EncounterSlotOrderByWithRelationInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    encounter_method_id?: SortOrder
    slot?: SortOrder
    rarity?: SortOrder
    version_group?: VersionGroupOrderByWithRelationInput
    method?: EncounterMethodOrderByWithRelationInput
    encounters?: EncounterOrderByRelationAggregateInput
  }

  export type EncounterSlotWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EncounterSlotWhereInput | EncounterSlotWhereInput[]
    OR?: EncounterSlotWhereInput[]
    NOT?: EncounterSlotWhereInput | EncounterSlotWhereInput[]
    version_group_id?: IntFilter<"EncounterSlot"> | number
    encounter_method_id?: IntFilter<"EncounterSlot"> | number
    slot?: IntFilter<"EncounterSlot"> | number
    rarity?: IntFilter<"EncounterSlot"> | number
    version_group?: XOR<VersionGroupScalarRelationFilter, VersionGroupWhereInput>
    method?: XOR<EncounterMethodScalarRelationFilter, EncounterMethodWhereInput>
    encounters?: EncounterListRelationFilter
  }, "id">

  export type EncounterSlotOrderByWithAggregationInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    encounter_method_id?: SortOrder
    slot?: SortOrder
    rarity?: SortOrder
    _count?: EncounterSlotCountOrderByAggregateInput
    _avg?: EncounterSlotAvgOrderByAggregateInput
    _max?: EncounterSlotMaxOrderByAggregateInput
    _min?: EncounterSlotMinOrderByAggregateInput
    _sum?: EncounterSlotSumOrderByAggregateInput
  }

  export type EncounterSlotScalarWhereWithAggregatesInput = {
    AND?: EncounterSlotScalarWhereWithAggregatesInput | EncounterSlotScalarWhereWithAggregatesInput[]
    OR?: EncounterSlotScalarWhereWithAggregatesInput[]
    NOT?: EncounterSlotScalarWhereWithAggregatesInput | EncounterSlotScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EncounterSlot"> | number
    version_group_id?: IntWithAggregatesFilter<"EncounterSlot"> | number
    encounter_method_id?: IntWithAggregatesFilter<"EncounterSlot"> | number
    slot?: IntWithAggregatesFilter<"EncounterSlot"> | number
    rarity?: IntWithAggregatesFilter<"EncounterSlot"> | number
  }

  export type EncounterWhereInput = {
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    id?: IntFilter<"Encounter"> | number
    version_id?: IntFilter<"Encounter"> | number
    pokemon_id?: IntFilter<"Encounter"> | number
    location_area_id?: IntFilter<"Encounter"> | number
    encounter_slot_id?: IntFilter<"Encounter"> | number
    min_level?: IntFilter<"Encounter"> | number
    max_level?: IntFilter<"Encounter"> | number
    version?: XOR<VersionScalarRelationFilter, VersionWhereInput>
    pokemon?: XOR<PokemonScalarRelationFilter, PokemonWhereInput>
    location_area?: XOR<LocationAreaScalarRelationFilter, LocationAreaWhereInput>
    slot?: XOR<EncounterSlotScalarRelationFilter, EncounterSlotWhereInput>
    conditions?: EncounterConditionValueMapListRelationFilter
  }

  export type EncounterOrderByWithRelationInput = {
    id?: SortOrder
    version_id?: SortOrder
    pokemon_id?: SortOrder
    location_area_id?: SortOrder
    encounter_slot_id?: SortOrder
    min_level?: SortOrder
    max_level?: SortOrder
    version?: VersionOrderByWithRelationInput
    pokemon?: PokemonOrderByWithRelationInput
    location_area?: LocationAreaOrderByWithRelationInput
    slot?: EncounterSlotOrderByWithRelationInput
    conditions?: EncounterConditionValueMapOrderByRelationAggregateInput
  }

  export type EncounterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EncounterWhereInput | EncounterWhereInput[]
    OR?: EncounterWhereInput[]
    NOT?: EncounterWhereInput | EncounterWhereInput[]
    version_id?: IntFilter<"Encounter"> | number
    pokemon_id?: IntFilter<"Encounter"> | number
    location_area_id?: IntFilter<"Encounter"> | number
    encounter_slot_id?: IntFilter<"Encounter"> | number
    min_level?: IntFilter<"Encounter"> | number
    max_level?: IntFilter<"Encounter"> | number
    version?: XOR<VersionScalarRelationFilter, VersionWhereInput>
    pokemon?: XOR<PokemonScalarRelationFilter, PokemonWhereInput>
    location_area?: XOR<LocationAreaScalarRelationFilter, LocationAreaWhereInput>
    slot?: XOR<EncounterSlotScalarRelationFilter, EncounterSlotWhereInput>
    conditions?: EncounterConditionValueMapListRelationFilter
  }, "id">

  export type EncounterOrderByWithAggregationInput = {
    id?: SortOrder
    version_id?: SortOrder
    pokemon_id?: SortOrder
    location_area_id?: SortOrder
    encounter_slot_id?: SortOrder
    min_level?: SortOrder
    max_level?: SortOrder
    _count?: EncounterCountOrderByAggregateInput
    _avg?: EncounterAvgOrderByAggregateInput
    _max?: EncounterMaxOrderByAggregateInput
    _min?: EncounterMinOrderByAggregateInput
    _sum?: EncounterSumOrderByAggregateInput
  }

  export type EncounterScalarWhereWithAggregatesInput = {
    AND?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    OR?: EncounterScalarWhereWithAggregatesInput[]
    NOT?: EncounterScalarWhereWithAggregatesInput | EncounterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Encounter"> | number
    version_id?: IntWithAggregatesFilter<"Encounter"> | number
    pokemon_id?: IntWithAggregatesFilter<"Encounter"> | number
    location_area_id?: IntWithAggregatesFilter<"Encounter"> | number
    encounter_slot_id?: IntWithAggregatesFilter<"Encounter"> | number
    min_level?: IntWithAggregatesFilter<"Encounter"> | number
    max_level?: IntWithAggregatesFilter<"Encounter"> | number
  }

  export type EncounterConditionWhereInput = {
    AND?: EncounterConditionWhereInput | EncounterConditionWhereInput[]
    OR?: EncounterConditionWhereInput[]
    NOT?: EncounterConditionWhereInput | EncounterConditionWhereInput[]
    id?: IntFilter<"EncounterCondition"> | number
    name?: StringFilter<"EncounterCondition"> | string
    values?: EncounterConditionValueListRelationFilter
  }

  export type EncounterConditionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    values?: EncounterConditionValueOrderByRelationAggregateInput
  }

  export type EncounterConditionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EncounterConditionWhereInput | EncounterConditionWhereInput[]
    OR?: EncounterConditionWhereInput[]
    NOT?: EncounterConditionWhereInput | EncounterConditionWhereInput[]
    name?: StringFilter<"EncounterCondition"> | string
    values?: EncounterConditionValueListRelationFilter
  }, "id">

  export type EncounterConditionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: EncounterConditionCountOrderByAggregateInput
    _avg?: EncounterConditionAvgOrderByAggregateInput
    _max?: EncounterConditionMaxOrderByAggregateInput
    _min?: EncounterConditionMinOrderByAggregateInput
    _sum?: EncounterConditionSumOrderByAggregateInput
  }

  export type EncounterConditionScalarWhereWithAggregatesInput = {
    AND?: EncounterConditionScalarWhereWithAggregatesInput | EncounterConditionScalarWhereWithAggregatesInput[]
    OR?: EncounterConditionScalarWhereWithAggregatesInput[]
    NOT?: EncounterConditionScalarWhereWithAggregatesInput | EncounterConditionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EncounterCondition"> | number
    name?: StringWithAggregatesFilter<"EncounterCondition"> | string
  }

  export type EncounterConditionValueWhereInput = {
    AND?: EncounterConditionValueWhereInput | EncounterConditionValueWhereInput[]
    OR?: EncounterConditionValueWhereInput[]
    NOT?: EncounterConditionValueWhereInput | EncounterConditionValueWhereInput[]
    id?: IntFilter<"EncounterConditionValue"> | number
    encounter_condition_id?: IntFilter<"EncounterConditionValue"> | number
    name?: StringFilter<"EncounterConditionValue"> | string
    is_default?: BoolFilter<"EncounterConditionValue"> | boolean
    condition?: XOR<EncounterConditionScalarRelationFilter, EncounterConditionWhereInput>
    maps?: EncounterConditionValueMapListRelationFilter
  }

  export type EncounterConditionValueOrderByWithRelationInput = {
    id?: SortOrder
    encounter_condition_id?: SortOrder
    name?: SortOrder
    is_default?: SortOrder
    condition?: EncounterConditionOrderByWithRelationInput
    maps?: EncounterConditionValueMapOrderByRelationAggregateInput
  }

  export type EncounterConditionValueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EncounterConditionValueWhereInput | EncounterConditionValueWhereInput[]
    OR?: EncounterConditionValueWhereInput[]
    NOT?: EncounterConditionValueWhereInput | EncounterConditionValueWhereInput[]
    encounter_condition_id?: IntFilter<"EncounterConditionValue"> | number
    name?: StringFilter<"EncounterConditionValue"> | string
    is_default?: BoolFilter<"EncounterConditionValue"> | boolean
    condition?: XOR<EncounterConditionScalarRelationFilter, EncounterConditionWhereInput>
    maps?: EncounterConditionValueMapListRelationFilter
  }, "id">

  export type EncounterConditionValueOrderByWithAggregationInput = {
    id?: SortOrder
    encounter_condition_id?: SortOrder
    name?: SortOrder
    is_default?: SortOrder
    _count?: EncounterConditionValueCountOrderByAggregateInput
    _avg?: EncounterConditionValueAvgOrderByAggregateInput
    _max?: EncounterConditionValueMaxOrderByAggregateInput
    _min?: EncounterConditionValueMinOrderByAggregateInput
    _sum?: EncounterConditionValueSumOrderByAggregateInput
  }

  export type EncounterConditionValueScalarWhereWithAggregatesInput = {
    AND?: EncounterConditionValueScalarWhereWithAggregatesInput | EncounterConditionValueScalarWhereWithAggregatesInput[]
    OR?: EncounterConditionValueScalarWhereWithAggregatesInput[]
    NOT?: EncounterConditionValueScalarWhereWithAggregatesInput | EncounterConditionValueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EncounterConditionValue"> | number
    encounter_condition_id?: IntWithAggregatesFilter<"EncounterConditionValue"> | number
    name?: StringWithAggregatesFilter<"EncounterConditionValue"> | string
    is_default?: BoolWithAggregatesFilter<"EncounterConditionValue"> | boolean
  }

  export type EncounterConditionValueMapWhereInput = {
    AND?: EncounterConditionValueMapWhereInput | EncounterConditionValueMapWhereInput[]
    OR?: EncounterConditionValueMapWhereInput[]
    NOT?: EncounterConditionValueMapWhereInput | EncounterConditionValueMapWhereInput[]
    id?: IntFilter<"EncounterConditionValueMap"> | number
    encounter_id?: IntFilter<"EncounterConditionValueMap"> | number
    encounter_condition_value_id?: IntFilter<"EncounterConditionValueMap"> | number
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    value?: XOR<EncounterConditionValueScalarRelationFilter, EncounterConditionValueWhereInput>
  }

  export type EncounterConditionValueMapOrderByWithRelationInput = {
    id?: SortOrder
    encounter_id?: SortOrder
    encounter_condition_value_id?: SortOrder
    encounter?: EncounterOrderByWithRelationInput
    value?: EncounterConditionValueOrderByWithRelationInput
  }

  export type EncounterConditionValueMapWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EncounterConditionValueMapWhereInput | EncounterConditionValueMapWhereInput[]
    OR?: EncounterConditionValueMapWhereInput[]
    NOT?: EncounterConditionValueMapWhereInput | EncounterConditionValueMapWhereInput[]
    encounter_id?: IntFilter<"EncounterConditionValueMap"> | number
    encounter_condition_value_id?: IntFilter<"EncounterConditionValueMap"> | number
    encounter?: XOR<EncounterScalarRelationFilter, EncounterWhereInput>
    value?: XOR<EncounterConditionValueScalarRelationFilter, EncounterConditionValueWhereInput>
  }, "id">

  export type EncounterConditionValueMapOrderByWithAggregationInput = {
    id?: SortOrder
    encounter_id?: SortOrder
    encounter_condition_value_id?: SortOrder
    _count?: EncounterConditionValueMapCountOrderByAggregateInput
    _avg?: EncounterConditionValueMapAvgOrderByAggregateInput
    _max?: EncounterConditionValueMapMaxOrderByAggregateInput
    _min?: EncounterConditionValueMapMinOrderByAggregateInput
    _sum?: EncounterConditionValueMapSumOrderByAggregateInput
  }

  export type EncounterConditionValueMapScalarWhereWithAggregatesInput = {
    AND?: EncounterConditionValueMapScalarWhereWithAggregatesInput | EncounterConditionValueMapScalarWhereWithAggregatesInput[]
    OR?: EncounterConditionValueMapScalarWhereWithAggregatesInput[]
    NOT?: EncounterConditionValueMapScalarWhereWithAggregatesInput | EncounterConditionValueMapScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EncounterConditionValueMap"> | number
    encounter_id?: IntWithAggregatesFilter<"EncounterConditionValueMap"> | number
    encounter_condition_value_id?: IntWithAggregatesFilter<"EncounterConditionValueMap"> | number
  }

  export type LocationAreaEncounterRateWhereInput = {
    AND?: LocationAreaEncounterRateWhereInput | LocationAreaEncounterRateWhereInput[]
    OR?: LocationAreaEncounterRateWhereInput[]
    NOT?: LocationAreaEncounterRateWhereInput | LocationAreaEncounterRateWhereInput[]
    id?: IntFilter<"LocationAreaEncounterRate"> | number
    location_area_id?: IntFilter<"LocationAreaEncounterRate"> | number
    encounter_method_id?: IntFilter<"LocationAreaEncounterRate"> | number
    version_id?: IntFilter<"LocationAreaEncounterRate"> | number
    rate?: IntFilter<"LocationAreaEncounterRate"> | number
    location_area?: XOR<LocationAreaScalarRelationFilter, LocationAreaWhereInput>
    encounter_method?: XOR<EncounterMethodScalarRelationFilter, EncounterMethodWhereInput>
    version?: XOR<VersionScalarRelationFilter, VersionWhereInput>
  }

  export type LocationAreaEncounterRateOrderByWithRelationInput = {
    id?: SortOrder
    location_area_id?: SortOrder
    encounter_method_id?: SortOrder
    version_id?: SortOrder
    rate?: SortOrder
    location_area?: LocationAreaOrderByWithRelationInput
    encounter_method?: EncounterMethodOrderByWithRelationInput
    version?: VersionOrderByWithRelationInput
  }

  export type LocationAreaEncounterRateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LocationAreaEncounterRateWhereInput | LocationAreaEncounterRateWhereInput[]
    OR?: LocationAreaEncounterRateWhereInput[]
    NOT?: LocationAreaEncounterRateWhereInput | LocationAreaEncounterRateWhereInput[]
    location_area_id?: IntFilter<"LocationAreaEncounterRate"> | number
    encounter_method_id?: IntFilter<"LocationAreaEncounterRate"> | number
    version_id?: IntFilter<"LocationAreaEncounterRate"> | number
    rate?: IntFilter<"LocationAreaEncounterRate"> | number
    location_area?: XOR<LocationAreaScalarRelationFilter, LocationAreaWhereInput>
    encounter_method?: XOR<EncounterMethodScalarRelationFilter, EncounterMethodWhereInput>
    version?: XOR<VersionScalarRelationFilter, VersionWhereInput>
  }, "id">

  export type LocationAreaEncounterRateOrderByWithAggregationInput = {
    id?: SortOrder
    location_area_id?: SortOrder
    encounter_method_id?: SortOrder
    version_id?: SortOrder
    rate?: SortOrder
    _count?: LocationAreaEncounterRateCountOrderByAggregateInput
    _avg?: LocationAreaEncounterRateAvgOrderByAggregateInput
    _max?: LocationAreaEncounterRateMaxOrderByAggregateInput
    _min?: LocationAreaEncounterRateMinOrderByAggregateInput
    _sum?: LocationAreaEncounterRateSumOrderByAggregateInput
  }

  export type LocationAreaEncounterRateScalarWhereWithAggregatesInput = {
    AND?: LocationAreaEncounterRateScalarWhereWithAggregatesInput | LocationAreaEncounterRateScalarWhereWithAggregatesInput[]
    OR?: LocationAreaEncounterRateScalarWhereWithAggregatesInput[]
    NOT?: LocationAreaEncounterRateScalarWhereWithAggregatesInput | LocationAreaEncounterRateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LocationAreaEncounterRate"> | number
    location_area_id?: IntWithAggregatesFilter<"LocationAreaEncounterRate"> | number
    encounter_method_id?: IntWithAggregatesFilter<"LocationAreaEncounterRate"> | number
    version_id?: IntWithAggregatesFilter<"LocationAreaEncounterRate"> | number
    rate?: IntWithAggregatesFilter<"LocationAreaEncounterRate"> | number
  }

  export type MoveDamageClassWhereInput = {
    AND?: MoveDamageClassWhereInput | MoveDamageClassWhereInput[]
    OR?: MoveDamageClassWhereInput[]
    NOT?: MoveDamageClassWhereInput | MoveDamageClassWhereInput[]
    id?: IntFilter<"MoveDamageClass"> | number
    name?: StringFilter<"MoveDamageClass"> | string
    moves?: MoveListRelationFilter
  }

  export type MoveDamageClassOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    moves?: MoveOrderByRelationAggregateInput
  }

  export type MoveDamageClassWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MoveDamageClassWhereInput | MoveDamageClassWhereInput[]
    OR?: MoveDamageClassWhereInput[]
    NOT?: MoveDamageClassWhereInput | MoveDamageClassWhereInput[]
    name?: StringFilter<"MoveDamageClass"> | string
    moves?: MoveListRelationFilter
  }, "id">

  export type MoveDamageClassOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: MoveDamageClassCountOrderByAggregateInput
    _avg?: MoveDamageClassAvgOrderByAggregateInput
    _max?: MoveDamageClassMaxOrderByAggregateInput
    _min?: MoveDamageClassMinOrderByAggregateInput
    _sum?: MoveDamageClassSumOrderByAggregateInput
  }

  export type MoveDamageClassScalarWhereWithAggregatesInput = {
    AND?: MoveDamageClassScalarWhereWithAggregatesInput | MoveDamageClassScalarWhereWithAggregatesInput[]
    OR?: MoveDamageClassScalarWhereWithAggregatesInput[]
    NOT?: MoveDamageClassScalarWhereWithAggregatesInput | MoveDamageClassScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MoveDamageClass"> | number
    name?: StringWithAggregatesFilter<"MoveDamageClass"> | string
  }

  export type MoveEffectWhereInput = {
    AND?: MoveEffectWhereInput | MoveEffectWhereInput[]
    OR?: MoveEffectWhereInput[]
    NOT?: MoveEffectWhereInput | MoveEffectWhereInput[]
    id?: IntFilter<"MoveEffect"> | number
    description?: StringFilter<"MoveEffect"> | string
    moves?: MoveListRelationFilter
  }

  export type MoveEffectOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    moves?: MoveOrderByRelationAggregateInput
  }

  export type MoveEffectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MoveEffectWhereInput | MoveEffectWhereInput[]
    OR?: MoveEffectWhereInput[]
    NOT?: MoveEffectWhereInput | MoveEffectWhereInput[]
    description?: StringFilter<"MoveEffect"> | string
    moves?: MoveListRelationFilter
  }, "id">

  export type MoveEffectOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    _count?: MoveEffectCountOrderByAggregateInput
    _avg?: MoveEffectAvgOrderByAggregateInput
    _max?: MoveEffectMaxOrderByAggregateInput
    _min?: MoveEffectMinOrderByAggregateInput
    _sum?: MoveEffectSumOrderByAggregateInput
  }

  export type MoveEffectScalarWhereWithAggregatesInput = {
    AND?: MoveEffectScalarWhereWithAggregatesInput | MoveEffectScalarWhereWithAggregatesInput[]
    OR?: MoveEffectScalarWhereWithAggregatesInput[]
    NOT?: MoveEffectScalarWhereWithAggregatesInput | MoveEffectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MoveEffect"> | number
    description?: StringWithAggregatesFilter<"MoveEffect"> | string
  }

  export type MoveMethodWhereInput = {
    AND?: MoveMethodWhereInput | MoveMethodWhereInput[]
    OR?: MoveMethodWhereInput[]
    NOT?: MoveMethodWhereInput | MoveMethodWhereInput[]
    id?: IntFilter<"MoveMethod"> | number
    name?: StringFilter<"MoveMethod"> | string
    moves?: PokemonMoveListRelationFilter
  }

  export type MoveMethodOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    moves?: PokemonMoveOrderByRelationAggregateInput
  }

  export type MoveMethodWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MoveMethodWhereInput | MoveMethodWhereInput[]
    OR?: MoveMethodWhereInput[]
    NOT?: MoveMethodWhereInput | MoveMethodWhereInput[]
    name?: StringFilter<"MoveMethod"> | string
    moves?: PokemonMoveListRelationFilter
  }, "id">

  export type MoveMethodOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: MoveMethodCountOrderByAggregateInput
    _avg?: MoveMethodAvgOrderByAggregateInput
    _max?: MoveMethodMaxOrderByAggregateInput
    _min?: MoveMethodMinOrderByAggregateInput
    _sum?: MoveMethodSumOrderByAggregateInput
  }

  export type MoveMethodScalarWhereWithAggregatesInput = {
    AND?: MoveMethodScalarWhereWithAggregatesInput | MoveMethodScalarWhereWithAggregatesInput[]
    OR?: MoveMethodScalarWhereWithAggregatesInput[]
    NOT?: MoveMethodScalarWhereWithAggregatesInput | MoveMethodScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MoveMethod"> | number
    name?: StringWithAggregatesFilter<"MoveMethod"> | string
  }

  export type MoveWhereInput = {
    AND?: MoveWhereInput | MoveWhereInput[]
    OR?: MoveWhereInput[]
    NOT?: MoveWhereInput | MoveWhereInput[]
    id?: IntFilter<"Move"> | number
    name?: StringFilter<"Move"> | string
    generation_id?: IntFilter<"Move"> | number
    type_id?: IntFilter<"Move"> | number
    pp?: IntFilter<"Move"> | number
    accuracy?: IntNullableFilter<"Move"> | number | null
    priority?: IntFilter<"Move"> | number
    move_damage_class_id?: IntFilter<"Move"> | number
    move_effect_id?: IntFilter<"Move"> | number
    type?: XOR<TypeScalarRelationFilter, TypeWhereInput>
    damage_class?: XOR<MoveDamageClassScalarRelationFilter, MoveDamageClassWhereInput>
    effect?: XOR<MoveEffectScalarRelationFilter, MoveEffectWhereInput>
    pokemon_moves?: PokemonMoveListRelationFilter
  }

  export type MoveOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    generation_id?: SortOrder
    type_id?: SortOrder
    pp?: SortOrder
    accuracy?: SortOrderInput | SortOrder
    priority?: SortOrder
    move_damage_class_id?: SortOrder
    move_effect_id?: SortOrder
    type?: TypeOrderByWithRelationInput
    damage_class?: MoveDamageClassOrderByWithRelationInput
    effect?: MoveEffectOrderByWithRelationInput
    pokemon_moves?: PokemonMoveOrderByRelationAggregateInput
  }

  export type MoveWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MoveWhereInput | MoveWhereInput[]
    OR?: MoveWhereInput[]
    NOT?: MoveWhereInput | MoveWhereInput[]
    name?: StringFilter<"Move"> | string
    generation_id?: IntFilter<"Move"> | number
    type_id?: IntFilter<"Move"> | number
    pp?: IntFilter<"Move"> | number
    accuracy?: IntNullableFilter<"Move"> | number | null
    priority?: IntFilter<"Move"> | number
    move_damage_class_id?: IntFilter<"Move"> | number
    move_effect_id?: IntFilter<"Move"> | number
    type?: XOR<TypeScalarRelationFilter, TypeWhereInput>
    damage_class?: XOR<MoveDamageClassScalarRelationFilter, MoveDamageClassWhereInput>
    effect?: XOR<MoveEffectScalarRelationFilter, MoveEffectWhereInput>
    pokemon_moves?: PokemonMoveListRelationFilter
  }, "id">

  export type MoveOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    generation_id?: SortOrder
    type_id?: SortOrder
    pp?: SortOrder
    accuracy?: SortOrderInput | SortOrder
    priority?: SortOrder
    move_damage_class_id?: SortOrder
    move_effect_id?: SortOrder
    _count?: MoveCountOrderByAggregateInput
    _avg?: MoveAvgOrderByAggregateInput
    _max?: MoveMaxOrderByAggregateInput
    _min?: MoveMinOrderByAggregateInput
    _sum?: MoveSumOrderByAggregateInput
  }

  export type MoveScalarWhereWithAggregatesInput = {
    AND?: MoveScalarWhereWithAggregatesInput | MoveScalarWhereWithAggregatesInput[]
    OR?: MoveScalarWhereWithAggregatesInput[]
    NOT?: MoveScalarWhereWithAggregatesInput | MoveScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Move"> | number
    name?: StringWithAggregatesFilter<"Move"> | string
    generation_id?: IntWithAggregatesFilter<"Move"> | number
    type_id?: IntWithAggregatesFilter<"Move"> | number
    pp?: IntWithAggregatesFilter<"Move"> | number
    accuracy?: IntNullableWithAggregatesFilter<"Move"> | number | null
    priority?: IntWithAggregatesFilter<"Move"> | number
    move_damage_class_id?: IntWithAggregatesFilter<"Move"> | number
    move_effect_id?: IntWithAggregatesFilter<"Move"> | number
  }

  export type PokemonMoveWhereInput = {
    AND?: PokemonMoveWhereInput | PokemonMoveWhereInput[]
    OR?: PokemonMoveWhereInput[]
    NOT?: PokemonMoveWhereInput | PokemonMoveWhereInput[]
    id?: IntFilter<"PokemonMove"> | number
    version_group_id?: IntFilter<"PokemonMove"> | number
    move_method_id?: IntFilter<"PokemonMove"> | number
    move_id?: IntFilter<"PokemonMove"> | number
    pokemon_id?: IntFilter<"PokemonMove"> | number
    level?: IntFilter<"PokemonMove"> | number
    version_group?: XOR<VersionGroupScalarRelationFilter, VersionGroupWhereInput>
    method?: XOR<MoveMethodScalarRelationFilter, MoveMethodWhereInput>
    move?: XOR<MoveScalarRelationFilter, MoveWhereInput>
    pokemon?: XOR<PokemonScalarRelationFilter, PokemonWhereInput>
  }

  export type PokemonMoveOrderByWithRelationInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    move_method_id?: SortOrder
    move_id?: SortOrder
    pokemon_id?: SortOrder
    level?: SortOrder
    version_group?: VersionGroupOrderByWithRelationInput
    method?: MoveMethodOrderByWithRelationInput
    move?: MoveOrderByWithRelationInput
    pokemon?: PokemonOrderByWithRelationInput
  }

  export type PokemonMoveWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PokemonMoveWhereInput | PokemonMoveWhereInput[]
    OR?: PokemonMoveWhereInput[]
    NOT?: PokemonMoveWhereInput | PokemonMoveWhereInput[]
    version_group_id?: IntFilter<"PokemonMove"> | number
    move_method_id?: IntFilter<"PokemonMove"> | number
    move_id?: IntFilter<"PokemonMove"> | number
    pokemon_id?: IntFilter<"PokemonMove"> | number
    level?: IntFilter<"PokemonMove"> | number
    version_group?: XOR<VersionGroupScalarRelationFilter, VersionGroupWhereInput>
    method?: XOR<MoveMethodScalarRelationFilter, MoveMethodWhereInput>
    move?: XOR<MoveScalarRelationFilter, MoveWhereInput>
    pokemon?: XOR<PokemonScalarRelationFilter, PokemonWhereInput>
  }, "id">

  export type PokemonMoveOrderByWithAggregationInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    move_method_id?: SortOrder
    move_id?: SortOrder
    pokemon_id?: SortOrder
    level?: SortOrder
    _count?: PokemonMoveCountOrderByAggregateInput
    _avg?: PokemonMoveAvgOrderByAggregateInput
    _max?: PokemonMoveMaxOrderByAggregateInput
    _min?: PokemonMoveMinOrderByAggregateInput
    _sum?: PokemonMoveSumOrderByAggregateInput
  }

  export type PokemonMoveScalarWhereWithAggregatesInput = {
    AND?: PokemonMoveScalarWhereWithAggregatesInput | PokemonMoveScalarWhereWithAggregatesInput[]
    OR?: PokemonMoveScalarWhereWithAggregatesInput[]
    NOT?: PokemonMoveScalarWhereWithAggregatesInput | PokemonMoveScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PokemonMove"> | number
    version_group_id?: IntWithAggregatesFilter<"PokemonMove"> | number
    move_method_id?: IntWithAggregatesFilter<"PokemonMove"> | number
    move_id?: IntWithAggregatesFilter<"PokemonMove"> | number
    pokemon_id?: IntWithAggregatesFilter<"PokemonMove"> | number
    level?: IntWithAggregatesFilter<"PokemonMove"> | number
  }

  export type PokedexWhereInput = {
    AND?: PokedexWhereInput | PokedexWhereInput[]
    OR?: PokedexWhereInput[]
    NOT?: PokedexWhereInput | PokedexWhereInput[]
    id?: IntFilter<"Pokedex"> | number
    name?: StringFilter<"Pokedex"> | string
    region_id?: IntFilter<"Pokedex"> | number
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    pokedex_version_groups?: PokedexVersionGroupListRelationFilter
    pokemon_dex_numbers?: PokemonDexNumberListRelationFilter
  }

  export type PokedexOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
    region?: RegionOrderByWithRelationInput
    pokedex_version_groups?: PokedexVersionGroupOrderByRelationAggregateInput
    pokemon_dex_numbers?: PokemonDexNumberOrderByRelationAggregateInput
  }

  export type PokedexWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PokedexWhereInput | PokedexWhereInput[]
    OR?: PokedexWhereInput[]
    NOT?: PokedexWhereInput | PokedexWhereInput[]
    name?: StringFilter<"Pokedex"> | string
    region_id?: IntFilter<"Pokedex"> | number
    region?: XOR<RegionScalarRelationFilter, RegionWhereInput>
    pokedex_version_groups?: PokedexVersionGroupListRelationFilter
    pokemon_dex_numbers?: PokemonDexNumberListRelationFilter
  }, "id">

  export type PokedexOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
    _count?: PokedexCountOrderByAggregateInput
    _avg?: PokedexAvgOrderByAggregateInput
    _max?: PokedexMaxOrderByAggregateInput
    _min?: PokedexMinOrderByAggregateInput
    _sum?: PokedexSumOrderByAggregateInput
  }

  export type PokedexScalarWhereWithAggregatesInput = {
    AND?: PokedexScalarWhereWithAggregatesInput | PokedexScalarWhereWithAggregatesInput[]
    OR?: PokedexScalarWhereWithAggregatesInput[]
    NOT?: PokedexScalarWhereWithAggregatesInput | PokedexScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pokedex"> | number
    name?: StringWithAggregatesFilter<"Pokedex"> | string
    region_id?: IntWithAggregatesFilter<"Pokedex"> | number
  }

  export type PokedexVersionGroupWhereInput = {
    AND?: PokedexVersionGroupWhereInput | PokedexVersionGroupWhereInput[]
    OR?: PokedexVersionGroupWhereInput[]
    NOT?: PokedexVersionGroupWhereInput | PokedexVersionGroupWhereInput[]
    id?: IntFilter<"PokedexVersionGroup"> | number
    version_group_id?: IntFilter<"PokedexVersionGroup"> | number
    pokedex_id?: IntFilter<"PokedexVersionGroup"> | number
    version_group?: XOR<VersionGroupScalarRelationFilter, VersionGroupWhereInput>
    pokedex?: XOR<PokedexScalarRelationFilter, PokedexWhereInput>
  }

  export type PokedexVersionGroupOrderByWithRelationInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    pokedex_id?: SortOrder
    version_group?: VersionGroupOrderByWithRelationInput
    pokedex?: PokedexOrderByWithRelationInput
  }

  export type PokedexVersionGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PokedexVersionGroupWhereInput | PokedexVersionGroupWhereInput[]
    OR?: PokedexVersionGroupWhereInput[]
    NOT?: PokedexVersionGroupWhereInput | PokedexVersionGroupWhereInput[]
    version_group_id?: IntFilter<"PokedexVersionGroup"> | number
    pokedex_id?: IntFilter<"PokedexVersionGroup"> | number
    version_group?: XOR<VersionGroupScalarRelationFilter, VersionGroupWhereInput>
    pokedex?: XOR<PokedexScalarRelationFilter, PokedexWhereInput>
  }, "id">

  export type PokedexVersionGroupOrderByWithAggregationInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    pokedex_id?: SortOrder
    _count?: PokedexVersionGroupCountOrderByAggregateInput
    _avg?: PokedexVersionGroupAvgOrderByAggregateInput
    _max?: PokedexVersionGroupMaxOrderByAggregateInput
    _min?: PokedexVersionGroupMinOrderByAggregateInput
    _sum?: PokedexVersionGroupSumOrderByAggregateInput
  }

  export type PokedexVersionGroupScalarWhereWithAggregatesInput = {
    AND?: PokedexVersionGroupScalarWhereWithAggregatesInput | PokedexVersionGroupScalarWhereWithAggregatesInput[]
    OR?: PokedexVersionGroupScalarWhereWithAggregatesInput[]
    NOT?: PokedexVersionGroupScalarWhereWithAggregatesInput | PokedexVersionGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PokedexVersionGroup"> | number
    version_group_id?: IntWithAggregatesFilter<"PokedexVersionGroup"> | number
    pokedex_id?: IntWithAggregatesFilter<"PokedexVersionGroup"> | number
  }

  export type PokemonDexNumberWhereInput = {
    AND?: PokemonDexNumberWhereInput | PokemonDexNumberWhereInput[]
    OR?: PokemonDexNumberWhereInput[]
    NOT?: PokemonDexNumberWhereInput | PokemonDexNumberWhereInput[]
    id?: IntFilter<"PokemonDexNumber"> | number
    pokemon_id?: IntFilter<"PokemonDexNumber"> | number
    pokedex_id?: IntFilter<"PokemonDexNumber"> | number
    pokedex_number?: IntFilter<"PokemonDexNumber"> | number
    pokemon?: XOR<PokemonScalarRelationFilter, PokemonWhereInput>
    pokedex?: XOR<PokedexScalarRelationFilter, PokedexWhereInput>
  }

  export type PokemonDexNumberOrderByWithRelationInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    pokedex_id?: SortOrder
    pokedex_number?: SortOrder
    pokemon?: PokemonOrderByWithRelationInput
    pokedex?: PokedexOrderByWithRelationInput
  }

  export type PokemonDexNumberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PokemonDexNumberWhereInput | PokemonDexNumberWhereInput[]
    OR?: PokemonDexNumberWhereInput[]
    NOT?: PokemonDexNumberWhereInput | PokemonDexNumberWhereInput[]
    pokemon_id?: IntFilter<"PokemonDexNumber"> | number
    pokedex_id?: IntFilter<"PokemonDexNumber"> | number
    pokedex_number?: IntFilter<"PokemonDexNumber"> | number
    pokemon?: XOR<PokemonScalarRelationFilter, PokemonWhereInput>
    pokedex?: XOR<PokedexScalarRelationFilter, PokedexWhereInput>
  }, "id">

  export type PokemonDexNumberOrderByWithAggregationInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    pokedex_id?: SortOrder
    pokedex_number?: SortOrder
    _count?: PokemonDexNumberCountOrderByAggregateInput
    _avg?: PokemonDexNumberAvgOrderByAggregateInput
    _max?: PokemonDexNumberMaxOrderByAggregateInput
    _min?: PokemonDexNumberMinOrderByAggregateInput
    _sum?: PokemonDexNumberSumOrderByAggregateInput
  }

  export type PokemonDexNumberScalarWhereWithAggregatesInput = {
    AND?: PokemonDexNumberScalarWhereWithAggregatesInput | PokemonDexNumberScalarWhereWithAggregatesInput[]
    OR?: PokemonDexNumberScalarWhereWithAggregatesInput[]
    NOT?: PokemonDexNumberScalarWhereWithAggregatesInput | PokemonDexNumberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PokemonDexNumber"> | number
    pokemon_id?: IntWithAggregatesFilter<"PokemonDexNumber"> | number
    pokedex_id?: IntWithAggregatesFilter<"PokemonDexNumber"> | number
    pokedex_number?: IntWithAggregatesFilter<"PokemonDexNumber"> | number
  }

  export type UserCreateInput = {
    id: number
    email: string
    name: string
    password: string
    role?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id: number
    email: string
    name: string
    password: string
    role?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id: number
    email: string
    name: string
    password: string
    role?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PokemonCreateInput = {
    id: number
    name: string
    abilities?: PokemonAbilityCreateNestedManyWithoutPokemonInput
    natures?: PokemonNatureCreateNestedManyWithoutPokemonInput
    stats?: PokemonStatCreateNestedManyWithoutPokemonInput
    types?: PokemonTypeCreateNestedManyWithoutPokemonInput
    egg_groups?: PokemonEggGroupCreateNestedManyWithoutPokemonInput
    encounters?: EncounterCreateNestedManyWithoutPokemonInput
    dex_numbers?: PokemonDexNumberCreateNestedManyWithoutPokemonInput
    move?: PokemonMoveCreateNestedManyWithoutPokemonInput
  }

  export type PokemonUncheckedCreateInput = {
    id: number
    name: string
    abilities?: PokemonAbilityUncheckedCreateNestedManyWithoutPokemonInput
    natures?: PokemonNatureUncheckedCreateNestedManyWithoutPokemonInput
    stats?: PokemonStatUncheckedCreateNestedManyWithoutPokemonInput
    types?: PokemonTypeUncheckedCreateNestedManyWithoutPokemonInput
    egg_groups?: PokemonEggGroupUncheckedCreateNestedManyWithoutPokemonInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutPokemonInput
    dex_numbers?: PokemonDexNumberUncheckedCreateNestedManyWithoutPokemonInput
    move?: PokemonMoveUncheckedCreateNestedManyWithoutPokemonInput
  }

  export type PokemonUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abilities?: PokemonAbilityUpdateManyWithoutPokemonNestedInput
    natures?: PokemonNatureUpdateManyWithoutPokemonNestedInput
    stats?: PokemonStatUpdateManyWithoutPokemonNestedInput
    types?: PokemonTypeUpdateManyWithoutPokemonNestedInput
    egg_groups?: PokemonEggGroupUpdateManyWithoutPokemonNestedInput
    encounters?: EncounterUpdateManyWithoutPokemonNestedInput
    dex_numbers?: PokemonDexNumberUpdateManyWithoutPokemonNestedInput
    move?: PokemonMoveUpdateManyWithoutPokemonNestedInput
  }

  export type PokemonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abilities?: PokemonAbilityUncheckedUpdateManyWithoutPokemonNestedInput
    natures?: PokemonNatureUncheckedUpdateManyWithoutPokemonNestedInput
    stats?: PokemonStatUncheckedUpdateManyWithoutPokemonNestedInput
    types?: PokemonTypeUncheckedUpdateManyWithoutPokemonNestedInput
    egg_groups?: PokemonEggGroupUncheckedUpdateManyWithoutPokemonNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutPokemonNestedInput
    dex_numbers?: PokemonDexNumberUncheckedUpdateManyWithoutPokemonNestedInput
    move?: PokemonMoveUncheckedUpdateManyWithoutPokemonNestedInput
  }

  export type PokemonCreateManyInput = {
    id: number
    name: string
  }

  export type PokemonUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PokemonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AbilityCreateInput = {
    id: number
    name: string
    description: string
    pokemon?: PokemonAbilityCreateNestedManyWithoutAbilityInput
  }

  export type AbilityUncheckedCreateInput = {
    id: number
    name: string
    description: string
    pokemon?: PokemonAbilityUncheckedCreateNestedManyWithoutAbilityInput
  }

  export type AbilityUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    pokemon?: PokemonAbilityUpdateManyWithoutAbilityNestedInput
  }

  export type AbilityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    pokemon?: PokemonAbilityUncheckedUpdateManyWithoutAbilityNestedInput
  }

  export type AbilityCreateManyInput = {
    id: number
    name: string
    description: string
  }

  export type AbilityUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type AbilityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PokemonAbilityCreateInput = {
    id: number
    is_hidden: boolean
    pokemon: PokemonCreateNestedOneWithoutAbilitiesInput
    ability: AbilityCreateNestedOneWithoutPokemonInput
  }

  export type PokemonAbilityUncheckedCreateInput = {
    id: number
    pokemon_id: number
    ability_id: number
    is_hidden: boolean
  }

  export type PokemonAbilityUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    is_hidden?: BoolFieldUpdateOperationsInput | boolean
    pokemon?: PokemonUpdateOneRequiredWithoutAbilitiesNestedInput
    ability?: AbilityUpdateOneRequiredWithoutPokemonNestedInput
  }

  export type PokemonAbilityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    ability_id?: IntFieldUpdateOperationsInput | number
    is_hidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PokemonAbilityCreateManyInput = {
    id: number
    pokemon_id: number
    ability_id: number
    is_hidden: boolean
  }

  export type PokemonAbilityUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    is_hidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PokemonAbilityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    ability_id?: IntFieldUpdateOperationsInput | number
    is_hidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NatureCreateInput = {
    id: number
    name: string
    stat_increased: StatCreateNestedOneWithoutNatures_increaseInput
    stat_decreased: StatCreateNestedOneWithoutNatures_decreaseInput
    pokemon?: PokemonNatureCreateNestedManyWithoutNatureInput
  }

  export type NatureUncheckedCreateInput = {
    id: number
    name: string
    increased_stat_id: number
    decreased_stat_id: number
    pokemon?: PokemonNatureUncheckedCreateNestedManyWithoutNatureInput
  }

  export type NatureUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    stat_increased?: StatUpdateOneRequiredWithoutNatures_increaseNestedInput
    stat_decreased?: StatUpdateOneRequiredWithoutNatures_decreaseNestedInput
    pokemon?: PokemonNatureUpdateManyWithoutNatureNestedInput
  }

  export type NatureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    increased_stat_id?: IntFieldUpdateOperationsInput | number
    decreased_stat_id?: IntFieldUpdateOperationsInput | number
    pokemon?: PokemonNatureUncheckedUpdateManyWithoutNatureNestedInput
  }

  export type NatureCreateManyInput = {
    id: number
    name: string
    increased_stat_id: number
    decreased_stat_id: number
  }

  export type NatureUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type NatureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    increased_stat_id?: IntFieldUpdateOperationsInput | number
    decreased_stat_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonNatureCreateInput = {
    id: number
    pokemon: PokemonCreateNestedOneWithoutNaturesInput
    nature: NatureCreateNestedOneWithoutPokemonInput
  }

  export type PokemonNatureUncheckedCreateInput = {
    id: number
    pokemon_id: number
    nature_id: number
  }

  export type PokemonNatureUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon?: PokemonUpdateOneRequiredWithoutNaturesNestedInput
    nature?: NatureUpdateOneRequiredWithoutPokemonNestedInput
  }

  export type PokemonNatureUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    nature_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonNatureCreateManyInput = {
    id: number
    pokemon_id: number
    nature_id: number
  }

  export type PokemonNatureUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonNatureUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    nature_id?: IntFieldUpdateOperationsInput | number
  }

  export type StatCreateInput = {
    id: number
    name: string
    natures_increase?: NatureCreateNestedManyWithoutStat_increasedInput
    natures_decrease?: NatureCreateNestedManyWithoutStat_decreasedInput
    pokemon_stats?: PokemonStatCreateNestedManyWithoutStatInput
  }

  export type StatUncheckedCreateInput = {
    id: number
    name: string
    natures_increase?: NatureUncheckedCreateNestedManyWithoutStat_increasedInput
    natures_decrease?: NatureUncheckedCreateNestedManyWithoutStat_decreasedInput
    pokemon_stats?: PokemonStatUncheckedCreateNestedManyWithoutStatInput
  }

  export type StatUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    natures_increase?: NatureUpdateManyWithoutStat_increasedNestedInput
    natures_decrease?: NatureUpdateManyWithoutStat_decreasedNestedInput
    pokemon_stats?: PokemonStatUpdateManyWithoutStatNestedInput
  }

  export type StatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    natures_increase?: NatureUncheckedUpdateManyWithoutStat_increasedNestedInput
    natures_decrease?: NatureUncheckedUpdateManyWithoutStat_decreasedNestedInput
    pokemon_stats?: PokemonStatUncheckedUpdateManyWithoutStatNestedInput
  }

  export type StatCreateManyInput = {
    id: number
    name: string
  }

  export type StatUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PokemonStatCreateInput = {
    id: number
    base_stat: number
    pokemon: PokemonCreateNestedOneWithoutStatsInput
    stat: StatCreateNestedOneWithoutPokemon_statsInput
  }

  export type PokemonStatUncheckedCreateInput = {
    id: number
    pokemon_id: number
    stat_id: number
    base_stat: number
  }

  export type PokemonStatUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    base_stat?: IntFieldUpdateOperationsInput | number
    pokemon?: PokemonUpdateOneRequiredWithoutStatsNestedInput
    stat?: StatUpdateOneRequiredWithoutPokemon_statsNestedInput
  }

  export type PokemonStatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    stat_id?: IntFieldUpdateOperationsInput | number
    base_stat?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonStatCreateManyInput = {
    id: number
    pokemon_id: number
    stat_id: number
    base_stat: number
  }

  export type PokemonStatUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    base_stat?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonStatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    stat_id?: IntFieldUpdateOperationsInput | number
    base_stat?: IntFieldUpdateOperationsInput | number
  }

  export type TypeCreateInput = {
    id: number
    name: string
    generation: GenerationCreateNestedOneWithoutTypesInput
    pokemon?: PokemonTypeCreateNestedManyWithoutTypeInput
    attacking?: TypeEffectivenessCreateNestedManyWithoutAttackerInput
    defending?: TypeEffectivenessCreateNestedManyWithoutDefenderInput
    move?: MoveCreateNestedManyWithoutTypeInput
  }

  export type TypeUncheckedCreateInput = {
    id: number
    name: string
    generation_id: number
    pokemon?: PokemonTypeUncheckedCreateNestedManyWithoutTypeInput
    attacking?: TypeEffectivenessUncheckedCreateNestedManyWithoutAttackerInput
    defending?: TypeEffectivenessUncheckedCreateNestedManyWithoutDefenderInput
    move?: MoveUncheckedCreateNestedManyWithoutTypeInput
  }

  export type TypeUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation?: GenerationUpdateOneRequiredWithoutTypesNestedInput
    pokemon?: PokemonTypeUpdateManyWithoutTypeNestedInput
    attacking?: TypeEffectivenessUpdateManyWithoutAttackerNestedInput
    defending?: TypeEffectivenessUpdateManyWithoutDefenderNestedInput
    move?: MoveUpdateManyWithoutTypeNestedInput
  }

  export type TypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    pokemon?: PokemonTypeUncheckedUpdateManyWithoutTypeNestedInput
    attacking?: TypeEffectivenessUncheckedUpdateManyWithoutAttackerNestedInput
    defending?: TypeEffectivenessUncheckedUpdateManyWithoutDefenderNestedInput
    move?: MoveUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type TypeCreateManyInput = {
    id: number
    name: string
    generation_id: number
  }

  export type TypeUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
  }

  export type TypeEffectivenessCreateInput = {
    id: number
    damage_factor: number
    attacker: TypeCreateNestedOneWithoutAttackingInput
    defender: TypeCreateNestedOneWithoutDefendingInput
  }

  export type TypeEffectivenessUncheckedCreateInput = {
    id: number
    type_id: number
    target_type_id: number
    damage_factor: number
  }

  export type TypeEffectivenessUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    damage_factor?: IntFieldUpdateOperationsInput | number
    attacker?: TypeUpdateOneRequiredWithoutAttackingNestedInput
    defender?: TypeUpdateOneRequiredWithoutDefendingNestedInput
  }

  export type TypeEffectivenessUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    target_type_id?: IntFieldUpdateOperationsInput | number
    damage_factor?: IntFieldUpdateOperationsInput | number
  }

  export type TypeEffectivenessCreateManyInput = {
    id: number
    type_id: number
    target_type_id: number
    damage_factor: number
  }

  export type TypeEffectivenessUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    damage_factor?: IntFieldUpdateOperationsInput | number
  }

  export type TypeEffectivenessUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    target_type_id?: IntFieldUpdateOperationsInput | number
    damage_factor?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonTypeCreateInput = {
    id: number
    pokemon: PokemonCreateNestedOneWithoutTypesInput
    type: TypeCreateNestedOneWithoutPokemonInput
  }

  export type PokemonTypeUncheckedCreateInput = {
    id: number
    pokemon_id: number
    type_id: number
  }

  export type PokemonTypeUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon?: PokemonUpdateOneRequiredWithoutTypesNestedInput
    type?: TypeUpdateOneRequiredWithoutPokemonNestedInput
  }

  export type PokemonTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonTypeCreateManyInput = {
    id: number
    pokemon_id: number
    type_id: number
  }

  export type PokemonTypeUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
  }

  export type EggGroupCreateInput = {
    id: number
    name: string
    pokemon_egg_group?: PokemonEggGroupCreateNestedManyWithoutEgg_groupInput
  }

  export type EggGroupUncheckedCreateInput = {
    id: number
    name: string
    pokemon_egg_group?: PokemonEggGroupUncheckedCreateNestedManyWithoutEgg_groupInput
  }

  export type EggGroupUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    pokemon_egg_group?: PokemonEggGroupUpdateManyWithoutEgg_groupNestedInput
  }

  export type EggGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    pokemon_egg_group?: PokemonEggGroupUncheckedUpdateManyWithoutEgg_groupNestedInput
  }

  export type EggGroupCreateManyInput = {
    id: number
    name: string
  }

  export type EggGroupUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EggGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PokemonEggGroupCreateInput = {
    id: number
    pokemon: PokemonCreateNestedOneWithoutEgg_groupsInput
    egg_group: EggGroupCreateNestedOneWithoutPokemon_egg_groupInput
  }

  export type PokemonEggGroupUncheckedCreateInput = {
    id: number
    pokemon_id: number
    egg_group_id: number
  }

  export type PokemonEggGroupUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon?: PokemonUpdateOneRequiredWithoutEgg_groupsNestedInput
    egg_group?: EggGroupUpdateOneRequiredWithoutPokemon_egg_groupNestedInput
  }

  export type PokemonEggGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    egg_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonEggGroupCreateManyInput = {
    id: number
    pokemon_id: number
    egg_group_id: number
  }

  export type PokemonEggGroupUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonEggGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    egg_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type RegionCreateInput = {
    id: number
    name: string
    locations?: LocationCreateNestedManyWithoutRegionInput
    version_groups?: VersionGroupRegionCreateNestedManyWithoutRegionInput
    generations?: GenerationCreateNestedOneWithoutRegionInput
    pokedex?: PokedexCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateInput = {
    id: number
    name: string
    locations?: LocationUncheckedCreateNestedManyWithoutRegionInput
    version_groups?: VersionGroupRegionUncheckedCreateNestedManyWithoutRegionInput
    generations?: GenerationUncheckedCreateNestedOneWithoutRegionInput
    pokedex?: PokedexUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: LocationUpdateManyWithoutRegionNestedInput
    version_groups?: VersionGroupRegionUpdateManyWithoutRegionNestedInput
    generations?: GenerationUpdateOneWithoutRegionNestedInput
    pokedex?: PokedexUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: LocationUncheckedUpdateManyWithoutRegionNestedInput
    version_groups?: VersionGroupRegionUncheckedUpdateManyWithoutRegionNestedInput
    generations?: GenerationUncheckedUpdateOneWithoutRegionNestedInput
    pokedex?: PokedexUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type RegionCreateManyInput = {
    id: number
    name: string
  }

  export type RegionUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RegionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GenerationCreateInput = {
    id: number
    name: string
    region: RegionCreateNestedOneWithoutGenerationsInput
    types?: TypeCreateNestedManyWithoutGenerationInput
    versionGroups?: VersionGroupCreateNestedManyWithoutGenerationInput
  }

  export type GenerationUncheckedCreateInput = {
    id: number
    name: string
    region_id: number
    types?: TypeUncheckedCreateNestedManyWithoutGenerationInput
    versionGroups?: VersionGroupUncheckedCreateNestedManyWithoutGenerationInput
  }

  export type GenerationUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutGenerationsNestedInput
    types?: TypeUpdateManyWithoutGenerationNestedInput
    versionGroups?: VersionGroupUpdateManyWithoutGenerationNestedInput
  }

  export type GenerationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
    types?: TypeUncheckedUpdateManyWithoutGenerationNestedInput
    versionGroups?: VersionGroupUncheckedUpdateManyWithoutGenerationNestedInput
  }

  export type GenerationCreateManyInput = {
    id: number
    name: string
    region_id: number
  }

  export type GenerationUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GenerationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
  }

  export type VersionGroupCreateInput = {
    id: number
    name: string
    generation: GenerationCreateNestedOneWithoutVersionGroupsInput
    versions?: VersionCreateNestedManyWithoutVersionGroupInput
    regions?: VersionGroupRegionCreateNestedManyWithoutVersion_groupInput
    slots?: EncounterSlotCreateNestedManyWithoutVersion_groupInput
    moves?: PokemonMoveCreateNestedManyWithoutVersion_groupInput
    pokedex_version_groups?: PokedexVersionGroupCreateNestedManyWithoutVersion_groupInput
  }

  export type VersionGroupUncheckedCreateInput = {
    id: number
    name: string
    generation_id: number
    versions?: VersionUncheckedCreateNestedManyWithoutVersionGroupInput
    regions?: VersionGroupRegionUncheckedCreateNestedManyWithoutVersion_groupInput
    slots?: EncounterSlotUncheckedCreateNestedManyWithoutVersion_groupInput
    moves?: PokemonMoveUncheckedCreateNestedManyWithoutVersion_groupInput
    pokedex_version_groups?: PokedexVersionGroupUncheckedCreateNestedManyWithoutVersion_groupInput
  }

  export type VersionGroupUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation?: GenerationUpdateOneRequiredWithoutVersionGroupsNestedInput
    versions?: VersionUpdateManyWithoutVersionGroupNestedInput
    regions?: VersionGroupRegionUpdateManyWithoutVersion_groupNestedInput
    slots?: EncounterSlotUpdateManyWithoutVersion_groupNestedInput
    moves?: PokemonMoveUpdateManyWithoutVersion_groupNestedInput
    pokedex_version_groups?: PokedexVersionGroupUpdateManyWithoutVersion_groupNestedInput
  }

  export type VersionGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    versions?: VersionUncheckedUpdateManyWithoutVersionGroupNestedInput
    regions?: VersionGroupRegionUncheckedUpdateManyWithoutVersion_groupNestedInput
    slots?: EncounterSlotUncheckedUpdateManyWithoutVersion_groupNestedInput
    moves?: PokemonMoveUncheckedUpdateManyWithoutVersion_groupNestedInput
    pokedex_version_groups?: PokedexVersionGroupUncheckedUpdateManyWithoutVersion_groupNestedInput
  }

  export type VersionGroupCreateManyInput = {
    id: number
    name: string
    generation_id: number
  }

  export type VersionGroupUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VersionGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
  }

  export type VersionGroupRegionCreateInput = {
    id: number
    region: RegionCreateNestedOneWithoutVersion_groupsInput
    version_group: VersionGroupCreateNestedOneWithoutRegionsInput
  }

  export type VersionGroupRegionUncheckedCreateInput = {
    id: number
    version_group_id: number
    region_id: number
  }

  export type VersionGroupRegionUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    region?: RegionUpdateOneRequiredWithoutVersion_groupsNestedInput
    version_group?: VersionGroupUpdateOneRequiredWithoutRegionsNestedInput
  }

  export type VersionGroupRegionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
    region_id?: IntFieldUpdateOperationsInput | number
  }

  export type VersionGroupRegionCreateManyInput = {
    id: number
    version_group_id: number
    region_id: number
  }

  export type VersionGroupRegionUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type VersionGroupRegionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
    region_id?: IntFieldUpdateOperationsInput | number
  }

  export type VersionCreateInput = {
    id: number
    name: string
    versionGroup: VersionGroupCreateNestedOneWithoutVersionsInput
    encounters?: EncounterCreateNestedManyWithoutVersionInput
    encounterRates?: LocationAreaEncounterRateCreateNestedManyWithoutVersionInput
  }

  export type VersionUncheckedCreateInput = {
    id: number
    name: string
    version_group_id: number
    encounters?: EncounterUncheckedCreateNestedManyWithoutVersionInput
    encounterRates?: LocationAreaEncounterRateUncheckedCreateNestedManyWithoutVersionInput
  }

  export type VersionUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    versionGroup?: VersionGroupUpdateOneRequiredWithoutVersionsNestedInput
    encounters?: EncounterUpdateManyWithoutVersionNestedInput
    encounterRates?: LocationAreaEncounterRateUpdateManyWithoutVersionNestedInput
  }

  export type VersionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    version_group_id?: IntFieldUpdateOperationsInput | number
    encounters?: EncounterUncheckedUpdateManyWithoutVersionNestedInput
    encounterRates?: LocationAreaEncounterRateUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type VersionCreateManyInput = {
    id: number
    name: string
    version_group_id: number
  }

  export type VersionUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VersionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    version_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type LocationCreateInput = {
    id: number
    name: string
    region: RegionCreateNestedOneWithoutLocationsInput
    areas?: LocationAreaCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id: number
    name: string
    region_id: number
    areas?: LocationAreaUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutLocationsNestedInput
    areas?: LocationAreaUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
    areas?: LocationAreaUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id: number
    name: string
    region_id: number
  }

  export type LocationUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
  }

  export type LocationAreaCreateInput = {
    id: number
    name: string
    location: LocationCreateNestedOneWithoutAreasInput
    encounters?: EncounterCreateNestedManyWithoutLocation_areaInput
    encounterRates?: LocationAreaEncounterRateCreateNestedManyWithoutLocation_areaInput
  }

  export type LocationAreaUncheckedCreateInput = {
    id: number
    name: string
    location_id: number
    encounters?: EncounterUncheckedCreateNestedManyWithoutLocation_areaInput
    encounterRates?: LocationAreaEncounterRateUncheckedCreateNestedManyWithoutLocation_areaInput
  }

  export type LocationAreaUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: LocationUpdateOneRequiredWithoutAreasNestedInput
    encounters?: EncounterUpdateManyWithoutLocation_areaNestedInput
    encounterRates?: LocationAreaEncounterRateUpdateManyWithoutLocation_areaNestedInput
  }

  export type LocationAreaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location_id?: IntFieldUpdateOperationsInput | number
    encounters?: EncounterUncheckedUpdateManyWithoutLocation_areaNestedInput
    encounterRates?: LocationAreaEncounterRateUncheckedUpdateManyWithoutLocation_areaNestedInput
  }

  export type LocationAreaCreateManyInput = {
    id: number
    name: string
    location_id: number
  }

  export type LocationAreaUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LocationAreaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location_id?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterMethodCreateInput = {
    id: number
    name: string
    slots?: EncounterSlotCreateNestedManyWithoutMethodInput
    location_area_encounter_rates?: LocationAreaEncounterRateCreateNestedManyWithoutEncounter_methodInput
  }

  export type EncounterMethodUncheckedCreateInput = {
    id: number
    name: string
    slots?: EncounterSlotUncheckedCreateNestedManyWithoutMethodInput
    location_area_encounter_rates?: LocationAreaEncounterRateUncheckedCreateNestedManyWithoutEncounter_methodInput
  }

  export type EncounterMethodUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slots?: EncounterSlotUpdateManyWithoutMethodNestedInput
    location_area_encounter_rates?: LocationAreaEncounterRateUpdateManyWithoutEncounter_methodNestedInput
  }

  export type EncounterMethodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slots?: EncounterSlotUncheckedUpdateManyWithoutMethodNestedInput
    location_area_encounter_rates?: LocationAreaEncounterRateUncheckedUpdateManyWithoutEncounter_methodNestedInput
  }

  export type EncounterMethodCreateManyInput = {
    id: number
    name: string
  }

  export type EncounterMethodUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EncounterMethodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EncounterSlotCreateInput = {
    id: number
    slot: number
    rarity: number
    version_group: VersionGroupCreateNestedOneWithoutSlotsInput
    method: EncounterMethodCreateNestedOneWithoutSlotsInput
    encounters?: EncounterCreateNestedManyWithoutSlotInput
  }

  export type EncounterSlotUncheckedCreateInput = {
    id: number
    version_group_id: number
    encounter_method_id: number
    slot: number
    rarity: number
    encounters?: EncounterUncheckedCreateNestedManyWithoutSlotInput
  }

  export type EncounterSlotUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slot?: IntFieldUpdateOperationsInput | number
    rarity?: IntFieldUpdateOperationsInput | number
    version_group?: VersionGroupUpdateOneRequiredWithoutSlotsNestedInput
    method?: EncounterMethodUpdateOneRequiredWithoutSlotsNestedInput
    encounters?: EncounterUpdateManyWithoutSlotNestedInput
  }

  export type EncounterSlotUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
    encounter_method_id?: IntFieldUpdateOperationsInput | number
    slot?: IntFieldUpdateOperationsInput | number
    rarity?: IntFieldUpdateOperationsInput | number
    encounters?: EncounterUncheckedUpdateManyWithoutSlotNestedInput
  }

  export type EncounterSlotCreateManyInput = {
    id: number
    version_group_id: number
    encounter_method_id: number
    slot: number
    rarity: number
  }

  export type EncounterSlotUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    slot?: IntFieldUpdateOperationsInput | number
    rarity?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterSlotUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
    encounter_method_id?: IntFieldUpdateOperationsInput | number
    slot?: IntFieldUpdateOperationsInput | number
    rarity?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterCreateInput = {
    id: number
    min_level: number
    max_level: number
    version: VersionCreateNestedOneWithoutEncountersInput
    pokemon: PokemonCreateNestedOneWithoutEncountersInput
    location_area: LocationAreaCreateNestedOneWithoutEncountersInput
    slot: EncounterSlotCreateNestedOneWithoutEncountersInput
    conditions?: EncounterConditionValueMapCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateInput = {
    id: number
    version_id: number
    pokemon_id: number
    location_area_id: number
    encounter_slot_id: number
    min_level: number
    max_level: number
    conditions?: EncounterConditionValueMapUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    min_level?: IntFieldUpdateOperationsInput | number
    max_level?: IntFieldUpdateOperationsInput | number
    version?: VersionUpdateOneRequiredWithoutEncountersNestedInput
    pokemon?: PokemonUpdateOneRequiredWithoutEncountersNestedInput
    location_area?: LocationAreaUpdateOneRequiredWithoutEncountersNestedInput
    slot?: EncounterSlotUpdateOneRequiredWithoutEncountersNestedInput
    conditions?: EncounterConditionValueMapUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    location_area_id?: IntFieldUpdateOperationsInput | number
    encounter_slot_id?: IntFieldUpdateOperationsInput | number
    min_level?: IntFieldUpdateOperationsInput | number
    max_level?: IntFieldUpdateOperationsInput | number
    conditions?: EncounterConditionValueMapUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterCreateManyInput = {
    id: number
    version_id: number
    pokemon_id: number
    location_area_id: number
    encounter_slot_id: number
    min_level: number
    max_level: number
  }

  export type EncounterUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    min_level?: IntFieldUpdateOperationsInput | number
    max_level?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    location_area_id?: IntFieldUpdateOperationsInput | number
    encounter_slot_id?: IntFieldUpdateOperationsInput | number
    min_level?: IntFieldUpdateOperationsInput | number
    max_level?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterConditionCreateInput = {
    id: number
    name: string
    values?: EncounterConditionValueCreateNestedManyWithoutConditionInput
  }

  export type EncounterConditionUncheckedCreateInput = {
    id: number
    name: string
    values?: EncounterConditionValueUncheckedCreateNestedManyWithoutConditionInput
  }

  export type EncounterConditionUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    values?: EncounterConditionValueUpdateManyWithoutConditionNestedInput
  }

  export type EncounterConditionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    values?: EncounterConditionValueUncheckedUpdateManyWithoutConditionNestedInput
  }

  export type EncounterConditionCreateManyInput = {
    id: number
    name: string
  }

  export type EncounterConditionUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EncounterConditionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EncounterConditionValueCreateInput = {
    id: number
    name: string
    is_default: boolean
    condition: EncounterConditionCreateNestedOneWithoutValuesInput
    maps?: EncounterConditionValueMapCreateNestedManyWithoutValueInput
  }

  export type EncounterConditionValueUncheckedCreateInput = {
    id: number
    encounter_condition_id: number
    name: string
    is_default: boolean
    maps?: EncounterConditionValueMapUncheckedCreateNestedManyWithoutValueInput
  }

  export type EncounterConditionValueUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    condition?: EncounterConditionUpdateOneRequiredWithoutValuesNestedInput
    maps?: EncounterConditionValueMapUpdateManyWithoutValueNestedInput
  }

  export type EncounterConditionValueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounter_condition_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    maps?: EncounterConditionValueMapUncheckedUpdateManyWithoutValueNestedInput
  }

  export type EncounterConditionValueCreateManyInput = {
    id: number
    encounter_condition_id: number
    name: string
    is_default: boolean
  }

  export type EncounterConditionValueUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EncounterConditionValueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounter_condition_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EncounterConditionValueMapCreateInput = {
    id: number
    encounter: EncounterCreateNestedOneWithoutConditionsInput
    value: EncounterConditionValueCreateNestedOneWithoutMapsInput
  }

  export type EncounterConditionValueMapUncheckedCreateInput = {
    id: number
    encounter_id: number
    encounter_condition_value_id: number
  }

  export type EncounterConditionValueMapUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounter?: EncounterUpdateOneRequiredWithoutConditionsNestedInput
    value?: EncounterConditionValueUpdateOneRequiredWithoutMapsNestedInput
  }

  export type EncounterConditionValueMapUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounter_id?: IntFieldUpdateOperationsInput | number
    encounter_condition_value_id?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterConditionValueMapCreateManyInput = {
    id: number
    encounter_id: number
    encounter_condition_value_id: number
  }

  export type EncounterConditionValueMapUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterConditionValueMapUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounter_id?: IntFieldUpdateOperationsInput | number
    encounter_condition_value_id?: IntFieldUpdateOperationsInput | number
  }

  export type LocationAreaEncounterRateCreateInput = {
    id: number
    rate: number
    location_area: LocationAreaCreateNestedOneWithoutEncounterRatesInput
    encounter_method: EncounterMethodCreateNestedOneWithoutLocation_area_encounter_ratesInput
    version: VersionCreateNestedOneWithoutEncounterRatesInput
  }

  export type LocationAreaEncounterRateUncheckedCreateInput = {
    id: number
    location_area_id: number
    encounter_method_id: number
    version_id: number
    rate: number
  }

  export type LocationAreaEncounterRateUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
    location_area?: LocationAreaUpdateOneRequiredWithoutEncounterRatesNestedInput
    encounter_method?: EncounterMethodUpdateOneRequiredWithoutLocation_area_encounter_ratesNestedInput
    version?: VersionUpdateOneRequiredWithoutEncounterRatesNestedInput
  }

  export type LocationAreaEncounterRateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    location_area_id?: IntFieldUpdateOperationsInput | number
    encounter_method_id?: IntFieldUpdateOperationsInput | number
    version_id?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
  }

  export type LocationAreaEncounterRateCreateManyInput = {
    id: number
    location_area_id: number
    encounter_method_id: number
    version_id: number
    rate: number
  }

  export type LocationAreaEncounterRateUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
  }

  export type LocationAreaEncounterRateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    location_area_id?: IntFieldUpdateOperationsInput | number
    encounter_method_id?: IntFieldUpdateOperationsInput | number
    version_id?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
  }

  export type MoveDamageClassCreateInput = {
    id: number
    name: string
    moves?: MoveCreateNestedManyWithoutDamage_classInput
  }

  export type MoveDamageClassUncheckedCreateInput = {
    id: number
    name: string
    moves?: MoveUncheckedCreateNestedManyWithoutDamage_classInput
  }

  export type MoveDamageClassUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    moves?: MoveUpdateManyWithoutDamage_classNestedInput
  }

  export type MoveDamageClassUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    moves?: MoveUncheckedUpdateManyWithoutDamage_classNestedInput
  }

  export type MoveDamageClassCreateManyInput = {
    id: number
    name: string
  }

  export type MoveDamageClassUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MoveDamageClassUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MoveEffectCreateInput = {
    id: number
    description: string
    moves?: MoveCreateNestedManyWithoutEffectInput
  }

  export type MoveEffectUncheckedCreateInput = {
    id: number
    description: string
    moves?: MoveUncheckedCreateNestedManyWithoutEffectInput
  }

  export type MoveEffectUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    moves?: MoveUpdateManyWithoutEffectNestedInput
  }

  export type MoveEffectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    moves?: MoveUncheckedUpdateManyWithoutEffectNestedInput
  }

  export type MoveEffectCreateManyInput = {
    id: number
    description: string
  }

  export type MoveEffectUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type MoveEffectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type MoveMethodCreateInput = {
    id: number
    name: string
    moves?: PokemonMoveCreateNestedManyWithoutMethodInput
  }

  export type MoveMethodUncheckedCreateInput = {
    id: number
    name: string
    moves?: PokemonMoveUncheckedCreateNestedManyWithoutMethodInput
  }

  export type MoveMethodUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    moves?: PokemonMoveUpdateManyWithoutMethodNestedInput
  }

  export type MoveMethodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    moves?: PokemonMoveUncheckedUpdateManyWithoutMethodNestedInput
  }

  export type MoveMethodCreateManyInput = {
    id: number
    name: string
  }

  export type MoveMethodUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MoveMethodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MoveCreateInput = {
    id: number
    name: string
    generation_id: number
    pp: number
    accuracy?: number | null
    priority: number
    type: TypeCreateNestedOneWithoutMoveInput
    damage_class: MoveDamageClassCreateNestedOneWithoutMovesInput
    effect: MoveEffectCreateNestedOneWithoutMovesInput
    pokemon_moves?: PokemonMoveCreateNestedManyWithoutMoveInput
  }

  export type MoveUncheckedCreateInput = {
    id: number
    name: string
    generation_id: number
    type_id: number
    pp: number
    accuracy?: number | null
    priority: number
    move_damage_class_id: number
    move_effect_id: number
    pokemon_moves?: PokemonMoveUncheckedCreateNestedManyWithoutMoveInput
  }

  export type MoveUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    accuracy?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    type?: TypeUpdateOneRequiredWithoutMoveNestedInput
    damage_class?: MoveDamageClassUpdateOneRequiredWithoutMovesNestedInput
    effect?: MoveEffectUpdateOneRequiredWithoutMovesNestedInput
    pokemon_moves?: PokemonMoveUpdateManyWithoutMoveNestedInput
  }

  export type MoveUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    accuracy?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    move_damage_class_id?: IntFieldUpdateOperationsInput | number
    move_effect_id?: IntFieldUpdateOperationsInput | number
    pokemon_moves?: PokemonMoveUncheckedUpdateManyWithoutMoveNestedInput
  }

  export type MoveCreateManyInput = {
    id: number
    name: string
    generation_id: number
    type_id: number
    pp: number
    accuracy?: number | null
    priority: number
    move_damage_class_id: number
    move_effect_id: number
  }

  export type MoveUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    accuracy?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type MoveUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    accuracy?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    move_damage_class_id?: IntFieldUpdateOperationsInput | number
    move_effect_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonMoveCreateInput = {
    id: number
    level: number
    version_group: VersionGroupCreateNestedOneWithoutMovesInput
    method: MoveMethodCreateNestedOneWithoutMovesInput
    move: MoveCreateNestedOneWithoutPokemon_movesInput
    pokemon: PokemonCreateNestedOneWithoutMoveInput
  }

  export type PokemonMoveUncheckedCreateInput = {
    id: number
    version_group_id: number
    move_method_id: number
    move_id: number
    pokemon_id: number
    level: number
  }

  export type PokemonMoveUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    version_group?: VersionGroupUpdateOneRequiredWithoutMovesNestedInput
    method?: MoveMethodUpdateOneRequiredWithoutMovesNestedInput
    move?: MoveUpdateOneRequiredWithoutPokemon_movesNestedInput
    pokemon?: PokemonUpdateOneRequiredWithoutMoveNestedInput
  }

  export type PokemonMoveUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
    move_method_id?: IntFieldUpdateOperationsInput | number
    move_id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonMoveCreateManyInput = {
    id: number
    version_group_id: number
    move_method_id: number
    move_id: number
    pokemon_id: number
    level: number
  }

  export type PokemonMoveUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonMoveUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
    move_method_id?: IntFieldUpdateOperationsInput | number
    move_id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type PokedexCreateInput = {
    id: number
    name: string
    region: RegionCreateNestedOneWithoutPokedexInput
    pokedex_version_groups?: PokedexVersionGroupCreateNestedManyWithoutPokedexInput
    pokemon_dex_numbers?: PokemonDexNumberCreateNestedManyWithoutPokedexInput
  }

  export type PokedexUncheckedCreateInput = {
    id: number
    name: string
    region_id: number
    pokedex_version_groups?: PokedexVersionGroupUncheckedCreateNestedManyWithoutPokedexInput
    pokemon_dex_numbers?: PokemonDexNumberUncheckedCreateNestedManyWithoutPokedexInput
  }

  export type PokedexUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutPokedexNestedInput
    pokedex_version_groups?: PokedexVersionGroupUpdateManyWithoutPokedexNestedInput
    pokemon_dex_numbers?: PokemonDexNumberUpdateManyWithoutPokedexNestedInput
  }

  export type PokedexUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
    pokedex_version_groups?: PokedexVersionGroupUncheckedUpdateManyWithoutPokedexNestedInput
    pokemon_dex_numbers?: PokemonDexNumberUncheckedUpdateManyWithoutPokedexNestedInput
  }

  export type PokedexCreateManyInput = {
    id: number
    name: string
    region_id: number
  }

  export type PokedexUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PokedexUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokedexVersionGroupCreateInput = {
    id: number
    version_group: VersionGroupCreateNestedOneWithoutPokedex_version_groupsInput
    pokedex: PokedexCreateNestedOneWithoutPokedex_version_groupsInput
  }

  export type PokedexVersionGroupUncheckedCreateInput = {
    id: number
    version_group_id: number
    pokedex_id: number
  }

  export type PokedexVersionGroupUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group?: VersionGroupUpdateOneRequiredWithoutPokedex_version_groupsNestedInput
    pokedex?: PokedexUpdateOneRequiredWithoutPokedex_version_groupsNestedInput
  }

  export type PokedexVersionGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
    pokedex_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokedexVersionGroupCreateManyInput = {
    id: number
    version_group_id: number
    pokedex_id: number
  }

  export type PokedexVersionGroupUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type PokedexVersionGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
    pokedex_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonDexNumberCreateInput = {
    id: number
    pokedex_number: number
    pokemon: PokemonCreateNestedOneWithoutDex_numbersInput
    pokedex: PokedexCreateNestedOneWithoutPokemon_dex_numbersInput
  }

  export type PokemonDexNumberUncheckedCreateInput = {
    id: number
    pokemon_id: number
    pokedex_id: number
    pokedex_number: number
  }

  export type PokemonDexNumberUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokedex_number?: IntFieldUpdateOperationsInput | number
    pokemon?: PokemonUpdateOneRequiredWithoutDex_numbersNestedInput
    pokedex?: PokedexUpdateOneRequiredWithoutPokemon_dex_numbersNestedInput
  }

  export type PokemonDexNumberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    pokedex_id?: IntFieldUpdateOperationsInput | number
    pokedex_number?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonDexNumberCreateManyInput = {
    id: number
    pokemon_id: number
    pokedex_id: number
    pokedex_number: number
  }

  export type PokemonDexNumberUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokedex_number?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonDexNumberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    pokedex_id?: IntFieldUpdateOperationsInput | number
    pokedex_number?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type PokemonAbilityListRelationFilter = {
    every?: PokemonAbilityWhereInput
    some?: PokemonAbilityWhereInput
    none?: PokemonAbilityWhereInput
  }

  export type PokemonNatureListRelationFilter = {
    every?: PokemonNatureWhereInput
    some?: PokemonNatureWhereInput
    none?: PokemonNatureWhereInput
  }

  export type PokemonStatListRelationFilter = {
    every?: PokemonStatWhereInput
    some?: PokemonStatWhereInput
    none?: PokemonStatWhereInput
  }

  export type PokemonTypeListRelationFilter = {
    every?: PokemonTypeWhereInput
    some?: PokemonTypeWhereInput
    none?: PokemonTypeWhereInput
  }

  export type PokemonEggGroupListRelationFilter = {
    every?: PokemonEggGroupWhereInput
    some?: PokemonEggGroupWhereInput
    none?: PokemonEggGroupWhereInput
  }

  export type EncounterListRelationFilter = {
    every?: EncounterWhereInput
    some?: EncounterWhereInput
    none?: EncounterWhereInput
  }

  export type PokemonDexNumberListRelationFilter = {
    every?: PokemonDexNumberWhereInput
    some?: PokemonDexNumberWhereInput
    none?: PokemonDexNumberWhereInput
  }

  export type PokemonMoveListRelationFilter = {
    every?: PokemonMoveWhereInput
    some?: PokemonMoveWhereInput
    none?: PokemonMoveWhereInput
  }

  export type PokemonAbilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PokemonNatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PokemonStatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PokemonTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PokemonEggGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PokemonDexNumberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PokemonMoveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PokemonCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PokemonAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PokemonMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PokemonMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PokemonSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AbilityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type AbilityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AbilityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type AbilityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type AbilitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PokemonScalarRelationFilter = {
    is?: PokemonWhereInput
    isNot?: PokemonWhereInput
  }

  export type AbilityScalarRelationFilter = {
    is?: AbilityWhereInput
    isNot?: AbilityWhereInput
  }

  export type PokemonAbilityCountOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    ability_id?: SortOrder
    is_hidden?: SortOrder
  }

  export type PokemonAbilityAvgOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    ability_id?: SortOrder
  }

  export type PokemonAbilityMaxOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    ability_id?: SortOrder
    is_hidden?: SortOrder
  }

  export type PokemonAbilityMinOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    ability_id?: SortOrder
    is_hidden?: SortOrder
  }

  export type PokemonAbilitySumOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    ability_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StatScalarRelationFilter = {
    is?: StatWhereInput
    isNot?: StatWhereInput
  }

  export type NatureCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    increased_stat_id?: SortOrder
    decreased_stat_id?: SortOrder
  }

  export type NatureAvgOrderByAggregateInput = {
    id?: SortOrder
    increased_stat_id?: SortOrder
    decreased_stat_id?: SortOrder
  }

  export type NatureMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    increased_stat_id?: SortOrder
    decreased_stat_id?: SortOrder
  }

  export type NatureMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    increased_stat_id?: SortOrder
    decreased_stat_id?: SortOrder
  }

  export type NatureSumOrderByAggregateInput = {
    id?: SortOrder
    increased_stat_id?: SortOrder
    decreased_stat_id?: SortOrder
  }

  export type NatureScalarRelationFilter = {
    is?: NatureWhereInput
    isNot?: NatureWhereInput
  }

  export type PokemonNatureCountOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    nature_id?: SortOrder
  }

  export type PokemonNatureAvgOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    nature_id?: SortOrder
  }

  export type PokemonNatureMaxOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    nature_id?: SortOrder
  }

  export type PokemonNatureMinOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    nature_id?: SortOrder
  }

  export type PokemonNatureSumOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    nature_id?: SortOrder
  }

  export type NatureListRelationFilter = {
    every?: NatureWhereInput
    some?: NatureWhereInput
    none?: NatureWhereInput
  }

  export type NatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StatCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type StatAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StatMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type StatMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type StatSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PokemonStatCountOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    stat_id?: SortOrder
    base_stat?: SortOrder
  }

  export type PokemonStatAvgOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    stat_id?: SortOrder
    base_stat?: SortOrder
  }

  export type PokemonStatMaxOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    stat_id?: SortOrder
    base_stat?: SortOrder
  }

  export type PokemonStatMinOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    stat_id?: SortOrder
    base_stat?: SortOrder
  }

  export type PokemonStatSumOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    stat_id?: SortOrder
    base_stat?: SortOrder
  }

  export type GenerationScalarRelationFilter = {
    is?: GenerationWhereInput
    isNot?: GenerationWhereInput
  }

  export type TypeEffectivenessListRelationFilter = {
    every?: TypeEffectivenessWhereInput
    some?: TypeEffectivenessWhereInput
    none?: TypeEffectivenessWhereInput
  }

  export type MoveListRelationFilter = {
    every?: MoveWhereInput
    some?: MoveWhereInput
    none?: MoveWhereInput
  }

  export type TypeEffectivenessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MoveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    generation_id?: SortOrder
  }

  export type TypeAvgOrderByAggregateInput = {
    id?: SortOrder
    generation_id?: SortOrder
  }

  export type TypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    generation_id?: SortOrder
  }

  export type TypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    generation_id?: SortOrder
  }

  export type TypeSumOrderByAggregateInput = {
    id?: SortOrder
    generation_id?: SortOrder
  }

  export type TypeScalarRelationFilter = {
    is?: TypeWhereInput
    isNot?: TypeWhereInput
  }

  export type TypeEffectivenessCountOrderByAggregateInput = {
    id?: SortOrder
    type_id?: SortOrder
    target_type_id?: SortOrder
    damage_factor?: SortOrder
  }

  export type TypeEffectivenessAvgOrderByAggregateInput = {
    id?: SortOrder
    type_id?: SortOrder
    target_type_id?: SortOrder
    damage_factor?: SortOrder
  }

  export type TypeEffectivenessMaxOrderByAggregateInput = {
    id?: SortOrder
    type_id?: SortOrder
    target_type_id?: SortOrder
    damage_factor?: SortOrder
  }

  export type TypeEffectivenessMinOrderByAggregateInput = {
    id?: SortOrder
    type_id?: SortOrder
    target_type_id?: SortOrder
    damage_factor?: SortOrder
  }

  export type TypeEffectivenessSumOrderByAggregateInput = {
    id?: SortOrder
    type_id?: SortOrder
    target_type_id?: SortOrder
    damage_factor?: SortOrder
  }

  export type PokemonTypeCountOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    type_id?: SortOrder
  }

  export type PokemonTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    type_id?: SortOrder
  }

  export type PokemonTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    type_id?: SortOrder
  }

  export type PokemonTypeMinOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    type_id?: SortOrder
  }

  export type PokemonTypeSumOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    type_id?: SortOrder
  }

  export type EggGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EggGroupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EggGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EggGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EggGroupSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EggGroupScalarRelationFilter = {
    is?: EggGroupWhereInput
    isNot?: EggGroupWhereInput
  }

  export type PokemonEggGroupCountOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    egg_group_id?: SortOrder
  }

  export type PokemonEggGroupAvgOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    egg_group_id?: SortOrder
  }

  export type PokemonEggGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    egg_group_id?: SortOrder
  }

  export type PokemonEggGroupMinOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    egg_group_id?: SortOrder
  }

  export type PokemonEggGroupSumOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    egg_group_id?: SortOrder
  }

  export type LocationListRelationFilter = {
    every?: LocationWhereInput
    some?: LocationWhereInput
    none?: LocationWhereInput
  }

  export type VersionGroupRegionListRelationFilter = {
    every?: VersionGroupRegionWhereInput
    some?: VersionGroupRegionWhereInput
    none?: VersionGroupRegionWhereInput
  }

  export type GenerationNullableScalarRelationFilter = {
    is?: GenerationWhereInput | null
    isNot?: GenerationWhereInput | null
  }

  export type PokedexListRelationFilter = {
    every?: PokedexWhereInput
    some?: PokedexWhereInput
    none?: PokedexWhereInput
  }

  export type LocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VersionGroupRegionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PokedexOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RegionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RegionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RegionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RegionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RegionScalarRelationFilter = {
    is?: RegionWhereInput
    isNot?: RegionWhereInput
  }

  export type TypeListRelationFilter = {
    every?: TypeWhereInput
    some?: TypeWhereInput
    none?: TypeWhereInput
  }

  export type VersionGroupListRelationFilter = {
    every?: VersionGroupWhereInput
    some?: VersionGroupWhereInput
    none?: VersionGroupWhereInput
  }

  export type TypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VersionGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GenerationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
  }

  export type GenerationAvgOrderByAggregateInput = {
    id?: SortOrder
    region_id?: SortOrder
  }

  export type GenerationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
  }

  export type GenerationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
  }

  export type GenerationSumOrderByAggregateInput = {
    id?: SortOrder
    region_id?: SortOrder
  }

  export type VersionListRelationFilter = {
    every?: VersionWhereInput
    some?: VersionWhereInput
    none?: VersionWhereInput
  }

  export type EncounterSlotListRelationFilter = {
    every?: EncounterSlotWhereInput
    some?: EncounterSlotWhereInput
    none?: EncounterSlotWhereInput
  }

  export type PokedexVersionGroupListRelationFilter = {
    every?: PokedexVersionGroupWhereInput
    some?: PokedexVersionGroupWhereInput
    none?: PokedexVersionGroupWhereInput
  }

  export type VersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PokedexVersionGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VersionGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    generation_id?: SortOrder
  }

  export type VersionGroupAvgOrderByAggregateInput = {
    id?: SortOrder
    generation_id?: SortOrder
  }

  export type VersionGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    generation_id?: SortOrder
  }

  export type VersionGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    generation_id?: SortOrder
  }

  export type VersionGroupSumOrderByAggregateInput = {
    id?: SortOrder
    generation_id?: SortOrder
  }

  export type VersionGroupScalarRelationFilter = {
    is?: VersionGroupWhereInput
    isNot?: VersionGroupWhereInput
  }

  export type VersionGroupRegionCountOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    region_id?: SortOrder
  }

  export type VersionGroupRegionAvgOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    region_id?: SortOrder
  }

  export type VersionGroupRegionMaxOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    region_id?: SortOrder
  }

  export type VersionGroupRegionMinOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    region_id?: SortOrder
  }

  export type VersionGroupRegionSumOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    region_id?: SortOrder
  }

  export type LocationAreaEncounterRateListRelationFilter = {
    every?: LocationAreaEncounterRateWhereInput
    some?: LocationAreaEncounterRateWhereInput
    none?: LocationAreaEncounterRateWhereInput
  }

  export type LocationAreaEncounterRateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VersionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version_group_id?: SortOrder
  }

  export type VersionAvgOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
  }

  export type VersionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version_group_id?: SortOrder
  }

  export type VersionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version_group_id?: SortOrder
  }

  export type VersionSumOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
  }

  export type LocationAreaListRelationFilter = {
    every?: LocationAreaWhereInput
    some?: LocationAreaWhereInput
    none?: LocationAreaWhereInput
  }

  export type LocationAreaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    id?: SortOrder
    region_id?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    id?: SortOrder
    region_id?: SortOrder
  }

  export type LocationScalarRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type LocationAreaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location_id?: SortOrder
  }

  export type LocationAreaAvgOrderByAggregateInput = {
    id?: SortOrder
    location_id?: SortOrder
  }

  export type LocationAreaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location_id?: SortOrder
  }

  export type LocationAreaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location_id?: SortOrder
  }

  export type LocationAreaSumOrderByAggregateInput = {
    id?: SortOrder
    location_id?: SortOrder
  }

  export type EncounterMethodCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EncounterMethodAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EncounterMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EncounterMethodMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EncounterMethodSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EncounterMethodScalarRelationFilter = {
    is?: EncounterMethodWhereInput
    isNot?: EncounterMethodWhereInput
  }

  export type EncounterSlotCountOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    encounter_method_id?: SortOrder
    slot?: SortOrder
    rarity?: SortOrder
  }

  export type EncounterSlotAvgOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    encounter_method_id?: SortOrder
    slot?: SortOrder
    rarity?: SortOrder
  }

  export type EncounterSlotMaxOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    encounter_method_id?: SortOrder
    slot?: SortOrder
    rarity?: SortOrder
  }

  export type EncounterSlotMinOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    encounter_method_id?: SortOrder
    slot?: SortOrder
    rarity?: SortOrder
  }

  export type EncounterSlotSumOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    encounter_method_id?: SortOrder
    slot?: SortOrder
    rarity?: SortOrder
  }

  export type VersionScalarRelationFilter = {
    is?: VersionWhereInput
    isNot?: VersionWhereInput
  }

  export type LocationAreaScalarRelationFilter = {
    is?: LocationAreaWhereInput
    isNot?: LocationAreaWhereInput
  }

  export type EncounterSlotScalarRelationFilter = {
    is?: EncounterSlotWhereInput
    isNot?: EncounterSlotWhereInput
  }

  export type EncounterConditionValueMapListRelationFilter = {
    every?: EncounterConditionValueMapWhereInput
    some?: EncounterConditionValueMapWhereInput
    none?: EncounterConditionValueMapWhereInput
  }

  export type EncounterConditionValueMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterCountOrderByAggregateInput = {
    id?: SortOrder
    version_id?: SortOrder
    pokemon_id?: SortOrder
    location_area_id?: SortOrder
    encounter_slot_id?: SortOrder
    min_level?: SortOrder
    max_level?: SortOrder
  }

  export type EncounterAvgOrderByAggregateInput = {
    id?: SortOrder
    version_id?: SortOrder
    pokemon_id?: SortOrder
    location_area_id?: SortOrder
    encounter_slot_id?: SortOrder
    min_level?: SortOrder
    max_level?: SortOrder
  }

  export type EncounterMaxOrderByAggregateInput = {
    id?: SortOrder
    version_id?: SortOrder
    pokemon_id?: SortOrder
    location_area_id?: SortOrder
    encounter_slot_id?: SortOrder
    min_level?: SortOrder
    max_level?: SortOrder
  }

  export type EncounterMinOrderByAggregateInput = {
    id?: SortOrder
    version_id?: SortOrder
    pokemon_id?: SortOrder
    location_area_id?: SortOrder
    encounter_slot_id?: SortOrder
    min_level?: SortOrder
    max_level?: SortOrder
  }

  export type EncounterSumOrderByAggregateInput = {
    id?: SortOrder
    version_id?: SortOrder
    pokemon_id?: SortOrder
    location_area_id?: SortOrder
    encounter_slot_id?: SortOrder
    min_level?: SortOrder
    max_level?: SortOrder
  }

  export type EncounterConditionValueListRelationFilter = {
    every?: EncounterConditionValueWhereInput
    some?: EncounterConditionValueWhereInput
    none?: EncounterConditionValueWhereInput
  }

  export type EncounterConditionValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncounterConditionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EncounterConditionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EncounterConditionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EncounterConditionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EncounterConditionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EncounterConditionScalarRelationFilter = {
    is?: EncounterConditionWhereInput
    isNot?: EncounterConditionWhereInput
  }

  export type EncounterConditionValueCountOrderByAggregateInput = {
    id?: SortOrder
    encounter_condition_id?: SortOrder
    name?: SortOrder
    is_default?: SortOrder
  }

  export type EncounterConditionValueAvgOrderByAggregateInput = {
    id?: SortOrder
    encounter_condition_id?: SortOrder
  }

  export type EncounterConditionValueMaxOrderByAggregateInput = {
    id?: SortOrder
    encounter_condition_id?: SortOrder
    name?: SortOrder
    is_default?: SortOrder
  }

  export type EncounterConditionValueMinOrderByAggregateInput = {
    id?: SortOrder
    encounter_condition_id?: SortOrder
    name?: SortOrder
    is_default?: SortOrder
  }

  export type EncounterConditionValueSumOrderByAggregateInput = {
    id?: SortOrder
    encounter_condition_id?: SortOrder
  }

  export type EncounterScalarRelationFilter = {
    is?: EncounterWhereInput
    isNot?: EncounterWhereInput
  }

  export type EncounterConditionValueScalarRelationFilter = {
    is?: EncounterConditionValueWhereInput
    isNot?: EncounterConditionValueWhereInput
  }

  export type EncounterConditionValueMapCountOrderByAggregateInput = {
    id?: SortOrder
    encounter_id?: SortOrder
    encounter_condition_value_id?: SortOrder
  }

  export type EncounterConditionValueMapAvgOrderByAggregateInput = {
    id?: SortOrder
    encounter_id?: SortOrder
    encounter_condition_value_id?: SortOrder
  }

  export type EncounterConditionValueMapMaxOrderByAggregateInput = {
    id?: SortOrder
    encounter_id?: SortOrder
    encounter_condition_value_id?: SortOrder
  }

  export type EncounterConditionValueMapMinOrderByAggregateInput = {
    id?: SortOrder
    encounter_id?: SortOrder
    encounter_condition_value_id?: SortOrder
  }

  export type EncounterConditionValueMapSumOrderByAggregateInput = {
    id?: SortOrder
    encounter_id?: SortOrder
    encounter_condition_value_id?: SortOrder
  }

  export type LocationAreaEncounterRateCountOrderByAggregateInput = {
    id?: SortOrder
    location_area_id?: SortOrder
    encounter_method_id?: SortOrder
    version_id?: SortOrder
    rate?: SortOrder
  }

  export type LocationAreaEncounterRateAvgOrderByAggregateInput = {
    id?: SortOrder
    location_area_id?: SortOrder
    encounter_method_id?: SortOrder
    version_id?: SortOrder
    rate?: SortOrder
  }

  export type LocationAreaEncounterRateMaxOrderByAggregateInput = {
    id?: SortOrder
    location_area_id?: SortOrder
    encounter_method_id?: SortOrder
    version_id?: SortOrder
    rate?: SortOrder
  }

  export type LocationAreaEncounterRateMinOrderByAggregateInput = {
    id?: SortOrder
    location_area_id?: SortOrder
    encounter_method_id?: SortOrder
    version_id?: SortOrder
    rate?: SortOrder
  }

  export type LocationAreaEncounterRateSumOrderByAggregateInput = {
    id?: SortOrder
    location_area_id?: SortOrder
    encounter_method_id?: SortOrder
    version_id?: SortOrder
    rate?: SortOrder
  }

  export type MoveDamageClassCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MoveDamageClassAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MoveDamageClassMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MoveDamageClassMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MoveDamageClassSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MoveEffectCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
  }

  export type MoveEffectAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MoveEffectMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
  }

  export type MoveEffectMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
  }

  export type MoveEffectSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MoveMethodCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MoveMethodAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MoveMethodMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MoveMethodMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MoveMethodSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type MoveDamageClassScalarRelationFilter = {
    is?: MoveDamageClassWhereInput
    isNot?: MoveDamageClassWhereInput
  }

  export type MoveEffectScalarRelationFilter = {
    is?: MoveEffectWhereInput
    isNot?: MoveEffectWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MoveCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    generation_id?: SortOrder
    type_id?: SortOrder
    pp?: SortOrder
    accuracy?: SortOrder
    priority?: SortOrder
    move_damage_class_id?: SortOrder
    move_effect_id?: SortOrder
  }

  export type MoveAvgOrderByAggregateInput = {
    id?: SortOrder
    generation_id?: SortOrder
    type_id?: SortOrder
    pp?: SortOrder
    accuracy?: SortOrder
    priority?: SortOrder
    move_damage_class_id?: SortOrder
    move_effect_id?: SortOrder
  }

  export type MoveMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    generation_id?: SortOrder
    type_id?: SortOrder
    pp?: SortOrder
    accuracy?: SortOrder
    priority?: SortOrder
    move_damage_class_id?: SortOrder
    move_effect_id?: SortOrder
  }

  export type MoveMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    generation_id?: SortOrder
    type_id?: SortOrder
    pp?: SortOrder
    accuracy?: SortOrder
    priority?: SortOrder
    move_damage_class_id?: SortOrder
    move_effect_id?: SortOrder
  }

  export type MoveSumOrderByAggregateInput = {
    id?: SortOrder
    generation_id?: SortOrder
    type_id?: SortOrder
    pp?: SortOrder
    accuracy?: SortOrder
    priority?: SortOrder
    move_damage_class_id?: SortOrder
    move_effect_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type MoveMethodScalarRelationFilter = {
    is?: MoveMethodWhereInput
    isNot?: MoveMethodWhereInput
  }

  export type MoveScalarRelationFilter = {
    is?: MoveWhereInput
    isNot?: MoveWhereInput
  }

  export type PokemonMoveCountOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    move_method_id?: SortOrder
    move_id?: SortOrder
    pokemon_id?: SortOrder
    level?: SortOrder
  }

  export type PokemonMoveAvgOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    move_method_id?: SortOrder
    move_id?: SortOrder
    pokemon_id?: SortOrder
    level?: SortOrder
  }

  export type PokemonMoveMaxOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    move_method_id?: SortOrder
    move_id?: SortOrder
    pokemon_id?: SortOrder
    level?: SortOrder
  }

  export type PokemonMoveMinOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    move_method_id?: SortOrder
    move_id?: SortOrder
    pokemon_id?: SortOrder
    level?: SortOrder
  }

  export type PokemonMoveSumOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    move_method_id?: SortOrder
    move_id?: SortOrder
    pokemon_id?: SortOrder
    level?: SortOrder
  }

  export type PokedexCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
  }

  export type PokedexAvgOrderByAggregateInput = {
    id?: SortOrder
    region_id?: SortOrder
  }

  export type PokedexMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
  }

  export type PokedexMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    region_id?: SortOrder
  }

  export type PokedexSumOrderByAggregateInput = {
    id?: SortOrder
    region_id?: SortOrder
  }

  export type PokedexScalarRelationFilter = {
    is?: PokedexWhereInput
    isNot?: PokedexWhereInput
  }

  export type PokedexVersionGroupCountOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    pokedex_id?: SortOrder
  }

  export type PokedexVersionGroupAvgOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    pokedex_id?: SortOrder
  }

  export type PokedexVersionGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    pokedex_id?: SortOrder
  }

  export type PokedexVersionGroupMinOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    pokedex_id?: SortOrder
  }

  export type PokedexVersionGroupSumOrderByAggregateInput = {
    id?: SortOrder
    version_group_id?: SortOrder
    pokedex_id?: SortOrder
  }

  export type PokemonDexNumberCountOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    pokedex_id?: SortOrder
    pokedex_number?: SortOrder
  }

  export type PokemonDexNumberAvgOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    pokedex_id?: SortOrder
    pokedex_number?: SortOrder
  }

  export type PokemonDexNumberMaxOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    pokedex_id?: SortOrder
    pokedex_number?: SortOrder
  }

  export type PokemonDexNumberMinOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    pokedex_id?: SortOrder
    pokedex_number?: SortOrder
  }

  export type PokemonDexNumberSumOrderByAggregateInput = {
    id?: SortOrder
    pokemon_id?: SortOrder
    pokedex_id?: SortOrder
    pokedex_number?: SortOrder
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PokemonAbilityCreateNestedManyWithoutPokemonInput = {
    create?: XOR<PokemonAbilityCreateWithoutPokemonInput, PokemonAbilityUncheckedCreateWithoutPokemonInput> | PokemonAbilityCreateWithoutPokemonInput[] | PokemonAbilityUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonAbilityCreateOrConnectWithoutPokemonInput | PokemonAbilityCreateOrConnectWithoutPokemonInput[]
    createMany?: PokemonAbilityCreateManyPokemonInputEnvelope
    connect?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
  }

  export type PokemonNatureCreateNestedManyWithoutPokemonInput = {
    create?: XOR<PokemonNatureCreateWithoutPokemonInput, PokemonNatureUncheckedCreateWithoutPokemonInput> | PokemonNatureCreateWithoutPokemonInput[] | PokemonNatureUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonNatureCreateOrConnectWithoutPokemonInput | PokemonNatureCreateOrConnectWithoutPokemonInput[]
    createMany?: PokemonNatureCreateManyPokemonInputEnvelope
    connect?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
  }

  export type PokemonStatCreateNestedManyWithoutPokemonInput = {
    create?: XOR<PokemonStatCreateWithoutPokemonInput, PokemonStatUncheckedCreateWithoutPokemonInput> | PokemonStatCreateWithoutPokemonInput[] | PokemonStatUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonStatCreateOrConnectWithoutPokemonInput | PokemonStatCreateOrConnectWithoutPokemonInput[]
    createMany?: PokemonStatCreateManyPokemonInputEnvelope
    connect?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
  }

  export type PokemonTypeCreateNestedManyWithoutPokemonInput = {
    create?: XOR<PokemonTypeCreateWithoutPokemonInput, PokemonTypeUncheckedCreateWithoutPokemonInput> | PokemonTypeCreateWithoutPokemonInput[] | PokemonTypeUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonTypeCreateOrConnectWithoutPokemonInput | PokemonTypeCreateOrConnectWithoutPokemonInput[]
    createMany?: PokemonTypeCreateManyPokemonInputEnvelope
    connect?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
  }

  export type PokemonEggGroupCreateNestedManyWithoutPokemonInput = {
    create?: XOR<PokemonEggGroupCreateWithoutPokemonInput, PokemonEggGroupUncheckedCreateWithoutPokemonInput> | PokemonEggGroupCreateWithoutPokemonInput[] | PokemonEggGroupUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonEggGroupCreateOrConnectWithoutPokemonInput | PokemonEggGroupCreateOrConnectWithoutPokemonInput[]
    createMany?: PokemonEggGroupCreateManyPokemonInputEnvelope
    connect?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
  }

  export type EncounterCreateNestedManyWithoutPokemonInput = {
    create?: XOR<EncounterCreateWithoutPokemonInput, EncounterUncheckedCreateWithoutPokemonInput> | EncounterCreateWithoutPokemonInput[] | EncounterUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPokemonInput | EncounterCreateOrConnectWithoutPokemonInput[]
    createMany?: EncounterCreateManyPokemonInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type PokemonDexNumberCreateNestedManyWithoutPokemonInput = {
    create?: XOR<PokemonDexNumberCreateWithoutPokemonInput, PokemonDexNumberUncheckedCreateWithoutPokemonInput> | PokemonDexNumberCreateWithoutPokemonInput[] | PokemonDexNumberUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonDexNumberCreateOrConnectWithoutPokemonInput | PokemonDexNumberCreateOrConnectWithoutPokemonInput[]
    createMany?: PokemonDexNumberCreateManyPokemonInputEnvelope
    connect?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
  }

  export type PokemonMoveCreateNestedManyWithoutPokemonInput = {
    create?: XOR<PokemonMoveCreateWithoutPokemonInput, PokemonMoveUncheckedCreateWithoutPokemonInput> | PokemonMoveCreateWithoutPokemonInput[] | PokemonMoveUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonMoveCreateOrConnectWithoutPokemonInput | PokemonMoveCreateOrConnectWithoutPokemonInput[]
    createMany?: PokemonMoveCreateManyPokemonInputEnvelope
    connect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
  }

  export type PokemonAbilityUncheckedCreateNestedManyWithoutPokemonInput = {
    create?: XOR<PokemonAbilityCreateWithoutPokemonInput, PokemonAbilityUncheckedCreateWithoutPokemonInput> | PokemonAbilityCreateWithoutPokemonInput[] | PokemonAbilityUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonAbilityCreateOrConnectWithoutPokemonInput | PokemonAbilityCreateOrConnectWithoutPokemonInput[]
    createMany?: PokemonAbilityCreateManyPokemonInputEnvelope
    connect?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
  }

  export type PokemonNatureUncheckedCreateNestedManyWithoutPokemonInput = {
    create?: XOR<PokemonNatureCreateWithoutPokemonInput, PokemonNatureUncheckedCreateWithoutPokemonInput> | PokemonNatureCreateWithoutPokemonInput[] | PokemonNatureUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonNatureCreateOrConnectWithoutPokemonInput | PokemonNatureCreateOrConnectWithoutPokemonInput[]
    createMany?: PokemonNatureCreateManyPokemonInputEnvelope
    connect?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
  }

  export type PokemonStatUncheckedCreateNestedManyWithoutPokemonInput = {
    create?: XOR<PokemonStatCreateWithoutPokemonInput, PokemonStatUncheckedCreateWithoutPokemonInput> | PokemonStatCreateWithoutPokemonInput[] | PokemonStatUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonStatCreateOrConnectWithoutPokemonInput | PokemonStatCreateOrConnectWithoutPokemonInput[]
    createMany?: PokemonStatCreateManyPokemonInputEnvelope
    connect?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
  }

  export type PokemonTypeUncheckedCreateNestedManyWithoutPokemonInput = {
    create?: XOR<PokemonTypeCreateWithoutPokemonInput, PokemonTypeUncheckedCreateWithoutPokemonInput> | PokemonTypeCreateWithoutPokemonInput[] | PokemonTypeUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonTypeCreateOrConnectWithoutPokemonInput | PokemonTypeCreateOrConnectWithoutPokemonInput[]
    createMany?: PokemonTypeCreateManyPokemonInputEnvelope
    connect?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
  }

  export type PokemonEggGroupUncheckedCreateNestedManyWithoutPokemonInput = {
    create?: XOR<PokemonEggGroupCreateWithoutPokemonInput, PokemonEggGroupUncheckedCreateWithoutPokemonInput> | PokemonEggGroupCreateWithoutPokemonInput[] | PokemonEggGroupUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonEggGroupCreateOrConnectWithoutPokemonInput | PokemonEggGroupCreateOrConnectWithoutPokemonInput[]
    createMany?: PokemonEggGroupCreateManyPokemonInputEnvelope
    connect?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutPokemonInput = {
    create?: XOR<EncounterCreateWithoutPokemonInput, EncounterUncheckedCreateWithoutPokemonInput> | EncounterCreateWithoutPokemonInput[] | EncounterUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPokemonInput | EncounterCreateOrConnectWithoutPokemonInput[]
    createMany?: EncounterCreateManyPokemonInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type PokemonDexNumberUncheckedCreateNestedManyWithoutPokemonInput = {
    create?: XOR<PokemonDexNumberCreateWithoutPokemonInput, PokemonDexNumberUncheckedCreateWithoutPokemonInput> | PokemonDexNumberCreateWithoutPokemonInput[] | PokemonDexNumberUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonDexNumberCreateOrConnectWithoutPokemonInput | PokemonDexNumberCreateOrConnectWithoutPokemonInput[]
    createMany?: PokemonDexNumberCreateManyPokemonInputEnvelope
    connect?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
  }

  export type PokemonMoveUncheckedCreateNestedManyWithoutPokemonInput = {
    create?: XOR<PokemonMoveCreateWithoutPokemonInput, PokemonMoveUncheckedCreateWithoutPokemonInput> | PokemonMoveCreateWithoutPokemonInput[] | PokemonMoveUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonMoveCreateOrConnectWithoutPokemonInput | PokemonMoveCreateOrConnectWithoutPokemonInput[]
    createMany?: PokemonMoveCreateManyPokemonInputEnvelope
    connect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
  }

  export type PokemonAbilityUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<PokemonAbilityCreateWithoutPokemonInput, PokemonAbilityUncheckedCreateWithoutPokemonInput> | PokemonAbilityCreateWithoutPokemonInput[] | PokemonAbilityUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonAbilityCreateOrConnectWithoutPokemonInput | PokemonAbilityCreateOrConnectWithoutPokemonInput[]
    upsert?: PokemonAbilityUpsertWithWhereUniqueWithoutPokemonInput | PokemonAbilityUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: PokemonAbilityCreateManyPokemonInputEnvelope
    set?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
    disconnect?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
    delete?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
    connect?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
    update?: PokemonAbilityUpdateWithWhereUniqueWithoutPokemonInput | PokemonAbilityUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: PokemonAbilityUpdateManyWithWhereWithoutPokemonInput | PokemonAbilityUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: PokemonAbilityScalarWhereInput | PokemonAbilityScalarWhereInput[]
  }

  export type PokemonNatureUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<PokemonNatureCreateWithoutPokemonInput, PokemonNatureUncheckedCreateWithoutPokemonInput> | PokemonNatureCreateWithoutPokemonInput[] | PokemonNatureUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonNatureCreateOrConnectWithoutPokemonInput | PokemonNatureCreateOrConnectWithoutPokemonInput[]
    upsert?: PokemonNatureUpsertWithWhereUniqueWithoutPokemonInput | PokemonNatureUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: PokemonNatureCreateManyPokemonInputEnvelope
    set?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
    disconnect?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
    delete?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
    connect?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
    update?: PokemonNatureUpdateWithWhereUniqueWithoutPokemonInput | PokemonNatureUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: PokemonNatureUpdateManyWithWhereWithoutPokemonInput | PokemonNatureUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: PokemonNatureScalarWhereInput | PokemonNatureScalarWhereInput[]
  }

  export type PokemonStatUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<PokemonStatCreateWithoutPokemonInput, PokemonStatUncheckedCreateWithoutPokemonInput> | PokemonStatCreateWithoutPokemonInput[] | PokemonStatUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonStatCreateOrConnectWithoutPokemonInput | PokemonStatCreateOrConnectWithoutPokemonInput[]
    upsert?: PokemonStatUpsertWithWhereUniqueWithoutPokemonInput | PokemonStatUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: PokemonStatCreateManyPokemonInputEnvelope
    set?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
    disconnect?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
    delete?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
    connect?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
    update?: PokemonStatUpdateWithWhereUniqueWithoutPokemonInput | PokemonStatUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: PokemonStatUpdateManyWithWhereWithoutPokemonInput | PokemonStatUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: PokemonStatScalarWhereInput | PokemonStatScalarWhereInput[]
  }

  export type PokemonTypeUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<PokemonTypeCreateWithoutPokemonInput, PokemonTypeUncheckedCreateWithoutPokemonInput> | PokemonTypeCreateWithoutPokemonInput[] | PokemonTypeUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonTypeCreateOrConnectWithoutPokemonInput | PokemonTypeCreateOrConnectWithoutPokemonInput[]
    upsert?: PokemonTypeUpsertWithWhereUniqueWithoutPokemonInput | PokemonTypeUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: PokemonTypeCreateManyPokemonInputEnvelope
    set?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
    disconnect?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
    delete?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
    connect?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
    update?: PokemonTypeUpdateWithWhereUniqueWithoutPokemonInput | PokemonTypeUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: PokemonTypeUpdateManyWithWhereWithoutPokemonInput | PokemonTypeUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: PokemonTypeScalarWhereInput | PokemonTypeScalarWhereInput[]
  }

  export type PokemonEggGroupUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<PokemonEggGroupCreateWithoutPokemonInput, PokemonEggGroupUncheckedCreateWithoutPokemonInput> | PokemonEggGroupCreateWithoutPokemonInput[] | PokemonEggGroupUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonEggGroupCreateOrConnectWithoutPokemonInput | PokemonEggGroupCreateOrConnectWithoutPokemonInput[]
    upsert?: PokemonEggGroupUpsertWithWhereUniqueWithoutPokemonInput | PokemonEggGroupUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: PokemonEggGroupCreateManyPokemonInputEnvelope
    set?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
    disconnect?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
    delete?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
    connect?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
    update?: PokemonEggGroupUpdateWithWhereUniqueWithoutPokemonInput | PokemonEggGroupUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: PokemonEggGroupUpdateManyWithWhereWithoutPokemonInput | PokemonEggGroupUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: PokemonEggGroupScalarWhereInput | PokemonEggGroupScalarWhereInput[]
  }

  export type EncounterUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<EncounterCreateWithoutPokemonInput, EncounterUncheckedCreateWithoutPokemonInput> | EncounterCreateWithoutPokemonInput[] | EncounterUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPokemonInput | EncounterCreateOrConnectWithoutPokemonInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutPokemonInput | EncounterUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: EncounterCreateManyPokemonInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutPokemonInput | EncounterUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutPokemonInput | EncounterUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type PokemonDexNumberUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<PokemonDexNumberCreateWithoutPokemonInput, PokemonDexNumberUncheckedCreateWithoutPokemonInput> | PokemonDexNumberCreateWithoutPokemonInput[] | PokemonDexNumberUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonDexNumberCreateOrConnectWithoutPokemonInput | PokemonDexNumberCreateOrConnectWithoutPokemonInput[]
    upsert?: PokemonDexNumberUpsertWithWhereUniqueWithoutPokemonInput | PokemonDexNumberUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: PokemonDexNumberCreateManyPokemonInputEnvelope
    set?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
    disconnect?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
    delete?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
    connect?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
    update?: PokemonDexNumberUpdateWithWhereUniqueWithoutPokemonInput | PokemonDexNumberUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: PokemonDexNumberUpdateManyWithWhereWithoutPokemonInput | PokemonDexNumberUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: PokemonDexNumberScalarWhereInput | PokemonDexNumberScalarWhereInput[]
  }

  export type PokemonMoveUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<PokemonMoveCreateWithoutPokemonInput, PokemonMoveUncheckedCreateWithoutPokemonInput> | PokemonMoveCreateWithoutPokemonInput[] | PokemonMoveUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonMoveCreateOrConnectWithoutPokemonInput | PokemonMoveCreateOrConnectWithoutPokemonInput[]
    upsert?: PokemonMoveUpsertWithWhereUniqueWithoutPokemonInput | PokemonMoveUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: PokemonMoveCreateManyPokemonInputEnvelope
    set?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    disconnect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    delete?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    connect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    update?: PokemonMoveUpdateWithWhereUniqueWithoutPokemonInput | PokemonMoveUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: PokemonMoveUpdateManyWithWhereWithoutPokemonInput | PokemonMoveUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: PokemonMoveScalarWhereInput | PokemonMoveScalarWhereInput[]
  }

  export type PokemonAbilityUncheckedUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<PokemonAbilityCreateWithoutPokemonInput, PokemonAbilityUncheckedCreateWithoutPokemonInput> | PokemonAbilityCreateWithoutPokemonInput[] | PokemonAbilityUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonAbilityCreateOrConnectWithoutPokemonInput | PokemonAbilityCreateOrConnectWithoutPokemonInput[]
    upsert?: PokemonAbilityUpsertWithWhereUniqueWithoutPokemonInput | PokemonAbilityUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: PokemonAbilityCreateManyPokemonInputEnvelope
    set?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
    disconnect?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
    delete?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
    connect?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
    update?: PokemonAbilityUpdateWithWhereUniqueWithoutPokemonInput | PokemonAbilityUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: PokemonAbilityUpdateManyWithWhereWithoutPokemonInput | PokemonAbilityUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: PokemonAbilityScalarWhereInput | PokemonAbilityScalarWhereInput[]
  }

  export type PokemonNatureUncheckedUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<PokemonNatureCreateWithoutPokemonInput, PokemonNatureUncheckedCreateWithoutPokemonInput> | PokemonNatureCreateWithoutPokemonInput[] | PokemonNatureUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonNatureCreateOrConnectWithoutPokemonInput | PokemonNatureCreateOrConnectWithoutPokemonInput[]
    upsert?: PokemonNatureUpsertWithWhereUniqueWithoutPokemonInput | PokemonNatureUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: PokemonNatureCreateManyPokemonInputEnvelope
    set?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
    disconnect?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
    delete?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
    connect?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
    update?: PokemonNatureUpdateWithWhereUniqueWithoutPokemonInput | PokemonNatureUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: PokemonNatureUpdateManyWithWhereWithoutPokemonInput | PokemonNatureUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: PokemonNatureScalarWhereInput | PokemonNatureScalarWhereInput[]
  }

  export type PokemonStatUncheckedUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<PokemonStatCreateWithoutPokemonInput, PokemonStatUncheckedCreateWithoutPokemonInput> | PokemonStatCreateWithoutPokemonInput[] | PokemonStatUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonStatCreateOrConnectWithoutPokemonInput | PokemonStatCreateOrConnectWithoutPokemonInput[]
    upsert?: PokemonStatUpsertWithWhereUniqueWithoutPokemonInput | PokemonStatUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: PokemonStatCreateManyPokemonInputEnvelope
    set?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
    disconnect?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
    delete?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
    connect?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
    update?: PokemonStatUpdateWithWhereUniqueWithoutPokemonInput | PokemonStatUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: PokemonStatUpdateManyWithWhereWithoutPokemonInput | PokemonStatUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: PokemonStatScalarWhereInput | PokemonStatScalarWhereInput[]
  }

  export type PokemonTypeUncheckedUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<PokemonTypeCreateWithoutPokemonInput, PokemonTypeUncheckedCreateWithoutPokemonInput> | PokemonTypeCreateWithoutPokemonInput[] | PokemonTypeUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonTypeCreateOrConnectWithoutPokemonInput | PokemonTypeCreateOrConnectWithoutPokemonInput[]
    upsert?: PokemonTypeUpsertWithWhereUniqueWithoutPokemonInput | PokemonTypeUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: PokemonTypeCreateManyPokemonInputEnvelope
    set?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
    disconnect?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
    delete?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
    connect?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
    update?: PokemonTypeUpdateWithWhereUniqueWithoutPokemonInput | PokemonTypeUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: PokemonTypeUpdateManyWithWhereWithoutPokemonInput | PokemonTypeUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: PokemonTypeScalarWhereInput | PokemonTypeScalarWhereInput[]
  }

  export type PokemonEggGroupUncheckedUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<PokemonEggGroupCreateWithoutPokemonInput, PokemonEggGroupUncheckedCreateWithoutPokemonInput> | PokemonEggGroupCreateWithoutPokemonInput[] | PokemonEggGroupUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonEggGroupCreateOrConnectWithoutPokemonInput | PokemonEggGroupCreateOrConnectWithoutPokemonInput[]
    upsert?: PokemonEggGroupUpsertWithWhereUniqueWithoutPokemonInput | PokemonEggGroupUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: PokemonEggGroupCreateManyPokemonInputEnvelope
    set?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
    disconnect?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
    delete?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
    connect?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
    update?: PokemonEggGroupUpdateWithWhereUniqueWithoutPokemonInput | PokemonEggGroupUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: PokemonEggGroupUpdateManyWithWhereWithoutPokemonInput | PokemonEggGroupUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: PokemonEggGroupScalarWhereInput | PokemonEggGroupScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<EncounterCreateWithoutPokemonInput, EncounterUncheckedCreateWithoutPokemonInput> | EncounterCreateWithoutPokemonInput[] | EncounterUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutPokemonInput | EncounterCreateOrConnectWithoutPokemonInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutPokemonInput | EncounterUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: EncounterCreateManyPokemonInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutPokemonInput | EncounterUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutPokemonInput | EncounterUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type PokemonDexNumberUncheckedUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<PokemonDexNumberCreateWithoutPokemonInput, PokemonDexNumberUncheckedCreateWithoutPokemonInput> | PokemonDexNumberCreateWithoutPokemonInput[] | PokemonDexNumberUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonDexNumberCreateOrConnectWithoutPokemonInput | PokemonDexNumberCreateOrConnectWithoutPokemonInput[]
    upsert?: PokemonDexNumberUpsertWithWhereUniqueWithoutPokemonInput | PokemonDexNumberUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: PokemonDexNumberCreateManyPokemonInputEnvelope
    set?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
    disconnect?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
    delete?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
    connect?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
    update?: PokemonDexNumberUpdateWithWhereUniqueWithoutPokemonInput | PokemonDexNumberUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: PokemonDexNumberUpdateManyWithWhereWithoutPokemonInput | PokemonDexNumberUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: PokemonDexNumberScalarWhereInput | PokemonDexNumberScalarWhereInput[]
  }

  export type PokemonMoveUncheckedUpdateManyWithoutPokemonNestedInput = {
    create?: XOR<PokemonMoveCreateWithoutPokemonInput, PokemonMoveUncheckedCreateWithoutPokemonInput> | PokemonMoveCreateWithoutPokemonInput[] | PokemonMoveUncheckedCreateWithoutPokemonInput[]
    connectOrCreate?: PokemonMoveCreateOrConnectWithoutPokemonInput | PokemonMoveCreateOrConnectWithoutPokemonInput[]
    upsert?: PokemonMoveUpsertWithWhereUniqueWithoutPokemonInput | PokemonMoveUpsertWithWhereUniqueWithoutPokemonInput[]
    createMany?: PokemonMoveCreateManyPokemonInputEnvelope
    set?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    disconnect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    delete?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    connect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    update?: PokemonMoveUpdateWithWhereUniqueWithoutPokemonInput | PokemonMoveUpdateWithWhereUniqueWithoutPokemonInput[]
    updateMany?: PokemonMoveUpdateManyWithWhereWithoutPokemonInput | PokemonMoveUpdateManyWithWhereWithoutPokemonInput[]
    deleteMany?: PokemonMoveScalarWhereInput | PokemonMoveScalarWhereInput[]
  }

  export type PokemonAbilityCreateNestedManyWithoutAbilityInput = {
    create?: XOR<PokemonAbilityCreateWithoutAbilityInput, PokemonAbilityUncheckedCreateWithoutAbilityInput> | PokemonAbilityCreateWithoutAbilityInput[] | PokemonAbilityUncheckedCreateWithoutAbilityInput[]
    connectOrCreate?: PokemonAbilityCreateOrConnectWithoutAbilityInput | PokemonAbilityCreateOrConnectWithoutAbilityInput[]
    createMany?: PokemonAbilityCreateManyAbilityInputEnvelope
    connect?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
  }

  export type PokemonAbilityUncheckedCreateNestedManyWithoutAbilityInput = {
    create?: XOR<PokemonAbilityCreateWithoutAbilityInput, PokemonAbilityUncheckedCreateWithoutAbilityInput> | PokemonAbilityCreateWithoutAbilityInput[] | PokemonAbilityUncheckedCreateWithoutAbilityInput[]
    connectOrCreate?: PokemonAbilityCreateOrConnectWithoutAbilityInput | PokemonAbilityCreateOrConnectWithoutAbilityInput[]
    createMany?: PokemonAbilityCreateManyAbilityInputEnvelope
    connect?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
  }

  export type PokemonAbilityUpdateManyWithoutAbilityNestedInput = {
    create?: XOR<PokemonAbilityCreateWithoutAbilityInput, PokemonAbilityUncheckedCreateWithoutAbilityInput> | PokemonAbilityCreateWithoutAbilityInput[] | PokemonAbilityUncheckedCreateWithoutAbilityInput[]
    connectOrCreate?: PokemonAbilityCreateOrConnectWithoutAbilityInput | PokemonAbilityCreateOrConnectWithoutAbilityInput[]
    upsert?: PokemonAbilityUpsertWithWhereUniqueWithoutAbilityInput | PokemonAbilityUpsertWithWhereUniqueWithoutAbilityInput[]
    createMany?: PokemonAbilityCreateManyAbilityInputEnvelope
    set?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
    disconnect?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
    delete?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
    connect?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
    update?: PokemonAbilityUpdateWithWhereUniqueWithoutAbilityInput | PokemonAbilityUpdateWithWhereUniqueWithoutAbilityInput[]
    updateMany?: PokemonAbilityUpdateManyWithWhereWithoutAbilityInput | PokemonAbilityUpdateManyWithWhereWithoutAbilityInput[]
    deleteMany?: PokemonAbilityScalarWhereInput | PokemonAbilityScalarWhereInput[]
  }

  export type PokemonAbilityUncheckedUpdateManyWithoutAbilityNestedInput = {
    create?: XOR<PokemonAbilityCreateWithoutAbilityInput, PokemonAbilityUncheckedCreateWithoutAbilityInput> | PokemonAbilityCreateWithoutAbilityInput[] | PokemonAbilityUncheckedCreateWithoutAbilityInput[]
    connectOrCreate?: PokemonAbilityCreateOrConnectWithoutAbilityInput | PokemonAbilityCreateOrConnectWithoutAbilityInput[]
    upsert?: PokemonAbilityUpsertWithWhereUniqueWithoutAbilityInput | PokemonAbilityUpsertWithWhereUniqueWithoutAbilityInput[]
    createMany?: PokemonAbilityCreateManyAbilityInputEnvelope
    set?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
    disconnect?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
    delete?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
    connect?: PokemonAbilityWhereUniqueInput | PokemonAbilityWhereUniqueInput[]
    update?: PokemonAbilityUpdateWithWhereUniqueWithoutAbilityInput | PokemonAbilityUpdateWithWhereUniqueWithoutAbilityInput[]
    updateMany?: PokemonAbilityUpdateManyWithWhereWithoutAbilityInput | PokemonAbilityUpdateManyWithWhereWithoutAbilityInput[]
    deleteMany?: PokemonAbilityScalarWhereInput | PokemonAbilityScalarWhereInput[]
  }

  export type PokemonCreateNestedOneWithoutAbilitiesInput = {
    create?: XOR<PokemonCreateWithoutAbilitiesInput, PokemonUncheckedCreateWithoutAbilitiesInput>
    connectOrCreate?: PokemonCreateOrConnectWithoutAbilitiesInput
    connect?: PokemonWhereUniqueInput
  }

  export type AbilityCreateNestedOneWithoutPokemonInput = {
    create?: XOR<AbilityCreateWithoutPokemonInput, AbilityUncheckedCreateWithoutPokemonInput>
    connectOrCreate?: AbilityCreateOrConnectWithoutPokemonInput
    connect?: AbilityWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PokemonUpdateOneRequiredWithoutAbilitiesNestedInput = {
    create?: XOR<PokemonCreateWithoutAbilitiesInput, PokemonUncheckedCreateWithoutAbilitiesInput>
    connectOrCreate?: PokemonCreateOrConnectWithoutAbilitiesInput
    upsert?: PokemonUpsertWithoutAbilitiesInput
    connect?: PokemonWhereUniqueInput
    update?: XOR<XOR<PokemonUpdateToOneWithWhereWithoutAbilitiesInput, PokemonUpdateWithoutAbilitiesInput>, PokemonUncheckedUpdateWithoutAbilitiesInput>
  }

  export type AbilityUpdateOneRequiredWithoutPokemonNestedInput = {
    create?: XOR<AbilityCreateWithoutPokemonInput, AbilityUncheckedCreateWithoutPokemonInput>
    connectOrCreate?: AbilityCreateOrConnectWithoutPokemonInput
    upsert?: AbilityUpsertWithoutPokemonInput
    connect?: AbilityWhereUniqueInput
    update?: XOR<XOR<AbilityUpdateToOneWithWhereWithoutPokemonInput, AbilityUpdateWithoutPokemonInput>, AbilityUncheckedUpdateWithoutPokemonInput>
  }

  export type StatCreateNestedOneWithoutNatures_increaseInput = {
    create?: XOR<StatCreateWithoutNatures_increaseInput, StatUncheckedCreateWithoutNatures_increaseInput>
    connectOrCreate?: StatCreateOrConnectWithoutNatures_increaseInput
    connect?: StatWhereUniqueInput
  }

  export type StatCreateNestedOneWithoutNatures_decreaseInput = {
    create?: XOR<StatCreateWithoutNatures_decreaseInput, StatUncheckedCreateWithoutNatures_decreaseInput>
    connectOrCreate?: StatCreateOrConnectWithoutNatures_decreaseInput
    connect?: StatWhereUniqueInput
  }

  export type PokemonNatureCreateNestedManyWithoutNatureInput = {
    create?: XOR<PokemonNatureCreateWithoutNatureInput, PokemonNatureUncheckedCreateWithoutNatureInput> | PokemonNatureCreateWithoutNatureInput[] | PokemonNatureUncheckedCreateWithoutNatureInput[]
    connectOrCreate?: PokemonNatureCreateOrConnectWithoutNatureInput | PokemonNatureCreateOrConnectWithoutNatureInput[]
    createMany?: PokemonNatureCreateManyNatureInputEnvelope
    connect?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
  }

  export type PokemonNatureUncheckedCreateNestedManyWithoutNatureInput = {
    create?: XOR<PokemonNatureCreateWithoutNatureInput, PokemonNatureUncheckedCreateWithoutNatureInput> | PokemonNatureCreateWithoutNatureInput[] | PokemonNatureUncheckedCreateWithoutNatureInput[]
    connectOrCreate?: PokemonNatureCreateOrConnectWithoutNatureInput | PokemonNatureCreateOrConnectWithoutNatureInput[]
    createMany?: PokemonNatureCreateManyNatureInputEnvelope
    connect?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
  }

  export type StatUpdateOneRequiredWithoutNatures_increaseNestedInput = {
    create?: XOR<StatCreateWithoutNatures_increaseInput, StatUncheckedCreateWithoutNatures_increaseInput>
    connectOrCreate?: StatCreateOrConnectWithoutNatures_increaseInput
    upsert?: StatUpsertWithoutNatures_increaseInput
    connect?: StatWhereUniqueInput
    update?: XOR<XOR<StatUpdateToOneWithWhereWithoutNatures_increaseInput, StatUpdateWithoutNatures_increaseInput>, StatUncheckedUpdateWithoutNatures_increaseInput>
  }

  export type StatUpdateOneRequiredWithoutNatures_decreaseNestedInput = {
    create?: XOR<StatCreateWithoutNatures_decreaseInput, StatUncheckedCreateWithoutNatures_decreaseInput>
    connectOrCreate?: StatCreateOrConnectWithoutNatures_decreaseInput
    upsert?: StatUpsertWithoutNatures_decreaseInput
    connect?: StatWhereUniqueInput
    update?: XOR<XOR<StatUpdateToOneWithWhereWithoutNatures_decreaseInput, StatUpdateWithoutNatures_decreaseInput>, StatUncheckedUpdateWithoutNatures_decreaseInput>
  }

  export type PokemonNatureUpdateManyWithoutNatureNestedInput = {
    create?: XOR<PokemonNatureCreateWithoutNatureInput, PokemonNatureUncheckedCreateWithoutNatureInput> | PokemonNatureCreateWithoutNatureInput[] | PokemonNatureUncheckedCreateWithoutNatureInput[]
    connectOrCreate?: PokemonNatureCreateOrConnectWithoutNatureInput | PokemonNatureCreateOrConnectWithoutNatureInput[]
    upsert?: PokemonNatureUpsertWithWhereUniqueWithoutNatureInput | PokemonNatureUpsertWithWhereUniqueWithoutNatureInput[]
    createMany?: PokemonNatureCreateManyNatureInputEnvelope
    set?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
    disconnect?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
    delete?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
    connect?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
    update?: PokemonNatureUpdateWithWhereUniqueWithoutNatureInput | PokemonNatureUpdateWithWhereUniqueWithoutNatureInput[]
    updateMany?: PokemonNatureUpdateManyWithWhereWithoutNatureInput | PokemonNatureUpdateManyWithWhereWithoutNatureInput[]
    deleteMany?: PokemonNatureScalarWhereInput | PokemonNatureScalarWhereInput[]
  }

  export type PokemonNatureUncheckedUpdateManyWithoutNatureNestedInput = {
    create?: XOR<PokemonNatureCreateWithoutNatureInput, PokemonNatureUncheckedCreateWithoutNatureInput> | PokemonNatureCreateWithoutNatureInput[] | PokemonNatureUncheckedCreateWithoutNatureInput[]
    connectOrCreate?: PokemonNatureCreateOrConnectWithoutNatureInput | PokemonNatureCreateOrConnectWithoutNatureInput[]
    upsert?: PokemonNatureUpsertWithWhereUniqueWithoutNatureInput | PokemonNatureUpsertWithWhereUniqueWithoutNatureInput[]
    createMany?: PokemonNatureCreateManyNatureInputEnvelope
    set?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
    disconnect?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
    delete?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
    connect?: PokemonNatureWhereUniqueInput | PokemonNatureWhereUniqueInput[]
    update?: PokemonNatureUpdateWithWhereUniqueWithoutNatureInput | PokemonNatureUpdateWithWhereUniqueWithoutNatureInput[]
    updateMany?: PokemonNatureUpdateManyWithWhereWithoutNatureInput | PokemonNatureUpdateManyWithWhereWithoutNatureInput[]
    deleteMany?: PokemonNatureScalarWhereInput | PokemonNatureScalarWhereInput[]
  }

  export type PokemonCreateNestedOneWithoutNaturesInput = {
    create?: XOR<PokemonCreateWithoutNaturesInput, PokemonUncheckedCreateWithoutNaturesInput>
    connectOrCreate?: PokemonCreateOrConnectWithoutNaturesInput
    connect?: PokemonWhereUniqueInput
  }

  export type NatureCreateNestedOneWithoutPokemonInput = {
    create?: XOR<NatureCreateWithoutPokemonInput, NatureUncheckedCreateWithoutPokemonInput>
    connectOrCreate?: NatureCreateOrConnectWithoutPokemonInput
    connect?: NatureWhereUniqueInput
  }

  export type PokemonUpdateOneRequiredWithoutNaturesNestedInput = {
    create?: XOR<PokemonCreateWithoutNaturesInput, PokemonUncheckedCreateWithoutNaturesInput>
    connectOrCreate?: PokemonCreateOrConnectWithoutNaturesInput
    upsert?: PokemonUpsertWithoutNaturesInput
    connect?: PokemonWhereUniqueInput
    update?: XOR<XOR<PokemonUpdateToOneWithWhereWithoutNaturesInput, PokemonUpdateWithoutNaturesInput>, PokemonUncheckedUpdateWithoutNaturesInput>
  }

  export type NatureUpdateOneRequiredWithoutPokemonNestedInput = {
    create?: XOR<NatureCreateWithoutPokemonInput, NatureUncheckedCreateWithoutPokemonInput>
    connectOrCreate?: NatureCreateOrConnectWithoutPokemonInput
    upsert?: NatureUpsertWithoutPokemonInput
    connect?: NatureWhereUniqueInput
    update?: XOR<XOR<NatureUpdateToOneWithWhereWithoutPokemonInput, NatureUpdateWithoutPokemonInput>, NatureUncheckedUpdateWithoutPokemonInput>
  }

  export type NatureCreateNestedManyWithoutStat_increasedInput = {
    create?: XOR<NatureCreateWithoutStat_increasedInput, NatureUncheckedCreateWithoutStat_increasedInput> | NatureCreateWithoutStat_increasedInput[] | NatureUncheckedCreateWithoutStat_increasedInput[]
    connectOrCreate?: NatureCreateOrConnectWithoutStat_increasedInput | NatureCreateOrConnectWithoutStat_increasedInput[]
    createMany?: NatureCreateManyStat_increasedInputEnvelope
    connect?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
  }

  export type NatureCreateNestedManyWithoutStat_decreasedInput = {
    create?: XOR<NatureCreateWithoutStat_decreasedInput, NatureUncheckedCreateWithoutStat_decreasedInput> | NatureCreateWithoutStat_decreasedInput[] | NatureUncheckedCreateWithoutStat_decreasedInput[]
    connectOrCreate?: NatureCreateOrConnectWithoutStat_decreasedInput | NatureCreateOrConnectWithoutStat_decreasedInput[]
    createMany?: NatureCreateManyStat_decreasedInputEnvelope
    connect?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
  }

  export type PokemonStatCreateNestedManyWithoutStatInput = {
    create?: XOR<PokemonStatCreateWithoutStatInput, PokemonStatUncheckedCreateWithoutStatInput> | PokemonStatCreateWithoutStatInput[] | PokemonStatUncheckedCreateWithoutStatInput[]
    connectOrCreate?: PokemonStatCreateOrConnectWithoutStatInput | PokemonStatCreateOrConnectWithoutStatInput[]
    createMany?: PokemonStatCreateManyStatInputEnvelope
    connect?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
  }

  export type NatureUncheckedCreateNestedManyWithoutStat_increasedInput = {
    create?: XOR<NatureCreateWithoutStat_increasedInput, NatureUncheckedCreateWithoutStat_increasedInput> | NatureCreateWithoutStat_increasedInput[] | NatureUncheckedCreateWithoutStat_increasedInput[]
    connectOrCreate?: NatureCreateOrConnectWithoutStat_increasedInput | NatureCreateOrConnectWithoutStat_increasedInput[]
    createMany?: NatureCreateManyStat_increasedInputEnvelope
    connect?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
  }

  export type NatureUncheckedCreateNestedManyWithoutStat_decreasedInput = {
    create?: XOR<NatureCreateWithoutStat_decreasedInput, NatureUncheckedCreateWithoutStat_decreasedInput> | NatureCreateWithoutStat_decreasedInput[] | NatureUncheckedCreateWithoutStat_decreasedInput[]
    connectOrCreate?: NatureCreateOrConnectWithoutStat_decreasedInput | NatureCreateOrConnectWithoutStat_decreasedInput[]
    createMany?: NatureCreateManyStat_decreasedInputEnvelope
    connect?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
  }

  export type PokemonStatUncheckedCreateNestedManyWithoutStatInput = {
    create?: XOR<PokemonStatCreateWithoutStatInput, PokemonStatUncheckedCreateWithoutStatInput> | PokemonStatCreateWithoutStatInput[] | PokemonStatUncheckedCreateWithoutStatInput[]
    connectOrCreate?: PokemonStatCreateOrConnectWithoutStatInput | PokemonStatCreateOrConnectWithoutStatInput[]
    createMany?: PokemonStatCreateManyStatInputEnvelope
    connect?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
  }

  export type NatureUpdateManyWithoutStat_increasedNestedInput = {
    create?: XOR<NatureCreateWithoutStat_increasedInput, NatureUncheckedCreateWithoutStat_increasedInput> | NatureCreateWithoutStat_increasedInput[] | NatureUncheckedCreateWithoutStat_increasedInput[]
    connectOrCreate?: NatureCreateOrConnectWithoutStat_increasedInput | NatureCreateOrConnectWithoutStat_increasedInput[]
    upsert?: NatureUpsertWithWhereUniqueWithoutStat_increasedInput | NatureUpsertWithWhereUniqueWithoutStat_increasedInput[]
    createMany?: NatureCreateManyStat_increasedInputEnvelope
    set?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
    disconnect?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
    delete?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
    connect?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
    update?: NatureUpdateWithWhereUniqueWithoutStat_increasedInput | NatureUpdateWithWhereUniqueWithoutStat_increasedInput[]
    updateMany?: NatureUpdateManyWithWhereWithoutStat_increasedInput | NatureUpdateManyWithWhereWithoutStat_increasedInput[]
    deleteMany?: NatureScalarWhereInput | NatureScalarWhereInput[]
  }

  export type NatureUpdateManyWithoutStat_decreasedNestedInput = {
    create?: XOR<NatureCreateWithoutStat_decreasedInput, NatureUncheckedCreateWithoutStat_decreasedInput> | NatureCreateWithoutStat_decreasedInput[] | NatureUncheckedCreateWithoutStat_decreasedInput[]
    connectOrCreate?: NatureCreateOrConnectWithoutStat_decreasedInput | NatureCreateOrConnectWithoutStat_decreasedInput[]
    upsert?: NatureUpsertWithWhereUniqueWithoutStat_decreasedInput | NatureUpsertWithWhereUniqueWithoutStat_decreasedInput[]
    createMany?: NatureCreateManyStat_decreasedInputEnvelope
    set?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
    disconnect?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
    delete?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
    connect?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
    update?: NatureUpdateWithWhereUniqueWithoutStat_decreasedInput | NatureUpdateWithWhereUniqueWithoutStat_decreasedInput[]
    updateMany?: NatureUpdateManyWithWhereWithoutStat_decreasedInput | NatureUpdateManyWithWhereWithoutStat_decreasedInput[]
    deleteMany?: NatureScalarWhereInput | NatureScalarWhereInput[]
  }

  export type PokemonStatUpdateManyWithoutStatNestedInput = {
    create?: XOR<PokemonStatCreateWithoutStatInput, PokemonStatUncheckedCreateWithoutStatInput> | PokemonStatCreateWithoutStatInput[] | PokemonStatUncheckedCreateWithoutStatInput[]
    connectOrCreate?: PokemonStatCreateOrConnectWithoutStatInput | PokemonStatCreateOrConnectWithoutStatInput[]
    upsert?: PokemonStatUpsertWithWhereUniqueWithoutStatInput | PokemonStatUpsertWithWhereUniqueWithoutStatInput[]
    createMany?: PokemonStatCreateManyStatInputEnvelope
    set?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
    disconnect?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
    delete?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
    connect?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
    update?: PokemonStatUpdateWithWhereUniqueWithoutStatInput | PokemonStatUpdateWithWhereUniqueWithoutStatInput[]
    updateMany?: PokemonStatUpdateManyWithWhereWithoutStatInput | PokemonStatUpdateManyWithWhereWithoutStatInput[]
    deleteMany?: PokemonStatScalarWhereInput | PokemonStatScalarWhereInput[]
  }

  export type NatureUncheckedUpdateManyWithoutStat_increasedNestedInput = {
    create?: XOR<NatureCreateWithoutStat_increasedInput, NatureUncheckedCreateWithoutStat_increasedInput> | NatureCreateWithoutStat_increasedInput[] | NatureUncheckedCreateWithoutStat_increasedInput[]
    connectOrCreate?: NatureCreateOrConnectWithoutStat_increasedInput | NatureCreateOrConnectWithoutStat_increasedInput[]
    upsert?: NatureUpsertWithWhereUniqueWithoutStat_increasedInput | NatureUpsertWithWhereUniqueWithoutStat_increasedInput[]
    createMany?: NatureCreateManyStat_increasedInputEnvelope
    set?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
    disconnect?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
    delete?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
    connect?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
    update?: NatureUpdateWithWhereUniqueWithoutStat_increasedInput | NatureUpdateWithWhereUniqueWithoutStat_increasedInput[]
    updateMany?: NatureUpdateManyWithWhereWithoutStat_increasedInput | NatureUpdateManyWithWhereWithoutStat_increasedInput[]
    deleteMany?: NatureScalarWhereInput | NatureScalarWhereInput[]
  }

  export type NatureUncheckedUpdateManyWithoutStat_decreasedNestedInput = {
    create?: XOR<NatureCreateWithoutStat_decreasedInput, NatureUncheckedCreateWithoutStat_decreasedInput> | NatureCreateWithoutStat_decreasedInput[] | NatureUncheckedCreateWithoutStat_decreasedInput[]
    connectOrCreate?: NatureCreateOrConnectWithoutStat_decreasedInput | NatureCreateOrConnectWithoutStat_decreasedInput[]
    upsert?: NatureUpsertWithWhereUniqueWithoutStat_decreasedInput | NatureUpsertWithWhereUniqueWithoutStat_decreasedInput[]
    createMany?: NatureCreateManyStat_decreasedInputEnvelope
    set?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
    disconnect?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
    delete?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
    connect?: NatureWhereUniqueInput | NatureWhereUniqueInput[]
    update?: NatureUpdateWithWhereUniqueWithoutStat_decreasedInput | NatureUpdateWithWhereUniqueWithoutStat_decreasedInput[]
    updateMany?: NatureUpdateManyWithWhereWithoutStat_decreasedInput | NatureUpdateManyWithWhereWithoutStat_decreasedInput[]
    deleteMany?: NatureScalarWhereInput | NatureScalarWhereInput[]
  }

  export type PokemonStatUncheckedUpdateManyWithoutStatNestedInput = {
    create?: XOR<PokemonStatCreateWithoutStatInput, PokemonStatUncheckedCreateWithoutStatInput> | PokemonStatCreateWithoutStatInput[] | PokemonStatUncheckedCreateWithoutStatInput[]
    connectOrCreate?: PokemonStatCreateOrConnectWithoutStatInput | PokemonStatCreateOrConnectWithoutStatInput[]
    upsert?: PokemonStatUpsertWithWhereUniqueWithoutStatInput | PokemonStatUpsertWithWhereUniqueWithoutStatInput[]
    createMany?: PokemonStatCreateManyStatInputEnvelope
    set?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
    disconnect?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
    delete?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
    connect?: PokemonStatWhereUniqueInput | PokemonStatWhereUniqueInput[]
    update?: PokemonStatUpdateWithWhereUniqueWithoutStatInput | PokemonStatUpdateWithWhereUniqueWithoutStatInput[]
    updateMany?: PokemonStatUpdateManyWithWhereWithoutStatInput | PokemonStatUpdateManyWithWhereWithoutStatInput[]
    deleteMany?: PokemonStatScalarWhereInput | PokemonStatScalarWhereInput[]
  }

  export type PokemonCreateNestedOneWithoutStatsInput = {
    create?: XOR<PokemonCreateWithoutStatsInput, PokemonUncheckedCreateWithoutStatsInput>
    connectOrCreate?: PokemonCreateOrConnectWithoutStatsInput
    connect?: PokemonWhereUniqueInput
  }

  export type StatCreateNestedOneWithoutPokemon_statsInput = {
    create?: XOR<StatCreateWithoutPokemon_statsInput, StatUncheckedCreateWithoutPokemon_statsInput>
    connectOrCreate?: StatCreateOrConnectWithoutPokemon_statsInput
    connect?: StatWhereUniqueInput
  }

  export type PokemonUpdateOneRequiredWithoutStatsNestedInput = {
    create?: XOR<PokemonCreateWithoutStatsInput, PokemonUncheckedCreateWithoutStatsInput>
    connectOrCreate?: PokemonCreateOrConnectWithoutStatsInput
    upsert?: PokemonUpsertWithoutStatsInput
    connect?: PokemonWhereUniqueInput
    update?: XOR<XOR<PokemonUpdateToOneWithWhereWithoutStatsInput, PokemonUpdateWithoutStatsInput>, PokemonUncheckedUpdateWithoutStatsInput>
  }

  export type StatUpdateOneRequiredWithoutPokemon_statsNestedInput = {
    create?: XOR<StatCreateWithoutPokemon_statsInput, StatUncheckedCreateWithoutPokemon_statsInput>
    connectOrCreate?: StatCreateOrConnectWithoutPokemon_statsInput
    upsert?: StatUpsertWithoutPokemon_statsInput
    connect?: StatWhereUniqueInput
    update?: XOR<XOR<StatUpdateToOneWithWhereWithoutPokemon_statsInput, StatUpdateWithoutPokemon_statsInput>, StatUncheckedUpdateWithoutPokemon_statsInput>
  }

  export type GenerationCreateNestedOneWithoutTypesInput = {
    create?: XOR<GenerationCreateWithoutTypesInput, GenerationUncheckedCreateWithoutTypesInput>
    connectOrCreate?: GenerationCreateOrConnectWithoutTypesInput
    connect?: GenerationWhereUniqueInput
  }

  export type PokemonTypeCreateNestedManyWithoutTypeInput = {
    create?: XOR<PokemonTypeCreateWithoutTypeInput, PokemonTypeUncheckedCreateWithoutTypeInput> | PokemonTypeCreateWithoutTypeInput[] | PokemonTypeUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: PokemonTypeCreateOrConnectWithoutTypeInput | PokemonTypeCreateOrConnectWithoutTypeInput[]
    createMany?: PokemonTypeCreateManyTypeInputEnvelope
    connect?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
  }

  export type TypeEffectivenessCreateNestedManyWithoutAttackerInput = {
    create?: XOR<TypeEffectivenessCreateWithoutAttackerInput, TypeEffectivenessUncheckedCreateWithoutAttackerInput> | TypeEffectivenessCreateWithoutAttackerInput[] | TypeEffectivenessUncheckedCreateWithoutAttackerInput[]
    connectOrCreate?: TypeEffectivenessCreateOrConnectWithoutAttackerInput | TypeEffectivenessCreateOrConnectWithoutAttackerInput[]
    createMany?: TypeEffectivenessCreateManyAttackerInputEnvelope
    connect?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
  }

  export type TypeEffectivenessCreateNestedManyWithoutDefenderInput = {
    create?: XOR<TypeEffectivenessCreateWithoutDefenderInput, TypeEffectivenessUncheckedCreateWithoutDefenderInput> | TypeEffectivenessCreateWithoutDefenderInput[] | TypeEffectivenessUncheckedCreateWithoutDefenderInput[]
    connectOrCreate?: TypeEffectivenessCreateOrConnectWithoutDefenderInput | TypeEffectivenessCreateOrConnectWithoutDefenderInput[]
    createMany?: TypeEffectivenessCreateManyDefenderInputEnvelope
    connect?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
  }

  export type MoveCreateNestedManyWithoutTypeInput = {
    create?: XOR<MoveCreateWithoutTypeInput, MoveUncheckedCreateWithoutTypeInput> | MoveCreateWithoutTypeInput[] | MoveUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutTypeInput | MoveCreateOrConnectWithoutTypeInput[]
    createMany?: MoveCreateManyTypeInputEnvelope
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
  }

  export type PokemonTypeUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<PokemonTypeCreateWithoutTypeInput, PokemonTypeUncheckedCreateWithoutTypeInput> | PokemonTypeCreateWithoutTypeInput[] | PokemonTypeUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: PokemonTypeCreateOrConnectWithoutTypeInput | PokemonTypeCreateOrConnectWithoutTypeInput[]
    createMany?: PokemonTypeCreateManyTypeInputEnvelope
    connect?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
  }

  export type TypeEffectivenessUncheckedCreateNestedManyWithoutAttackerInput = {
    create?: XOR<TypeEffectivenessCreateWithoutAttackerInput, TypeEffectivenessUncheckedCreateWithoutAttackerInput> | TypeEffectivenessCreateWithoutAttackerInput[] | TypeEffectivenessUncheckedCreateWithoutAttackerInput[]
    connectOrCreate?: TypeEffectivenessCreateOrConnectWithoutAttackerInput | TypeEffectivenessCreateOrConnectWithoutAttackerInput[]
    createMany?: TypeEffectivenessCreateManyAttackerInputEnvelope
    connect?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
  }

  export type TypeEffectivenessUncheckedCreateNestedManyWithoutDefenderInput = {
    create?: XOR<TypeEffectivenessCreateWithoutDefenderInput, TypeEffectivenessUncheckedCreateWithoutDefenderInput> | TypeEffectivenessCreateWithoutDefenderInput[] | TypeEffectivenessUncheckedCreateWithoutDefenderInput[]
    connectOrCreate?: TypeEffectivenessCreateOrConnectWithoutDefenderInput | TypeEffectivenessCreateOrConnectWithoutDefenderInput[]
    createMany?: TypeEffectivenessCreateManyDefenderInputEnvelope
    connect?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
  }

  export type MoveUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<MoveCreateWithoutTypeInput, MoveUncheckedCreateWithoutTypeInput> | MoveCreateWithoutTypeInput[] | MoveUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutTypeInput | MoveCreateOrConnectWithoutTypeInput[]
    createMany?: MoveCreateManyTypeInputEnvelope
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
  }

  export type GenerationUpdateOneRequiredWithoutTypesNestedInput = {
    create?: XOR<GenerationCreateWithoutTypesInput, GenerationUncheckedCreateWithoutTypesInput>
    connectOrCreate?: GenerationCreateOrConnectWithoutTypesInput
    upsert?: GenerationUpsertWithoutTypesInput
    connect?: GenerationWhereUniqueInput
    update?: XOR<XOR<GenerationUpdateToOneWithWhereWithoutTypesInput, GenerationUpdateWithoutTypesInput>, GenerationUncheckedUpdateWithoutTypesInput>
  }

  export type PokemonTypeUpdateManyWithoutTypeNestedInput = {
    create?: XOR<PokemonTypeCreateWithoutTypeInput, PokemonTypeUncheckedCreateWithoutTypeInput> | PokemonTypeCreateWithoutTypeInput[] | PokemonTypeUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: PokemonTypeCreateOrConnectWithoutTypeInput | PokemonTypeCreateOrConnectWithoutTypeInput[]
    upsert?: PokemonTypeUpsertWithWhereUniqueWithoutTypeInput | PokemonTypeUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: PokemonTypeCreateManyTypeInputEnvelope
    set?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
    disconnect?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
    delete?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
    connect?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
    update?: PokemonTypeUpdateWithWhereUniqueWithoutTypeInput | PokemonTypeUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: PokemonTypeUpdateManyWithWhereWithoutTypeInput | PokemonTypeUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: PokemonTypeScalarWhereInput | PokemonTypeScalarWhereInput[]
  }

  export type TypeEffectivenessUpdateManyWithoutAttackerNestedInput = {
    create?: XOR<TypeEffectivenessCreateWithoutAttackerInput, TypeEffectivenessUncheckedCreateWithoutAttackerInput> | TypeEffectivenessCreateWithoutAttackerInput[] | TypeEffectivenessUncheckedCreateWithoutAttackerInput[]
    connectOrCreate?: TypeEffectivenessCreateOrConnectWithoutAttackerInput | TypeEffectivenessCreateOrConnectWithoutAttackerInput[]
    upsert?: TypeEffectivenessUpsertWithWhereUniqueWithoutAttackerInput | TypeEffectivenessUpsertWithWhereUniqueWithoutAttackerInput[]
    createMany?: TypeEffectivenessCreateManyAttackerInputEnvelope
    set?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
    disconnect?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
    delete?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
    connect?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
    update?: TypeEffectivenessUpdateWithWhereUniqueWithoutAttackerInput | TypeEffectivenessUpdateWithWhereUniqueWithoutAttackerInput[]
    updateMany?: TypeEffectivenessUpdateManyWithWhereWithoutAttackerInput | TypeEffectivenessUpdateManyWithWhereWithoutAttackerInput[]
    deleteMany?: TypeEffectivenessScalarWhereInput | TypeEffectivenessScalarWhereInput[]
  }

  export type TypeEffectivenessUpdateManyWithoutDefenderNestedInput = {
    create?: XOR<TypeEffectivenessCreateWithoutDefenderInput, TypeEffectivenessUncheckedCreateWithoutDefenderInput> | TypeEffectivenessCreateWithoutDefenderInput[] | TypeEffectivenessUncheckedCreateWithoutDefenderInput[]
    connectOrCreate?: TypeEffectivenessCreateOrConnectWithoutDefenderInput | TypeEffectivenessCreateOrConnectWithoutDefenderInput[]
    upsert?: TypeEffectivenessUpsertWithWhereUniqueWithoutDefenderInput | TypeEffectivenessUpsertWithWhereUniqueWithoutDefenderInput[]
    createMany?: TypeEffectivenessCreateManyDefenderInputEnvelope
    set?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
    disconnect?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
    delete?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
    connect?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
    update?: TypeEffectivenessUpdateWithWhereUniqueWithoutDefenderInput | TypeEffectivenessUpdateWithWhereUniqueWithoutDefenderInput[]
    updateMany?: TypeEffectivenessUpdateManyWithWhereWithoutDefenderInput | TypeEffectivenessUpdateManyWithWhereWithoutDefenderInput[]
    deleteMany?: TypeEffectivenessScalarWhereInput | TypeEffectivenessScalarWhereInput[]
  }

  export type MoveUpdateManyWithoutTypeNestedInput = {
    create?: XOR<MoveCreateWithoutTypeInput, MoveUncheckedCreateWithoutTypeInput> | MoveCreateWithoutTypeInput[] | MoveUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutTypeInput | MoveCreateOrConnectWithoutTypeInput[]
    upsert?: MoveUpsertWithWhereUniqueWithoutTypeInput | MoveUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: MoveCreateManyTypeInputEnvelope
    set?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    disconnect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    delete?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    update?: MoveUpdateWithWhereUniqueWithoutTypeInput | MoveUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: MoveUpdateManyWithWhereWithoutTypeInput | MoveUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: MoveScalarWhereInput | MoveScalarWhereInput[]
  }

  export type PokemonTypeUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<PokemonTypeCreateWithoutTypeInput, PokemonTypeUncheckedCreateWithoutTypeInput> | PokemonTypeCreateWithoutTypeInput[] | PokemonTypeUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: PokemonTypeCreateOrConnectWithoutTypeInput | PokemonTypeCreateOrConnectWithoutTypeInput[]
    upsert?: PokemonTypeUpsertWithWhereUniqueWithoutTypeInput | PokemonTypeUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: PokemonTypeCreateManyTypeInputEnvelope
    set?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
    disconnect?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
    delete?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
    connect?: PokemonTypeWhereUniqueInput | PokemonTypeWhereUniqueInput[]
    update?: PokemonTypeUpdateWithWhereUniqueWithoutTypeInput | PokemonTypeUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: PokemonTypeUpdateManyWithWhereWithoutTypeInput | PokemonTypeUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: PokemonTypeScalarWhereInput | PokemonTypeScalarWhereInput[]
  }

  export type TypeEffectivenessUncheckedUpdateManyWithoutAttackerNestedInput = {
    create?: XOR<TypeEffectivenessCreateWithoutAttackerInput, TypeEffectivenessUncheckedCreateWithoutAttackerInput> | TypeEffectivenessCreateWithoutAttackerInput[] | TypeEffectivenessUncheckedCreateWithoutAttackerInput[]
    connectOrCreate?: TypeEffectivenessCreateOrConnectWithoutAttackerInput | TypeEffectivenessCreateOrConnectWithoutAttackerInput[]
    upsert?: TypeEffectivenessUpsertWithWhereUniqueWithoutAttackerInput | TypeEffectivenessUpsertWithWhereUniqueWithoutAttackerInput[]
    createMany?: TypeEffectivenessCreateManyAttackerInputEnvelope
    set?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
    disconnect?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
    delete?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
    connect?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
    update?: TypeEffectivenessUpdateWithWhereUniqueWithoutAttackerInput | TypeEffectivenessUpdateWithWhereUniqueWithoutAttackerInput[]
    updateMany?: TypeEffectivenessUpdateManyWithWhereWithoutAttackerInput | TypeEffectivenessUpdateManyWithWhereWithoutAttackerInput[]
    deleteMany?: TypeEffectivenessScalarWhereInput | TypeEffectivenessScalarWhereInput[]
  }

  export type TypeEffectivenessUncheckedUpdateManyWithoutDefenderNestedInput = {
    create?: XOR<TypeEffectivenessCreateWithoutDefenderInput, TypeEffectivenessUncheckedCreateWithoutDefenderInput> | TypeEffectivenessCreateWithoutDefenderInput[] | TypeEffectivenessUncheckedCreateWithoutDefenderInput[]
    connectOrCreate?: TypeEffectivenessCreateOrConnectWithoutDefenderInput | TypeEffectivenessCreateOrConnectWithoutDefenderInput[]
    upsert?: TypeEffectivenessUpsertWithWhereUniqueWithoutDefenderInput | TypeEffectivenessUpsertWithWhereUniqueWithoutDefenderInput[]
    createMany?: TypeEffectivenessCreateManyDefenderInputEnvelope
    set?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
    disconnect?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
    delete?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
    connect?: TypeEffectivenessWhereUniqueInput | TypeEffectivenessWhereUniqueInput[]
    update?: TypeEffectivenessUpdateWithWhereUniqueWithoutDefenderInput | TypeEffectivenessUpdateWithWhereUniqueWithoutDefenderInput[]
    updateMany?: TypeEffectivenessUpdateManyWithWhereWithoutDefenderInput | TypeEffectivenessUpdateManyWithWhereWithoutDefenderInput[]
    deleteMany?: TypeEffectivenessScalarWhereInput | TypeEffectivenessScalarWhereInput[]
  }

  export type MoveUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<MoveCreateWithoutTypeInput, MoveUncheckedCreateWithoutTypeInput> | MoveCreateWithoutTypeInput[] | MoveUncheckedCreateWithoutTypeInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutTypeInput | MoveCreateOrConnectWithoutTypeInput[]
    upsert?: MoveUpsertWithWhereUniqueWithoutTypeInput | MoveUpsertWithWhereUniqueWithoutTypeInput[]
    createMany?: MoveCreateManyTypeInputEnvelope
    set?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    disconnect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    delete?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    update?: MoveUpdateWithWhereUniqueWithoutTypeInput | MoveUpdateWithWhereUniqueWithoutTypeInput[]
    updateMany?: MoveUpdateManyWithWhereWithoutTypeInput | MoveUpdateManyWithWhereWithoutTypeInput[]
    deleteMany?: MoveScalarWhereInput | MoveScalarWhereInput[]
  }

  export type TypeCreateNestedOneWithoutAttackingInput = {
    create?: XOR<TypeCreateWithoutAttackingInput, TypeUncheckedCreateWithoutAttackingInput>
    connectOrCreate?: TypeCreateOrConnectWithoutAttackingInput
    connect?: TypeWhereUniqueInput
  }

  export type TypeCreateNestedOneWithoutDefendingInput = {
    create?: XOR<TypeCreateWithoutDefendingInput, TypeUncheckedCreateWithoutDefendingInput>
    connectOrCreate?: TypeCreateOrConnectWithoutDefendingInput
    connect?: TypeWhereUniqueInput
  }

  export type TypeUpdateOneRequiredWithoutAttackingNestedInput = {
    create?: XOR<TypeCreateWithoutAttackingInput, TypeUncheckedCreateWithoutAttackingInput>
    connectOrCreate?: TypeCreateOrConnectWithoutAttackingInput
    upsert?: TypeUpsertWithoutAttackingInput
    connect?: TypeWhereUniqueInput
    update?: XOR<XOR<TypeUpdateToOneWithWhereWithoutAttackingInput, TypeUpdateWithoutAttackingInput>, TypeUncheckedUpdateWithoutAttackingInput>
  }

  export type TypeUpdateOneRequiredWithoutDefendingNestedInput = {
    create?: XOR<TypeCreateWithoutDefendingInput, TypeUncheckedCreateWithoutDefendingInput>
    connectOrCreate?: TypeCreateOrConnectWithoutDefendingInput
    upsert?: TypeUpsertWithoutDefendingInput
    connect?: TypeWhereUniqueInput
    update?: XOR<XOR<TypeUpdateToOneWithWhereWithoutDefendingInput, TypeUpdateWithoutDefendingInput>, TypeUncheckedUpdateWithoutDefendingInput>
  }

  export type PokemonCreateNestedOneWithoutTypesInput = {
    create?: XOR<PokemonCreateWithoutTypesInput, PokemonUncheckedCreateWithoutTypesInput>
    connectOrCreate?: PokemonCreateOrConnectWithoutTypesInput
    connect?: PokemonWhereUniqueInput
  }

  export type TypeCreateNestedOneWithoutPokemonInput = {
    create?: XOR<TypeCreateWithoutPokemonInput, TypeUncheckedCreateWithoutPokemonInput>
    connectOrCreate?: TypeCreateOrConnectWithoutPokemonInput
    connect?: TypeWhereUniqueInput
  }

  export type PokemonUpdateOneRequiredWithoutTypesNestedInput = {
    create?: XOR<PokemonCreateWithoutTypesInput, PokemonUncheckedCreateWithoutTypesInput>
    connectOrCreate?: PokemonCreateOrConnectWithoutTypesInput
    upsert?: PokemonUpsertWithoutTypesInput
    connect?: PokemonWhereUniqueInput
    update?: XOR<XOR<PokemonUpdateToOneWithWhereWithoutTypesInput, PokemonUpdateWithoutTypesInput>, PokemonUncheckedUpdateWithoutTypesInput>
  }

  export type TypeUpdateOneRequiredWithoutPokemonNestedInput = {
    create?: XOR<TypeCreateWithoutPokemonInput, TypeUncheckedCreateWithoutPokemonInput>
    connectOrCreate?: TypeCreateOrConnectWithoutPokemonInput
    upsert?: TypeUpsertWithoutPokemonInput
    connect?: TypeWhereUniqueInput
    update?: XOR<XOR<TypeUpdateToOneWithWhereWithoutPokemonInput, TypeUpdateWithoutPokemonInput>, TypeUncheckedUpdateWithoutPokemonInput>
  }

  export type PokemonEggGroupCreateNestedManyWithoutEgg_groupInput = {
    create?: XOR<PokemonEggGroupCreateWithoutEgg_groupInput, PokemonEggGroupUncheckedCreateWithoutEgg_groupInput> | PokemonEggGroupCreateWithoutEgg_groupInput[] | PokemonEggGroupUncheckedCreateWithoutEgg_groupInput[]
    connectOrCreate?: PokemonEggGroupCreateOrConnectWithoutEgg_groupInput | PokemonEggGroupCreateOrConnectWithoutEgg_groupInput[]
    createMany?: PokemonEggGroupCreateManyEgg_groupInputEnvelope
    connect?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
  }

  export type PokemonEggGroupUncheckedCreateNestedManyWithoutEgg_groupInput = {
    create?: XOR<PokemonEggGroupCreateWithoutEgg_groupInput, PokemonEggGroupUncheckedCreateWithoutEgg_groupInput> | PokemonEggGroupCreateWithoutEgg_groupInput[] | PokemonEggGroupUncheckedCreateWithoutEgg_groupInput[]
    connectOrCreate?: PokemonEggGroupCreateOrConnectWithoutEgg_groupInput | PokemonEggGroupCreateOrConnectWithoutEgg_groupInput[]
    createMany?: PokemonEggGroupCreateManyEgg_groupInputEnvelope
    connect?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
  }

  export type PokemonEggGroupUpdateManyWithoutEgg_groupNestedInput = {
    create?: XOR<PokemonEggGroupCreateWithoutEgg_groupInput, PokemonEggGroupUncheckedCreateWithoutEgg_groupInput> | PokemonEggGroupCreateWithoutEgg_groupInput[] | PokemonEggGroupUncheckedCreateWithoutEgg_groupInput[]
    connectOrCreate?: PokemonEggGroupCreateOrConnectWithoutEgg_groupInput | PokemonEggGroupCreateOrConnectWithoutEgg_groupInput[]
    upsert?: PokemonEggGroupUpsertWithWhereUniqueWithoutEgg_groupInput | PokemonEggGroupUpsertWithWhereUniqueWithoutEgg_groupInput[]
    createMany?: PokemonEggGroupCreateManyEgg_groupInputEnvelope
    set?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
    disconnect?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
    delete?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
    connect?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
    update?: PokemonEggGroupUpdateWithWhereUniqueWithoutEgg_groupInput | PokemonEggGroupUpdateWithWhereUniqueWithoutEgg_groupInput[]
    updateMany?: PokemonEggGroupUpdateManyWithWhereWithoutEgg_groupInput | PokemonEggGroupUpdateManyWithWhereWithoutEgg_groupInput[]
    deleteMany?: PokemonEggGroupScalarWhereInput | PokemonEggGroupScalarWhereInput[]
  }

  export type PokemonEggGroupUncheckedUpdateManyWithoutEgg_groupNestedInput = {
    create?: XOR<PokemonEggGroupCreateWithoutEgg_groupInput, PokemonEggGroupUncheckedCreateWithoutEgg_groupInput> | PokemonEggGroupCreateWithoutEgg_groupInput[] | PokemonEggGroupUncheckedCreateWithoutEgg_groupInput[]
    connectOrCreate?: PokemonEggGroupCreateOrConnectWithoutEgg_groupInput | PokemonEggGroupCreateOrConnectWithoutEgg_groupInput[]
    upsert?: PokemonEggGroupUpsertWithWhereUniqueWithoutEgg_groupInput | PokemonEggGroupUpsertWithWhereUniqueWithoutEgg_groupInput[]
    createMany?: PokemonEggGroupCreateManyEgg_groupInputEnvelope
    set?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
    disconnect?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
    delete?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
    connect?: PokemonEggGroupWhereUniqueInput | PokemonEggGroupWhereUniqueInput[]
    update?: PokemonEggGroupUpdateWithWhereUniqueWithoutEgg_groupInput | PokemonEggGroupUpdateWithWhereUniqueWithoutEgg_groupInput[]
    updateMany?: PokemonEggGroupUpdateManyWithWhereWithoutEgg_groupInput | PokemonEggGroupUpdateManyWithWhereWithoutEgg_groupInput[]
    deleteMany?: PokemonEggGroupScalarWhereInput | PokemonEggGroupScalarWhereInput[]
  }

  export type PokemonCreateNestedOneWithoutEgg_groupsInput = {
    create?: XOR<PokemonCreateWithoutEgg_groupsInput, PokemonUncheckedCreateWithoutEgg_groupsInput>
    connectOrCreate?: PokemonCreateOrConnectWithoutEgg_groupsInput
    connect?: PokemonWhereUniqueInput
  }

  export type EggGroupCreateNestedOneWithoutPokemon_egg_groupInput = {
    create?: XOR<EggGroupCreateWithoutPokemon_egg_groupInput, EggGroupUncheckedCreateWithoutPokemon_egg_groupInput>
    connectOrCreate?: EggGroupCreateOrConnectWithoutPokemon_egg_groupInput
    connect?: EggGroupWhereUniqueInput
  }

  export type PokemonUpdateOneRequiredWithoutEgg_groupsNestedInput = {
    create?: XOR<PokemonCreateWithoutEgg_groupsInput, PokemonUncheckedCreateWithoutEgg_groupsInput>
    connectOrCreate?: PokemonCreateOrConnectWithoutEgg_groupsInput
    upsert?: PokemonUpsertWithoutEgg_groupsInput
    connect?: PokemonWhereUniqueInput
    update?: XOR<XOR<PokemonUpdateToOneWithWhereWithoutEgg_groupsInput, PokemonUpdateWithoutEgg_groupsInput>, PokemonUncheckedUpdateWithoutEgg_groupsInput>
  }

  export type EggGroupUpdateOneRequiredWithoutPokemon_egg_groupNestedInput = {
    create?: XOR<EggGroupCreateWithoutPokemon_egg_groupInput, EggGroupUncheckedCreateWithoutPokemon_egg_groupInput>
    connectOrCreate?: EggGroupCreateOrConnectWithoutPokemon_egg_groupInput
    upsert?: EggGroupUpsertWithoutPokemon_egg_groupInput
    connect?: EggGroupWhereUniqueInput
    update?: XOR<XOR<EggGroupUpdateToOneWithWhereWithoutPokemon_egg_groupInput, EggGroupUpdateWithoutPokemon_egg_groupInput>, EggGroupUncheckedUpdateWithoutPokemon_egg_groupInput>
  }

  export type LocationCreateNestedManyWithoutRegionInput = {
    create?: XOR<LocationCreateWithoutRegionInput, LocationUncheckedCreateWithoutRegionInput> | LocationCreateWithoutRegionInput[] | LocationUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutRegionInput | LocationCreateOrConnectWithoutRegionInput[]
    createMany?: LocationCreateManyRegionInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type VersionGroupRegionCreateNestedManyWithoutRegionInput = {
    create?: XOR<VersionGroupRegionCreateWithoutRegionInput, VersionGroupRegionUncheckedCreateWithoutRegionInput> | VersionGroupRegionCreateWithoutRegionInput[] | VersionGroupRegionUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: VersionGroupRegionCreateOrConnectWithoutRegionInput | VersionGroupRegionCreateOrConnectWithoutRegionInput[]
    createMany?: VersionGroupRegionCreateManyRegionInputEnvelope
    connect?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
  }

  export type GenerationCreateNestedOneWithoutRegionInput = {
    create?: XOR<GenerationCreateWithoutRegionInput, GenerationUncheckedCreateWithoutRegionInput>
    connectOrCreate?: GenerationCreateOrConnectWithoutRegionInput
    connect?: GenerationWhereUniqueInput
  }

  export type PokedexCreateNestedManyWithoutRegionInput = {
    create?: XOR<PokedexCreateWithoutRegionInput, PokedexUncheckedCreateWithoutRegionInput> | PokedexCreateWithoutRegionInput[] | PokedexUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: PokedexCreateOrConnectWithoutRegionInput | PokedexCreateOrConnectWithoutRegionInput[]
    createMany?: PokedexCreateManyRegionInputEnvelope
    connect?: PokedexWhereUniqueInput | PokedexWhereUniqueInput[]
  }

  export type LocationUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<LocationCreateWithoutRegionInput, LocationUncheckedCreateWithoutRegionInput> | LocationCreateWithoutRegionInput[] | LocationUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutRegionInput | LocationCreateOrConnectWithoutRegionInput[]
    createMany?: LocationCreateManyRegionInputEnvelope
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
  }

  export type VersionGroupRegionUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<VersionGroupRegionCreateWithoutRegionInput, VersionGroupRegionUncheckedCreateWithoutRegionInput> | VersionGroupRegionCreateWithoutRegionInput[] | VersionGroupRegionUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: VersionGroupRegionCreateOrConnectWithoutRegionInput | VersionGroupRegionCreateOrConnectWithoutRegionInput[]
    createMany?: VersionGroupRegionCreateManyRegionInputEnvelope
    connect?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
  }

  export type GenerationUncheckedCreateNestedOneWithoutRegionInput = {
    create?: XOR<GenerationCreateWithoutRegionInput, GenerationUncheckedCreateWithoutRegionInput>
    connectOrCreate?: GenerationCreateOrConnectWithoutRegionInput
    connect?: GenerationWhereUniqueInput
  }

  export type PokedexUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<PokedexCreateWithoutRegionInput, PokedexUncheckedCreateWithoutRegionInput> | PokedexCreateWithoutRegionInput[] | PokedexUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: PokedexCreateOrConnectWithoutRegionInput | PokedexCreateOrConnectWithoutRegionInput[]
    createMany?: PokedexCreateManyRegionInputEnvelope
    connect?: PokedexWhereUniqueInput | PokedexWhereUniqueInput[]
  }

  export type LocationUpdateManyWithoutRegionNestedInput = {
    create?: XOR<LocationCreateWithoutRegionInput, LocationUncheckedCreateWithoutRegionInput> | LocationCreateWithoutRegionInput[] | LocationUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutRegionInput | LocationCreateOrConnectWithoutRegionInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutRegionInput | LocationUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: LocationCreateManyRegionInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutRegionInput | LocationUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutRegionInput | LocationUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type VersionGroupRegionUpdateManyWithoutRegionNestedInput = {
    create?: XOR<VersionGroupRegionCreateWithoutRegionInput, VersionGroupRegionUncheckedCreateWithoutRegionInput> | VersionGroupRegionCreateWithoutRegionInput[] | VersionGroupRegionUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: VersionGroupRegionCreateOrConnectWithoutRegionInput | VersionGroupRegionCreateOrConnectWithoutRegionInput[]
    upsert?: VersionGroupRegionUpsertWithWhereUniqueWithoutRegionInput | VersionGroupRegionUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: VersionGroupRegionCreateManyRegionInputEnvelope
    set?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
    disconnect?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
    delete?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
    connect?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
    update?: VersionGroupRegionUpdateWithWhereUniqueWithoutRegionInput | VersionGroupRegionUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: VersionGroupRegionUpdateManyWithWhereWithoutRegionInput | VersionGroupRegionUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: VersionGroupRegionScalarWhereInput | VersionGroupRegionScalarWhereInput[]
  }

  export type GenerationUpdateOneWithoutRegionNestedInput = {
    create?: XOR<GenerationCreateWithoutRegionInput, GenerationUncheckedCreateWithoutRegionInput>
    connectOrCreate?: GenerationCreateOrConnectWithoutRegionInput
    upsert?: GenerationUpsertWithoutRegionInput
    disconnect?: GenerationWhereInput | boolean
    delete?: GenerationWhereInput | boolean
    connect?: GenerationWhereUniqueInput
    update?: XOR<XOR<GenerationUpdateToOneWithWhereWithoutRegionInput, GenerationUpdateWithoutRegionInput>, GenerationUncheckedUpdateWithoutRegionInput>
  }

  export type PokedexUpdateManyWithoutRegionNestedInput = {
    create?: XOR<PokedexCreateWithoutRegionInput, PokedexUncheckedCreateWithoutRegionInput> | PokedexCreateWithoutRegionInput[] | PokedexUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: PokedexCreateOrConnectWithoutRegionInput | PokedexCreateOrConnectWithoutRegionInput[]
    upsert?: PokedexUpsertWithWhereUniqueWithoutRegionInput | PokedexUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: PokedexCreateManyRegionInputEnvelope
    set?: PokedexWhereUniqueInput | PokedexWhereUniqueInput[]
    disconnect?: PokedexWhereUniqueInput | PokedexWhereUniqueInput[]
    delete?: PokedexWhereUniqueInput | PokedexWhereUniqueInput[]
    connect?: PokedexWhereUniqueInput | PokedexWhereUniqueInput[]
    update?: PokedexUpdateWithWhereUniqueWithoutRegionInput | PokedexUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: PokedexUpdateManyWithWhereWithoutRegionInput | PokedexUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: PokedexScalarWhereInput | PokedexScalarWhereInput[]
  }

  export type LocationUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<LocationCreateWithoutRegionInput, LocationUncheckedCreateWithoutRegionInput> | LocationCreateWithoutRegionInput[] | LocationUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: LocationCreateOrConnectWithoutRegionInput | LocationCreateOrConnectWithoutRegionInput[]
    upsert?: LocationUpsertWithWhereUniqueWithoutRegionInput | LocationUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: LocationCreateManyRegionInputEnvelope
    set?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    disconnect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    delete?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    connect?: LocationWhereUniqueInput | LocationWhereUniqueInput[]
    update?: LocationUpdateWithWhereUniqueWithoutRegionInput | LocationUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: LocationUpdateManyWithWhereWithoutRegionInput | LocationUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: LocationScalarWhereInput | LocationScalarWhereInput[]
  }

  export type VersionGroupRegionUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<VersionGroupRegionCreateWithoutRegionInput, VersionGroupRegionUncheckedCreateWithoutRegionInput> | VersionGroupRegionCreateWithoutRegionInput[] | VersionGroupRegionUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: VersionGroupRegionCreateOrConnectWithoutRegionInput | VersionGroupRegionCreateOrConnectWithoutRegionInput[]
    upsert?: VersionGroupRegionUpsertWithWhereUniqueWithoutRegionInput | VersionGroupRegionUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: VersionGroupRegionCreateManyRegionInputEnvelope
    set?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
    disconnect?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
    delete?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
    connect?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
    update?: VersionGroupRegionUpdateWithWhereUniqueWithoutRegionInput | VersionGroupRegionUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: VersionGroupRegionUpdateManyWithWhereWithoutRegionInput | VersionGroupRegionUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: VersionGroupRegionScalarWhereInput | VersionGroupRegionScalarWhereInput[]
  }

  export type GenerationUncheckedUpdateOneWithoutRegionNestedInput = {
    create?: XOR<GenerationCreateWithoutRegionInput, GenerationUncheckedCreateWithoutRegionInput>
    connectOrCreate?: GenerationCreateOrConnectWithoutRegionInput
    upsert?: GenerationUpsertWithoutRegionInput
    disconnect?: GenerationWhereInput | boolean
    delete?: GenerationWhereInput | boolean
    connect?: GenerationWhereUniqueInput
    update?: XOR<XOR<GenerationUpdateToOneWithWhereWithoutRegionInput, GenerationUpdateWithoutRegionInput>, GenerationUncheckedUpdateWithoutRegionInput>
  }

  export type PokedexUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<PokedexCreateWithoutRegionInput, PokedexUncheckedCreateWithoutRegionInput> | PokedexCreateWithoutRegionInput[] | PokedexUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: PokedexCreateOrConnectWithoutRegionInput | PokedexCreateOrConnectWithoutRegionInput[]
    upsert?: PokedexUpsertWithWhereUniqueWithoutRegionInput | PokedexUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: PokedexCreateManyRegionInputEnvelope
    set?: PokedexWhereUniqueInput | PokedexWhereUniqueInput[]
    disconnect?: PokedexWhereUniqueInput | PokedexWhereUniqueInput[]
    delete?: PokedexWhereUniqueInput | PokedexWhereUniqueInput[]
    connect?: PokedexWhereUniqueInput | PokedexWhereUniqueInput[]
    update?: PokedexUpdateWithWhereUniqueWithoutRegionInput | PokedexUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: PokedexUpdateManyWithWhereWithoutRegionInput | PokedexUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: PokedexScalarWhereInput | PokedexScalarWhereInput[]
  }

  export type RegionCreateNestedOneWithoutGenerationsInput = {
    create?: XOR<RegionCreateWithoutGenerationsInput, RegionUncheckedCreateWithoutGenerationsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutGenerationsInput
    connect?: RegionWhereUniqueInput
  }

  export type TypeCreateNestedManyWithoutGenerationInput = {
    create?: XOR<TypeCreateWithoutGenerationInput, TypeUncheckedCreateWithoutGenerationInput> | TypeCreateWithoutGenerationInput[] | TypeUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: TypeCreateOrConnectWithoutGenerationInput | TypeCreateOrConnectWithoutGenerationInput[]
    createMany?: TypeCreateManyGenerationInputEnvelope
    connect?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
  }

  export type VersionGroupCreateNestedManyWithoutGenerationInput = {
    create?: XOR<VersionGroupCreateWithoutGenerationInput, VersionGroupUncheckedCreateWithoutGenerationInput> | VersionGroupCreateWithoutGenerationInput[] | VersionGroupUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: VersionGroupCreateOrConnectWithoutGenerationInput | VersionGroupCreateOrConnectWithoutGenerationInput[]
    createMany?: VersionGroupCreateManyGenerationInputEnvelope
    connect?: VersionGroupWhereUniqueInput | VersionGroupWhereUniqueInput[]
  }

  export type TypeUncheckedCreateNestedManyWithoutGenerationInput = {
    create?: XOR<TypeCreateWithoutGenerationInput, TypeUncheckedCreateWithoutGenerationInput> | TypeCreateWithoutGenerationInput[] | TypeUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: TypeCreateOrConnectWithoutGenerationInput | TypeCreateOrConnectWithoutGenerationInput[]
    createMany?: TypeCreateManyGenerationInputEnvelope
    connect?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
  }

  export type VersionGroupUncheckedCreateNestedManyWithoutGenerationInput = {
    create?: XOR<VersionGroupCreateWithoutGenerationInput, VersionGroupUncheckedCreateWithoutGenerationInput> | VersionGroupCreateWithoutGenerationInput[] | VersionGroupUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: VersionGroupCreateOrConnectWithoutGenerationInput | VersionGroupCreateOrConnectWithoutGenerationInput[]
    createMany?: VersionGroupCreateManyGenerationInputEnvelope
    connect?: VersionGroupWhereUniqueInput | VersionGroupWhereUniqueInput[]
  }

  export type RegionUpdateOneRequiredWithoutGenerationsNestedInput = {
    create?: XOR<RegionCreateWithoutGenerationsInput, RegionUncheckedCreateWithoutGenerationsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutGenerationsInput
    upsert?: RegionUpsertWithoutGenerationsInput
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutGenerationsInput, RegionUpdateWithoutGenerationsInput>, RegionUncheckedUpdateWithoutGenerationsInput>
  }

  export type TypeUpdateManyWithoutGenerationNestedInput = {
    create?: XOR<TypeCreateWithoutGenerationInput, TypeUncheckedCreateWithoutGenerationInput> | TypeCreateWithoutGenerationInput[] | TypeUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: TypeCreateOrConnectWithoutGenerationInput | TypeCreateOrConnectWithoutGenerationInput[]
    upsert?: TypeUpsertWithWhereUniqueWithoutGenerationInput | TypeUpsertWithWhereUniqueWithoutGenerationInput[]
    createMany?: TypeCreateManyGenerationInputEnvelope
    set?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
    disconnect?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
    delete?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
    connect?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
    update?: TypeUpdateWithWhereUniqueWithoutGenerationInput | TypeUpdateWithWhereUniqueWithoutGenerationInput[]
    updateMany?: TypeUpdateManyWithWhereWithoutGenerationInput | TypeUpdateManyWithWhereWithoutGenerationInput[]
    deleteMany?: TypeScalarWhereInput | TypeScalarWhereInput[]
  }

  export type VersionGroupUpdateManyWithoutGenerationNestedInput = {
    create?: XOR<VersionGroupCreateWithoutGenerationInput, VersionGroupUncheckedCreateWithoutGenerationInput> | VersionGroupCreateWithoutGenerationInput[] | VersionGroupUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: VersionGroupCreateOrConnectWithoutGenerationInput | VersionGroupCreateOrConnectWithoutGenerationInput[]
    upsert?: VersionGroupUpsertWithWhereUniqueWithoutGenerationInput | VersionGroupUpsertWithWhereUniqueWithoutGenerationInput[]
    createMany?: VersionGroupCreateManyGenerationInputEnvelope
    set?: VersionGroupWhereUniqueInput | VersionGroupWhereUniqueInput[]
    disconnect?: VersionGroupWhereUniqueInput | VersionGroupWhereUniqueInput[]
    delete?: VersionGroupWhereUniqueInput | VersionGroupWhereUniqueInput[]
    connect?: VersionGroupWhereUniqueInput | VersionGroupWhereUniqueInput[]
    update?: VersionGroupUpdateWithWhereUniqueWithoutGenerationInput | VersionGroupUpdateWithWhereUniqueWithoutGenerationInput[]
    updateMany?: VersionGroupUpdateManyWithWhereWithoutGenerationInput | VersionGroupUpdateManyWithWhereWithoutGenerationInput[]
    deleteMany?: VersionGroupScalarWhereInput | VersionGroupScalarWhereInput[]
  }

  export type TypeUncheckedUpdateManyWithoutGenerationNestedInput = {
    create?: XOR<TypeCreateWithoutGenerationInput, TypeUncheckedCreateWithoutGenerationInput> | TypeCreateWithoutGenerationInput[] | TypeUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: TypeCreateOrConnectWithoutGenerationInput | TypeCreateOrConnectWithoutGenerationInput[]
    upsert?: TypeUpsertWithWhereUniqueWithoutGenerationInput | TypeUpsertWithWhereUniqueWithoutGenerationInput[]
    createMany?: TypeCreateManyGenerationInputEnvelope
    set?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
    disconnect?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
    delete?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
    connect?: TypeWhereUniqueInput | TypeWhereUniqueInput[]
    update?: TypeUpdateWithWhereUniqueWithoutGenerationInput | TypeUpdateWithWhereUniqueWithoutGenerationInput[]
    updateMany?: TypeUpdateManyWithWhereWithoutGenerationInput | TypeUpdateManyWithWhereWithoutGenerationInput[]
    deleteMany?: TypeScalarWhereInput | TypeScalarWhereInput[]
  }

  export type VersionGroupUncheckedUpdateManyWithoutGenerationNestedInput = {
    create?: XOR<VersionGroupCreateWithoutGenerationInput, VersionGroupUncheckedCreateWithoutGenerationInput> | VersionGroupCreateWithoutGenerationInput[] | VersionGroupUncheckedCreateWithoutGenerationInput[]
    connectOrCreate?: VersionGroupCreateOrConnectWithoutGenerationInput | VersionGroupCreateOrConnectWithoutGenerationInput[]
    upsert?: VersionGroupUpsertWithWhereUniqueWithoutGenerationInput | VersionGroupUpsertWithWhereUniqueWithoutGenerationInput[]
    createMany?: VersionGroupCreateManyGenerationInputEnvelope
    set?: VersionGroupWhereUniqueInput | VersionGroupWhereUniqueInput[]
    disconnect?: VersionGroupWhereUniqueInput | VersionGroupWhereUniqueInput[]
    delete?: VersionGroupWhereUniqueInput | VersionGroupWhereUniqueInput[]
    connect?: VersionGroupWhereUniqueInput | VersionGroupWhereUniqueInput[]
    update?: VersionGroupUpdateWithWhereUniqueWithoutGenerationInput | VersionGroupUpdateWithWhereUniqueWithoutGenerationInput[]
    updateMany?: VersionGroupUpdateManyWithWhereWithoutGenerationInput | VersionGroupUpdateManyWithWhereWithoutGenerationInput[]
    deleteMany?: VersionGroupScalarWhereInput | VersionGroupScalarWhereInput[]
  }

  export type GenerationCreateNestedOneWithoutVersionGroupsInput = {
    create?: XOR<GenerationCreateWithoutVersionGroupsInput, GenerationUncheckedCreateWithoutVersionGroupsInput>
    connectOrCreate?: GenerationCreateOrConnectWithoutVersionGroupsInput
    connect?: GenerationWhereUniqueInput
  }

  export type VersionCreateNestedManyWithoutVersionGroupInput = {
    create?: XOR<VersionCreateWithoutVersionGroupInput, VersionUncheckedCreateWithoutVersionGroupInput> | VersionCreateWithoutVersionGroupInput[] | VersionUncheckedCreateWithoutVersionGroupInput[]
    connectOrCreate?: VersionCreateOrConnectWithoutVersionGroupInput | VersionCreateOrConnectWithoutVersionGroupInput[]
    createMany?: VersionCreateManyVersionGroupInputEnvelope
    connect?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
  }

  export type VersionGroupRegionCreateNestedManyWithoutVersion_groupInput = {
    create?: XOR<VersionGroupRegionCreateWithoutVersion_groupInput, VersionGroupRegionUncheckedCreateWithoutVersion_groupInput> | VersionGroupRegionCreateWithoutVersion_groupInput[] | VersionGroupRegionUncheckedCreateWithoutVersion_groupInput[]
    connectOrCreate?: VersionGroupRegionCreateOrConnectWithoutVersion_groupInput | VersionGroupRegionCreateOrConnectWithoutVersion_groupInput[]
    createMany?: VersionGroupRegionCreateManyVersion_groupInputEnvelope
    connect?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
  }

  export type EncounterSlotCreateNestedManyWithoutVersion_groupInput = {
    create?: XOR<EncounterSlotCreateWithoutVersion_groupInput, EncounterSlotUncheckedCreateWithoutVersion_groupInput> | EncounterSlotCreateWithoutVersion_groupInput[] | EncounterSlotUncheckedCreateWithoutVersion_groupInput[]
    connectOrCreate?: EncounterSlotCreateOrConnectWithoutVersion_groupInput | EncounterSlotCreateOrConnectWithoutVersion_groupInput[]
    createMany?: EncounterSlotCreateManyVersion_groupInputEnvelope
    connect?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
  }

  export type PokemonMoveCreateNestedManyWithoutVersion_groupInput = {
    create?: XOR<PokemonMoveCreateWithoutVersion_groupInput, PokemonMoveUncheckedCreateWithoutVersion_groupInput> | PokemonMoveCreateWithoutVersion_groupInput[] | PokemonMoveUncheckedCreateWithoutVersion_groupInput[]
    connectOrCreate?: PokemonMoveCreateOrConnectWithoutVersion_groupInput | PokemonMoveCreateOrConnectWithoutVersion_groupInput[]
    createMany?: PokemonMoveCreateManyVersion_groupInputEnvelope
    connect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
  }

  export type PokedexVersionGroupCreateNestedManyWithoutVersion_groupInput = {
    create?: XOR<PokedexVersionGroupCreateWithoutVersion_groupInput, PokedexVersionGroupUncheckedCreateWithoutVersion_groupInput> | PokedexVersionGroupCreateWithoutVersion_groupInput[] | PokedexVersionGroupUncheckedCreateWithoutVersion_groupInput[]
    connectOrCreate?: PokedexVersionGroupCreateOrConnectWithoutVersion_groupInput | PokedexVersionGroupCreateOrConnectWithoutVersion_groupInput[]
    createMany?: PokedexVersionGroupCreateManyVersion_groupInputEnvelope
    connect?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
  }

  export type VersionUncheckedCreateNestedManyWithoutVersionGroupInput = {
    create?: XOR<VersionCreateWithoutVersionGroupInput, VersionUncheckedCreateWithoutVersionGroupInput> | VersionCreateWithoutVersionGroupInput[] | VersionUncheckedCreateWithoutVersionGroupInput[]
    connectOrCreate?: VersionCreateOrConnectWithoutVersionGroupInput | VersionCreateOrConnectWithoutVersionGroupInput[]
    createMany?: VersionCreateManyVersionGroupInputEnvelope
    connect?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
  }

  export type VersionGroupRegionUncheckedCreateNestedManyWithoutVersion_groupInput = {
    create?: XOR<VersionGroupRegionCreateWithoutVersion_groupInput, VersionGroupRegionUncheckedCreateWithoutVersion_groupInput> | VersionGroupRegionCreateWithoutVersion_groupInput[] | VersionGroupRegionUncheckedCreateWithoutVersion_groupInput[]
    connectOrCreate?: VersionGroupRegionCreateOrConnectWithoutVersion_groupInput | VersionGroupRegionCreateOrConnectWithoutVersion_groupInput[]
    createMany?: VersionGroupRegionCreateManyVersion_groupInputEnvelope
    connect?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
  }

  export type EncounterSlotUncheckedCreateNestedManyWithoutVersion_groupInput = {
    create?: XOR<EncounterSlotCreateWithoutVersion_groupInput, EncounterSlotUncheckedCreateWithoutVersion_groupInput> | EncounterSlotCreateWithoutVersion_groupInput[] | EncounterSlotUncheckedCreateWithoutVersion_groupInput[]
    connectOrCreate?: EncounterSlotCreateOrConnectWithoutVersion_groupInput | EncounterSlotCreateOrConnectWithoutVersion_groupInput[]
    createMany?: EncounterSlotCreateManyVersion_groupInputEnvelope
    connect?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
  }

  export type PokemonMoveUncheckedCreateNestedManyWithoutVersion_groupInput = {
    create?: XOR<PokemonMoveCreateWithoutVersion_groupInput, PokemonMoveUncheckedCreateWithoutVersion_groupInput> | PokemonMoveCreateWithoutVersion_groupInput[] | PokemonMoveUncheckedCreateWithoutVersion_groupInput[]
    connectOrCreate?: PokemonMoveCreateOrConnectWithoutVersion_groupInput | PokemonMoveCreateOrConnectWithoutVersion_groupInput[]
    createMany?: PokemonMoveCreateManyVersion_groupInputEnvelope
    connect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
  }

  export type PokedexVersionGroupUncheckedCreateNestedManyWithoutVersion_groupInput = {
    create?: XOR<PokedexVersionGroupCreateWithoutVersion_groupInput, PokedexVersionGroupUncheckedCreateWithoutVersion_groupInput> | PokedexVersionGroupCreateWithoutVersion_groupInput[] | PokedexVersionGroupUncheckedCreateWithoutVersion_groupInput[]
    connectOrCreate?: PokedexVersionGroupCreateOrConnectWithoutVersion_groupInput | PokedexVersionGroupCreateOrConnectWithoutVersion_groupInput[]
    createMany?: PokedexVersionGroupCreateManyVersion_groupInputEnvelope
    connect?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
  }

  export type GenerationUpdateOneRequiredWithoutVersionGroupsNestedInput = {
    create?: XOR<GenerationCreateWithoutVersionGroupsInput, GenerationUncheckedCreateWithoutVersionGroupsInput>
    connectOrCreate?: GenerationCreateOrConnectWithoutVersionGroupsInput
    upsert?: GenerationUpsertWithoutVersionGroupsInput
    connect?: GenerationWhereUniqueInput
    update?: XOR<XOR<GenerationUpdateToOneWithWhereWithoutVersionGroupsInput, GenerationUpdateWithoutVersionGroupsInput>, GenerationUncheckedUpdateWithoutVersionGroupsInput>
  }

  export type VersionUpdateManyWithoutVersionGroupNestedInput = {
    create?: XOR<VersionCreateWithoutVersionGroupInput, VersionUncheckedCreateWithoutVersionGroupInput> | VersionCreateWithoutVersionGroupInput[] | VersionUncheckedCreateWithoutVersionGroupInput[]
    connectOrCreate?: VersionCreateOrConnectWithoutVersionGroupInput | VersionCreateOrConnectWithoutVersionGroupInput[]
    upsert?: VersionUpsertWithWhereUniqueWithoutVersionGroupInput | VersionUpsertWithWhereUniqueWithoutVersionGroupInput[]
    createMany?: VersionCreateManyVersionGroupInputEnvelope
    set?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    disconnect?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    delete?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    connect?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    update?: VersionUpdateWithWhereUniqueWithoutVersionGroupInput | VersionUpdateWithWhereUniqueWithoutVersionGroupInput[]
    updateMany?: VersionUpdateManyWithWhereWithoutVersionGroupInput | VersionUpdateManyWithWhereWithoutVersionGroupInput[]
    deleteMany?: VersionScalarWhereInput | VersionScalarWhereInput[]
  }

  export type VersionGroupRegionUpdateManyWithoutVersion_groupNestedInput = {
    create?: XOR<VersionGroupRegionCreateWithoutVersion_groupInput, VersionGroupRegionUncheckedCreateWithoutVersion_groupInput> | VersionGroupRegionCreateWithoutVersion_groupInput[] | VersionGroupRegionUncheckedCreateWithoutVersion_groupInput[]
    connectOrCreate?: VersionGroupRegionCreateOrConnectWithoutVersion_groupInput | VersionGroupRegionCreateOrConnectWithoutVersion_groupInput[]
    upsert?: VersionGroupRegionUpsertWithWhereUniqueWithoutVersion_groupInput | VersionGroupRegionUpsertWithWhereUniqueWithoutVersion_groupInput[]
    createMany?: VersionGroupRegionCreateManyVersion_groupInputEnvelope
    set?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
    disconnect?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
    delete?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
    connect?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
    update?: VersionGroupRegionUpdateWithWhereUniqueWithoutVersion_groupInput | VersionGroupRegionUpdateWithWhereUniqueWithoutVersion_groupInput[]
    updateMany?: VersionGroupRegionUpdateManyWithWhereWithoutVersion_groupInput | VersionGroupRegionUpdateManyWithWhereWithoutVersion_groupInput[]
    deleteMany?: VersionGroupRegionScalarWhereInput | VersionGroupRegionScalarWhereInput[]
  }

  export type EncounterSlotUpdateManyWithoutVersion_groupNestedInput = {
    create?: XOR<EncounterSlotCreateWithoutVersion_groupInput, EncounterSlotUncheckedCreateWithoutVersion_groupInput> | EncounterSlotCreateWithoutVersion_groupInput[] | EncounterSlotUncheckedCreateWithoutVersion_groupInput[]
    connectOrCreate?: EncounterSlotCreateOrConnectWithoutVersion_groupInput | EncounterSlotCreateOrConnectWithoutVersion_groupInput[]
    upsert?: EncounterSlotUpsertWithWhereUniqueWithoutVersion_groupInput | EncounterSlotUpsertWithWhereUniqueWithoutVersion_groupInput[]
    createMany?: EncounterSlotCreateManyVersion_groupInputEnvelope
    set?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
    disconnect?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
    delete?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
    connect?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
    update?: EncounterSlotUpdateWithWhereUniqueWithoutVersion_groupInput | EncounterSlotUpdateWithWhereUniqueWithoutVersion_groupInput[]
    updateMany?: EncounterSlotUpdateManyWithWhereWithoutVersion_groupInput | EncounterSlotUpdateManyWithWhereWithoutVersion_groupInput[]
    deleteMany?: EncounterSlotScalarWhereInput | EncounterSlotScalarWhereInput[]
  }

  export type PokemonMoveUpdateManyWithoutVersion_groupNestedInput = {
    create?: XOR<PokemonMoveCreateWithoutVersion_groupInput, PokemonMoveUncheckedCreateWithoutVersion_groupInput> | PokemonMoveCreateWithoutVersion_groupInput[] | PokemonMoveUncheckedCreateWithoutVersion_groupInput[]
    connectOrCreate?: PokemonMoveCreateOrConnectWithoutVersion_groupInput | PokemonMoveCreateOrConnectWithoutVersion_groupInput[]
    upsert?: PokemonMoveUpsertWithWhereUniqueWithoutVersion_groupInput | PokemonMoveUpsertWithWhereUniqueWithoutVersion_groupInput[]
    createMany?: PokemonMoveCreateManyVersion_groupInputEnvelope
    set?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    disconnect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    delete?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    connect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    update?: PokemonMoveUpdateWithWhereUniqueWithoutVersion_groupInput | PokemonMoveUpdateWithWhereUniqueWithoutVersion_groupInput[]
    updateMany?: PokemonMoveUpdateManyWithWhereWithoutVersion_groupInput | PokemonMoveUpdateManyWithWhereWithoutVersion_groupInput[]
    deleteMany?: PokemonMoveScalarWhereInput | PokemonMoveScalarWhereInput[]
  }

  export type PokedexVersionGroupUpdateManyWithoutVersion_groupNestedInput = {
    create?: XOR<PokedexVersionGroupCreateWithoutVersion_groupInput, PokedexVersionGroupUncheckedCreateWithoutVersion_groupInput> | PokedexVersionGroupCreateWithoutVersion_groupInput[] | PokedexVersionGroupUncheckedCreateWithoutVersion_groupInput[]
    connectOrCreate?: PokedexVersionGroupCreateOrConnectWithoutVersion_groupInput | PokedexVersionGroupCreateOrConnectWithoutVersion_groupInput[]
    upsert?: PokedexVersionGroupUpsertWithWhereUniqueWithoutVersion_groupInput | PokedexVersionGroupUpsertWithWhereUniqueWithoutVersion_groupInput[]
    createMany?: PokedexVersionGroupCreateManyVersion_groupInputEnvelope
    set?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
    disconnect?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
    delete?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
    connect?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
    update?: PokedexVersionGroupUpdateWithWhereUniqueWithoutVersion_groupInput | PokedexVersionGroupUpdateWithWhereUniqueWithoutVersion_groupInput[]
    updateMany?: PokedexVersionGroupUpdateManyWithWhereWithoutVersion_groupInput | PokedexVersionGroupUpdateManyWithWhereWithoutVersion_groupInput[]
    deleteMany?: PokedexVersionGroupScalarWhereInput | PokedexVersionGroupScalarWhereInput[]
  }

  export type VersionUncheckedUpdateManyWithoutVersionGroupNestedInput = {
    create?: XOR<VersionCreateWithoutVersionGroupInput, VersionUncheckedCreateWithoutVersionGroupInput> | VersionCreateWithoutVersionGroupInput[] | VersionUncheckedCreateWithoutVersionGroupInput[]
    connectOrCreate?: VersionCreateOrConnectWithoutVersionGroupInput | VersionCreateOrConnectWithoutVersionGroupInput[]
    upsert?: VersionUpsertWithWhereUniqueWithoutVersionGroupInput | VersionUpsertWithWhereUniqueWithoutVersionGroupInput[]
    createMany?: VersionCreateManyVersionGroupInputEnvelope
    set?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    disconnect?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    delete?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    connect?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    update?: VersionUpdateWithWhereUniqueWithoutVersionGroupInput | VersionUpdateWithWhereUniqueWithoutVersionGroupInput[]
    updateMany?: VersionUpdateManyWithWhereWithoutVersionGroupInput | VersionUpdateManyWithWhereWithoutVersionGroupInput[]
    deleteMany?: VersionScalarWhereInput | VersionScalarWhereInput[]
  }

  export type VersionGroupRegionUncheckedUpdateManyWithoutVersion_groupNestedInput = {
    create?: XOR<VersionGroupRegionCreateWithoutVersion_groupInput, VersionGroupRegionUncheckedCreateWithoutVersion_groupInput> | VersionGroupRegionCreateWithoutVersion_groupInput[] | VersionGroupRegionUncheckedCreateWithoutVersion_groupInput[]
    connectOrCreate?: VersionGroupRegionCreateOrConnectWithoutVersion_groupInput | VersionGroupRegionCreateOrConnectWithoutVersion_groupInput[]
    upsert?: VersionGroupRegionUpsertWithWhereUniqueWithoutVersion_groupInput | VersionGroupRegionUpsertWithWhereUniqueWithoutVersion_groupInput[]
    createMany?: VersionGroupRegionCreateManyVersion_groupInputEnvelope
    set?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
    disconnect?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
    delete?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
    connect?: VersionGroupRegionWhereUniqueInput | VersionGroupRegionWhereUniqueInput[]
    update?: VersionGroupRegionUpdateWithWhereUniqueWithoutVersion_groupInput | VersionGroupRegionUpdateWithWhereUniqueWithoutVersion_groupInput[]
    updateMany?: VersionGroupRegionUpdateManyWithWhereWithoutVersion_groupInput | VersionGroupRegionUpdateManyWithWhereWithoutVersion_groupInput[]
    deleteMany?: VersionGroupRegionScalarWhereInput | VersionGroupRegionScalarWhereInput[]
  }

  export type EncounterSlotUncheckedUpdateManyWithoutVersion_groupNestedInput = {
    create?: XOR<EncounterSlotCreateWithoutVersion_groupInput, EncounterSlotUncheckedCreateWithoutVersion_groupInput> | EncounterSlotCreateWithoutVersion_groupInput[] | EncounterSlotUncheckedCreateWithoutVersion_groupInput[]
    connectOrCreate?: EncounterSlotCreateOrConnectWithoutVersion_groupInput | EncounterSlotCreateOrConnectWithoutVersion_groupInput[]
    upsert?: EncounterSlotUpsertWithWhereUniqueWithoutVersion_groupInput | EncounterSlotUpsertWithWhereUniqueWithoutVersion_groupInput[]
    createMany?: EncounterSlotCreateManyVersion_groupInputEnvelope
    set?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
    disconnect?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
    delete?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
    connect?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
    update?: EncounterSlotUpdateWithWhereUniqueWithoutVersion_groupInput | EncounterSlotUpdateWithWhereUniqueWithoutVersion_groupInput[]
    updateMany?: EncounterSlotUpdateManyWithWhereWithoutVersion_groupInput | EncounterSlotUpdateManyWithWhereWithoutVersion_groupInput[]
    deleteMany?: EncounterSlotScalarWhereInput | EncounterSlotScalarWhereInput[]
  }

  export type PokemonMoveUncheckedUpdateManyWithoutVersion_groupNestedInput = {
    create?: XOR<PokemonMoveCreateWithoutVersion_groupInput, PokemonMoveUncheckedCreateWithoutVersion_groupInput> | PokemonMoveCreateWithoutVersion_groupInput[] | PokemonMoveUncheckedCreateWithoutVersion_groupInput[]
    connectOrCreate?: PokemonMoveCreateOrConnectWithoutVersion_groupInput | PokemonMoveCreateOrConnectWithoutVersion_groupInput[]
    upsert?: PokemonMoveUpsertWithWhereUniqueWithoutVersion_groupInput | PokemonMoveUpsertWithWhereUniqueWithoutVersion_groupInput[]
    createMany?: PokemonMoveCreateManyVersion_groupInputEnvelope
    set?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    disconnect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    delete?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    connect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    update?: PokemonMoveUpdateWithWhereUniqueWithoutVersion_groupInput | PokemonMoveUpdateWithWhereUniqueWithoutVersion_groupInput[]
    updateMany?: PokemonMoveUpdateManyWithWhereWithoutVersion_groupInput | PokemonMoveUpdateManyWithWhereWithoutVersion_groupInput[]
    deleteMany?: PokemonMoveScalarWhereInput | PokemonMoveScalarWhereInput[]
  }

  export type PokedexVersionGroupUncheckedUpdateManyWithoutVersion_groupNestedInput = {
    create?: XOR<PokedexVersionGroupCreateWithoutVersion_groupInput, PokedexVersionGroupUncheckedCreateWithoutVersion_groupInput> | PokedexVersionGroupCreateWithoutVersion_groupInput[] | PokedexVersionGroupUncheckedCreateWithoutVersion_groupInput[]
    connectOrCreate?: PokedexVersionGroupCreateOrConnectWithoutVersion_groupInput | PokedexVersionGroupCreateOrConnectWithoutVersion_groupInput[]
    upsert?: PokedexVersionGroupUpsertWithWhereUniqueWithoutVersion_groupInput | PokedexVersionGroupUpsertWithWhereUniqueWithoutVersion_groupInput[]
    createMany?: PokedexVersionGroupCreateManyVersion_groupInputEnvelope
    set?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
    disconnect?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
    delete?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
    connect?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
    update?: PokedexVersionGroupUpdateWithWhereUniqueWithoutVersion_groupInput | PokedexVersionGroupUpdateWithWhereUniqueWithoutVersion_groupInput[]
    updateMany?: PokedexVersionGroupUpdateManyWithWhereWithoutVersion_groupInput | PokedexVersionGroupUpdateManyWithWhereWithoutVersion_groupInput[]
    deleteMany?: PokedexVersionGroupScalarWhereInput | PokedexVersionGroupScalarWhereInput[]
  }

  export type RegionCreateNestedOneWithoutVersion_groupsInput = {
    create?: XOR<RegionCreateWithoutVersion_groupsInput, RegionUncheckedCreateWithoutVersion_groupsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutVersion_groupsInput
    connect?: RegionWhereUniqueInput
  }

  export type VersionGroupCreateNestedOneWithoutRegionsInput = {
    create?: XOR<VersionGroupCreateWithoutRegionsInput, VersionGroupUncheckedCreateWithoutRegionsInput>
    connectOrCreate?: VersionGroupCreateOrConnectWithoutRegionsInput
    connect?: VersionGroupWhereUniqueInput
  }

  export type RegionUpdateOneRequiredWithoutVersion_groupsNestedInput = {
    create?: XOR<RegionCreateWithoutVersion_groupsInput, RegionUncheckedCreateWithoutVersion_groupsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutVersion_groupsInput
    upsert?: RegionUpsertWithoutVersion_groupsInput
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutVersion_groupsInput, RegionUpdateWithoutVersion_groupsInput>, RegionUncheckedUpdateWithoutVersion_groupsInput>
  }

  export type VersionGroupUpdateOneRequiredWithoutRegionsNestedInput = {
    create?: XOR<VersionGroupCreateWithoutRegionsInput, VersionGroupUncheckedCreateWithoutRegionsInput>
    connectOrCreate?: VersionGroupCreateOrConnectWithoutRegionsInput
    upsert?: VersionGroupUpsertWithoutRegionsInput
    connect?: VersionGroupWhereUniqueInput
    update?: XOR<XOR<VersionGroupUpdateToOneWithWhereWithoutRegionsInput, VersionGroupUpdateWithoutRegionsInput>, VersionGroupUncheckedUpdateWithoutRegionsInput>
  }

  export type VersionGroupCreateNestedOneWithoutVersionsInput = {
    create?: XOR<VersionGroupCreateWithoutVersionsInput, VersionGroupUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: VersionGroupCreateOrConnectWithoutVersionsInput
    connect?: VersionGroupWhereUniqueInput
  }

  export type EncounterCreateNestedManyWithoutVersionInput = {
    create?: XOR<EncounterCreateWithoutVersionInput, EncounterUncheckedCreateWithoutVersionInput> | EncounterCreateWithoutVersionInput[] | EncounterUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutVersionInput | EncounterCreateOrConnectWithoutVersionInput[]
    createMany?: EncounterCreateManyVersionInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type LocationAreaEncounterRateCreateNestedManyWithoutVersionInput = {
    create?: XOR<LocationAreaEncounterRateCreateWithoutVersionInput, LocationAreaEncounterRateUncheckedCreateWithoutVersionInput> | LocationAreaEncounterRateCreateWithoutVersionInput[] | LocationAreaEncounterRateUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: LocationAreaEncounterRateCreateOrConnectWithoutVersionInput | LocationAreaEncounterRateCreateOrConnectWithoutVersionInput[]
    createMany?: LocationAreaEncounterRateCreateManyVersionInputEnvelope
    connect?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutVersionInput = {
    create?: XOR<EncounterCreateWithoutVersionInput, EncounterUncheckedCreateWithoutVersionInput> | EncounterCreateWithoutVersionInput[] | EncounterUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutVersionInput | EncounterCreateOrConnectWithoutVersionInput[]
    createMany?: EncounterCreateManyVersionInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type LocationAreaEncounterRateUncheckedCreateNestedManyWithoutVersionInput = {
    create?: XOR<LocationAreaEncounterRateCreateWithoutVersionInput, LocationAreaEncounterRateUncheckedCreateWithoutVersionInput> | LocationAreaEncounterRateCreateWithoutVersionInput[] | LocationAreaEncounterRateUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: LocationAreaEncounterRateCreateOrConnectWithoutVersionInput | LocationAreaEncounterRateCreateOrConnectWithoutVersionInput[]
    createMany?: LocationAreaEncounterRateCreateManyVersionInputEnvelope
    connect?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
  }

  export type VersionGroupUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<VersionGroupCreateWithoutVersionsInput, VersionGroupUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: VersionGroupCreateOrConnectWithoutVersionsInput
    upsert?: VersionGroupUpsertWithoutVersionsInput
    connect?: VersionGroupWhereUniqueInput
    update?: XOR<XOR<VersionGroupUpdateToOneWithWhereWithoutVersionsInput, VersionGroupUpdateWithoutVersionsInput>, VersionGroupUncheckedUpdateWithoutVersionsInput>
  }

  export type EncounterUpdateManyWithoutVersionNestedInput = {
    create?: XOR<EncounterCreateWithoutVersionInput, EncounterUncheckedCreateWithoutVersionInput> | EncounterCreateWithoutVersionInput[] | EncounterUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutVersionInput | EncounterCreateOrConnectWithoutVersionInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutVersionInput | EncounterUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: EncounterCreateManyVersionInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutVersionInput | EncounterUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutVersionInput | EncounterUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type LocationAreaEncounterRateUpdateManyWithoutVersionNestedInput = {
    create?: XOR<LocationAreaEncounterRateCreateWithoutVersionInput, LocationAreaEncounterRateUncheckedCreateWithoutVersionInput> | LocationAreaEncounterRateCreateWithoutVersionInput[] | LocationAreaEncounterRateUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: LocationAreaEncounterRateCreateOrConnectWithoutVersionInput | LocationAreaEncounterRateCreateOrConnectWithoutVersionInput[]
    upsert?: LocationAreaEncounterRateUpsertWithWhereUniqueWithoutVersionInput | LocationAreaEncounterRateUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: LocationAreaEncounterRateCreateManyVersionInputEnvelope
    set?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    disconnect?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    delete?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    connect?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    update?: LocationAreaEncounterRateUpdateWithWhereUniqueWithoutVersionInput | LocationAreaEncounterRateUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: LocationAreaEncounterRateUpdateManyWithWhereWithoutVersionInput | LocationAreaEncounterRateUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: LocationAreaEncounterRateScalarWhereInput | LocationAreaEncounterRateScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutVersionNestedInput = {
    create?: XOR<EncounterCreateWithoutVersionInput, EncounterUncheckedCreateWithoutVersionInput> | EncounterCreateWithoutVersionInput[] | EncounterUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutVersionInput | EncounterCreateOrConnectWithoutVersionInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutVersionInput | EncounterUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: EncounterCreateManyVersionInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutVersionInput | EncounterUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutVersionInput | EncounterUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type LocationAreaEncounterRateUncheckedUpdateManyWithoutVersionNestedInput = {
    create?: XOR<LocationAreaEncounterRateCreateWithoutVersionInput, LocationAreaEncounterRateUncheckedCreateWithoutVersionInput> | LocationAreaEncounterRateCreateWithoutVersionInput[] | LocationAreaEncounterRateUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: LocationAreaEncounterRateCreateOrConnectWithoutVersionInput | LocationAreaEncounterRateCreateOrConnectWithoutVersionInput[]
    upsert?: LocationAreaEncounterRateUpsertWithWhereUniqueWithoutVersionInput | LocationAreaEncounterRateUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: LocationAreaEncounterRateCreateManyVersionInputEnvelope
    set?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    disconnect?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    delete?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    connect?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    update?: LocationAreaEncounterRateUpdateWithWhereUniqueWithoutVersionInput | LocationAreaEncounterRateUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: LocationAreaEncounterRateUpdateManyWithWhereWithoutVersionInput | LocationAreaEncounterRateUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: LocationAreaEncounterRateScalarWhereInput | LocationAreaEncounterRateScalarWhereInput[]
  }

  export type RegionCreateNestedOneWithoutLocationsInput = {
    create?: XOR<RegionCreateWithoutLocationsInput, RegionUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutLocationsInput
    connect?: RegionWhereUniqueInput
  }

  export type LocationAreaCreateNestedManyWithoutLocationInput = {
    create?: XOR<LocationAreaCreateWithoutLocationInput, LocationAreaUncheckedCreateWithoutLocationInput> | LocationAreaCreateWithoutLocationInput[] | LocationAreaUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: LocationAreaCreateOrConnectWithoutLocationInput | LocationAreaCreateOrConnectWithoutLocationInput[]
    createMany?: LocationAreaCreateManyLocationInputEnvelope
    connect?: LocationAreaWhereUniqueInput | LocationAreaWhereUniqueInput[]
  }

  export type LocationAreaUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<LocationAreaCreateWithoutLocationInput, LocationAreaUncheckedCreateWithoutLocationInput> | LocationAreaCreateWithoutLocationInput[] | LocationAreaUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: LocationAreaCreateOrConnectWithoutLocationInput | LocationAreaCreateOrConnectWithoutLocationInput[]
    createMany?: LocationAreaCreateManyLocationInputEnvelope
    connect?: LocationAreaWhereUniqueInput | LocationAreaWhereUniqueInput[]
  }

  export type RegionUpdateOneRequiredWithoutLocationsNestedInput = {
    create?: XOR<RegionCreateWithoutLocationsInput, RegionUncheckedCreateWithoutLocationsInput>
    connectOrCreate?: RegionCreateOrConnectWithoutLocationsInput
    upsert?: RegionUpsertWithoutLocationsInput
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutLocationsInput, RegionUpdateWithoutLocationsInput>, RegionUncheckedUpdateWithoutLocationsInput>
  }

  export type LocationAreaUpdateManyWithoutLocationNestedInput = {
    create?: XOR<LocationAreaCreateWithoutLocationInput, LocationAreaUncheckedCreateWithoutLocationInput> | LocationAreaCreateWithoutLocationInput[] | LocationAreaUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: LocationAreaCreateOrConnectWithoutLocationInput | LocationAreaCreateOrConnectWithoutLocationInput[]
    upsert?: LocationAreaUpsertWithWhereUniqueWithoutLocationInput | LocationAreaUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: LocationAreaCreateManyLocationInputEnvelope
    set?: LocationAreaWhereUniqueInput | LocationAreaWhereUniqueInput[]
    disconnect?: LocationAreaWhereUniqueInput | LocationAreaWhereUniqueInput[]
    delete?: LocationAreaWhereUniqueInput | LocationAreaWhereUniqueInput[]
    connect?: LocationAreaWhereUniqueInput | LocationAreaWhereUniqueInput[]
    update?: LocationAreaUpdateWithWhereUniqueWithoutLocationInput | LocationAreaUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: LocationAreaUpdateManyWithWhereWithoutLocationInput | LocationAreaUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: LocationAreaScalarWhereInput | LocationAreaScalarWhereInput[]
  }

  export type LocationAreaUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<LocationAreaCreateWithoutLocationInput, LocationAreaUncheckedCreateWithoutLocationInput> | LocationAreaCreateWithoutLocationInput[] | LocationAreaUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: LocationAreaCreateOrConnectWithoutLocationInput | LocationAreaCreateOrConnectWithoutLocationInput[]
    upsert?: LocationAreaUpsertWithWhereUniqueWithoutLocationInput | LocationAreaUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: LocationAreaCreateManyLocationInputEnvelope
    set?: LocationAreaWhereUniqueInput | LocationAreaWhereUniqueInput[]
    disconnect?: LocationAreaWhereUniqueInput | LocationAreaWhereUniqueInput[]
    delete?: LocationAreaWhereUniqueInput | LocationAreaWhereUniqueInput[]
    connect?: LocationAreaWhereUniqueInput | LocationAreaWhereUniqueInput[]
    update?: LocationAreaUpdateWithWhereUniqueWithoutLocationInput | LocationAreaUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: LocationAreaUpdateManyWithWhereWithoutLocationInput | LocationAreaUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: LocationAreaScalarWhereInput | LocationAreaScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutAreasInput = {
    create?: XOR<LocationCreateWithoutAreasInput, LocationUncheckedCreateWithoutAreasInput>
    connectOrCreate?: LocationCreateOrConnectWithoutAreasInput
    connect?: LocationWhereUniqueInput
  }

  export type EncounterCreateNestedManyWithoutLocation_areaInput = {
    create?: XOR<EncounterCreateWithoutLocation_areaInput, EncounterUncheckedCreateWithoutLocation_areaInput> | EncounterCreateWithoutLocation_areaInput[] | EncounterUncheckedCreateWithoutLocation_areaInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutLocation_areaInput | EncounterCreateOrConnectWithoutLocation_areaInput[]
    createMany?: EncounterCreateManyLocation_areaInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type LocationAreaEncounterRateCreateNestedManyWithoutLocation_areaInput = {
    create?: XOR<LocationAreaEncounterRateCreateWithoutLocation_areaInput, LocationAreaEncounterRateUncheckedCreateWithoutLocation_areaInput> | LocationAreaEncounterRateCreateWithoutLocation_areaInput[] | LocationAreaEncounterRateUncheckedCreateWithoutLocation_areaInput[]
    connectOrCreate?: LocationAreaEncounterRateCreateOrConnectWithoutLocation_areaInput | LocationAreaEncounterRateCreateOrConnectWithoutLocation_areaInput[]
    createMany?: LocationAreaEncounterRateCreateManyLocation_areaInputEnvelope
    connect?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutLocation_areaInput = {
    create?: XOR<EncounterCreateWithoutLocation_areaInput, EncounterUncheckedCreateWithoutLocation_areaInput> | EncounterCreateWithoutLocation_areaInput[] | EncounterUncheckedCreateWithoutLocation_areaInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutLocation_areaInput | EncounterCreateOrConnectWithoutLocation_areaInput[]
    createMany?: EncounterCreateManyLocation_areaInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type LocationAreaEncounterRateUncheckedCreateNestedManyWithoutLocation_areaInput = {
    create?: XOR<LocationAreaEncounterRateCreateWithoutLocation_areaInput, LocationAreaEncounterRateUncheckedCreateWithoutLocation_areaInput> | LocationAreaEncounterRateCreateWithoutLocation_areaInput[] | LocationAreaEncounterRateUncheckedCreateWithoutLocation_areaInput[]
    connectOrCreate?: LocationAreaEncounterRateCreateOrConnectWithoutLocation_areaInput | LocationAreaEncounterRateCreateOrConnectWithoutLocation_areaInput[]
    createMany?: LocationAreaEncounterRateCreateManyLocation_areaInputEnvelope
    connect?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
  }

  export type LocationUpdateOneRequiredWithoutAreasNestedInput = {
    create?: XOR<LocationCreateWithoutAreasInput, LocationUncheckedCreateWithoutAreasInput>
    connectOrCreate?: LocationCreateOrConnectWithoutAreasInput
    upsert?: LocationUpsertWithoutAreasInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutAreasInput, LocationUpdateWithoutAreasInput>, LocationUncheckedUpdateWithoutAreasInput>
  }

  export type EncounterUpdateManyWithoutLocation_areaNestedInput = {
    create?: XOR<EncounterCreateWithoutLocation_areaInput, EncounterUncheckedCreateWithoutLocation_areaInput> | EncounterCreateWithoutLocation_areaInput[] | EncounterUncheckedCreateWithoutLocation_areaInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutLocation_areaInput | EncounterCreateOrConnectWithoutLocation_areaInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutLocation_areaInput | EncounterUpsertWithWhereUniqueWithoutLocation_areaInput[]
    createMany?: EncounterCreateManyLocation_areaInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutLocation_areaInput | EncounterUpdateWithWhereUniqueWithoutLocation_areaInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutLocation_areaInput | EncounterUpdateManyWithWhereWithoutLocation_areaInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type LocationAreaEncounterRateUpdateManyWithoutLocation_areaNestedInput = {
    create?: XOR<LocationAreaEncounterRateCreateWithoutLocation_areaInput, LocationAreaEncounterRateUncheckedCreateWithoutLocation_areaInput> | LocationAreaEncounterRateCreateWithoutLocation_areaInput[] | LocationAreaEncounterRateUncheckedCreateWithoutLocation_areaInput[]
    connectOrCreate?: LocationAreaEncounterRateCreateOrConnectWithoutLocation_areaInput | LocationAreaEncounterRateCreateOrConnectWithoutLocation_areaInput[]
    upsert?: LocationAreaEncounterRateUpsertWithWhereUniqueWithoutLocation_areaInput | LocationAreaEncounterRateUpsertWithWhereUniqueWithoutLocation_areaInput[]
    createMany?: LocationAreaEncounterRateCreateManyLocation_areaInputEnvelope
    set?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    disconnect?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    delete?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    connect?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    update?: LocationAreaEncounterRateUpdateWithWhereUniqueWithoutLocation_areaInput | LocationAreaEncounterRateUpdateWithWhereUniqueWithoutLocation_areaInput[]
    updateMany?: LocationAreaEncounterRateUpdateManyWithWhereWithoutLocation_areaInput | LocationAreaEncounterRateUpdateManyWithWhereWithoutLocation_areaInput[]
    deleteMany?: LocationAreaEncounterRateScalarWhereInput | LocationAreaEncounterRateScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutLocation_areaNestedInput = {
    create?: XOR<EncounterCreateWithoutLocation_areaInput, EncounterUncheckedCreateWithoutLocation_areaInput> | EncounterCreateWithoutLocation_areaInput[] | EncounterUncheckedCreateWithoutLocation_areaInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutLocation_areaInput | EncounterCreateOrConnectWithoutLocation_areaInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutLocation_areaInput | EncounterUpsertWithWhereUniqueWithoutLocation_areaInput[]
    createMany?: EncounterCreateManyLocation_areaInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutLocation_areaInput | EncounterUpdateWithWhereUniqueWithoutLocation_areaInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutLocation_areaInput | EncounterUpdateManyWithWhereWithoutLocation_areaInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type LocationAreaEncounterRateUncheckedUpdateManyWithoutLocation_areaNestedInput = {
    create?: XOR<LocationAreaEncounterRateCreateWithoutLocation_areaInput, LocationAreaEncounterRateUncheckedCreateWithoutLocation_areaInput> | LocationAreaEncounterRateCreateWithoutLocation_areaInput[] | LocationAreaEncounterRateUncheckedCreateWithoutLocation_areaInput[]
    connectOrCreate?: LocationAreaEncounterRateCreateOrConnectWithoutLocation_areaInput | LocationAreaEncounterRateCreateOrConnectWithoutLocation_areaInput[]
    upsert?: LocationAreaEncounterRateUpsertWithWhereUniqueWithoutLocation_areaInput | LocationAreaEncounterRateUpsertWithWhereUniqueWithoutLocation_areaInput[]
    createMany?: LocationAreaEncounterRateCreateManyLocation_areaInputEnvelope
    set?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    disconnect?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    delete?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    connect?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    update?: LocationAreaEncounterRateUpdateWithWhereUniqueWithoutLocation_areaInput | LocationAreaEncounterRateUpdateWithWhereUniqueWithoutLocation_areaInput[]
    updateMany?: LocationAreaEncounterRateUpdateManyWithWhereWithoutLocation_areaInput | LocationAreaEncounterRateUpdateManyWithWhereWithoutLocation_areaInput[]
    deleteMany?: LocationAreaEncounterRateScalarWhereInput | LocationAreaEncounterRateScalarWhereInput[]
  }

  export type EncounterSlotCreateNestedManyWithoutMethodInput = {
    create?: XOR<EncounterSlotCreateWithoutMethodInput, EncounterSlotUncheckedCreateWithoutMethodInput> | EncounterSlotCreateWithoutMethodInput[] | EncounterSlotUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: EncounterSlotCreateOrConnectWithoutMethodInput | EncounterSlotCreateOrConnectWithoutMethodInput[]
    createMany?: EncounterSlotCreateManyMethodInputEnvelope
    connect?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
  }

  export type LocationAreaEncounterRateCreateNestedManyWithoutEncounter_methodInput = {
    create?: XOR<LocationAreaEncounterRateCreateWithoutEncounter_methodInput, LocationAreaEncounterRateUncheckedCreateWithoutEncounter_methodInput> | LocationAreaEncounterRateCreateWithoutEncounter_methodInput[] | LocationAreaEncounterRateUncheckedCreateWithoutEncounter_methodInput[]
    connectOrCreate?: LocationAreaEncounterRateCreateOrConnectWithoutEncounter_methodInput | LocationAreaEncounterRateCreateOrConnectWithoutEncounter_methodInput[]
    createMany?: LocationAreaEncounterRateCreateManyEncounter_methodInputEnvelope
    connect?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
  }

  export type EncounterSlotUncheckedCreateNestedManyWithoutMethodInput = {
    create?: XOR<EncounterSlotCreateWithoutMethodInput, EncounterSlotUncheckedCreateWithoutMethodInput> | EncounterSlotCreateWithoutMethodInput[] | EncounterSlotUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: EncounterSlotCreateOrConnectWithoutMethodInput | EncounterSlotCreateOrConnectWithoutMethodInput[]
    createMany?: EncounterSlotCreateManyMethodInputEnvelope
    connect?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
  }

  export type LocationAreaEncounterRateUncheckedCreateNestedManyWithoutEncounter_methodInput = {
    create?: XOR<LocationAreaEncounterRateCreateWithoutEncounter_methodInput, LocationAreaEncounterRateUncheckedCreateWithoutEncounter_methodInput> | LocationAreaEncounterRateCreateWithoutEncounter_methodInput[] | LocationAreaEncounterRateUncheckedCreateWithoutEncounter_methodInput[]
    connectOrCreate?: LocationAreaEncounterRateCreateOrConnectWithoutEncounter_methodInput | LocationAreaEncounterRateCreateOrConnectWithoutEncounter_methodInput[]
    createMany?: LocationAreaEncounterRateCreateManyEncounter_methodInputEnvelope
    connect?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
  }

  export type EncounterSlotUpdateManyWithoutMethodNestedInput = {
    create?: XOR<EncounterSlotCreateWithoutMethodInput, EncounterSlotUncheckedCreateWithoutMethodInput> | EncounterSlotCreateWithoutMethodInput[] | EncounterSlotUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: EncounterSlotCreateOrConnectWithoutMethodInput | EncounterSlotCreateOrConnectWithoutMethodInput[]
    upsert?: EncounterSlotUpsertWithWhereUniqueWithoutMethodInput | EncounterSlotUpsertWithWhereUniqueWithoutMethodInput[]
    createMany?: EncounterSlotCreateManyMethodInputEnvelope
    set?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
    disconnect?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
    delete?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
    connect?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
    update?: EncounterSlotUpdateWithWhereUniqueWithoutMethodInput | EncounterSlotUpdateWithWhereUniqueWithoutMethodInput[]
    updateMany?: EncounterSlotUpdateManyWithWhereWithoutMethodInput | EncounterSlotUpdateManyWithWhereWithoutMethodInput[]
    deleteMany?: EncounterSlotScalarWhereInput | EncounterSlotScalarWhereInput[]
  }

  export type LocationAreaEncounterRateUpdateManyWithoutEncounter_methodNestedInput = {
    create?: XOR<LocationAreaEncounterRateCreateWithoutEncounter_methodInput, LocationAreaEncounterRateUncheckedCreateWithoutEncounter_methodInput> | LocationAreaEncounterRateCreateWithoutEncounter_methodInput[] | LocationAreaEncounterRateUncheckedCreateWithoutEncounter_methodInput[]
    connectOrCreate?: LocationAreaEncounterRateCreateOrConnectWithoutEncounter_methodInput | LocationAreaEncounterRateCreateOrConnectWithoutEncounter_methodInput[]
    upsert?: LocationAreaEncounterRateUpsertWithWhereUniqueWithoutEncounter_methodInput | LocationAreaEncounterRateUpsertWithWhereUniqueWithoutEncounter_methodInput[]
    createMany?: LocationAreaEncounterRateCreateManyEncounter_methodInputEnvelope
    set?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    disconnect?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    delete?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    connect?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    update?: LocationAreaEncounterRateUpdateWithWhereUniqueWithoutEncounter_methodInput | LocationAreaEncounterRateUpdateWithWhereUniqueWithoutEncounter_methodInput[]
    updateMany?: LocationAreaEncounterRateUpdateManyWithWhereWithoutEncounter_methodInput | LocationAreaEncounterRateUpdateManyWithWhereWithoutEncounter_methodInput[]
    deleteMany?: LocationAreaEncounterRateScalarWhereInput | LocationAreaEncounterRateScalarWhereInput[]
  }

  export type EncounterSlotUncheckedUpdateManyWithoutMethodNestedInput = {
    create?: XOR<EncounterSlotCreateWithoutMethodInput, EncounterSlotUncheckedCreateWithoutMethodInput> | EncounterSlotCreateWithoutMethodInput[] | EncounterSlotUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: EncounterSlotCreateOrConnectWithoutMethodInput | EncounterSlotCreateOrConnectWithoutMethodInput[]
    upsert?: EncounterSlotUpsertWithWhereUniqueWithoutMethodInput | EncounterSlotUpsertWithWhereUniqueWithoutMethodInput[]
    createMany?: EncounterSlotCreateManyMethodInputEnvelope
    set?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
    disconnect?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
    delete?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
    connect?: EncounterSlotWhereUniqueInput | EncounterSlotWhereUniqueInput[]
    update?: EncounterSlotUpdateWithWhereUniqueWithoutMethodInput | EncounterSlotUpdateWithWhereUniqueWithoutMethodInput[]
    updateMany?: EncounterSlotUpdateManyWithWhereWithoutMethodInput | EncounterSlotUpdateManyWithWhereWithoutMethodInput[]
    deleteMany?: EncounterSlotScalarWhereInput | EncounterSlotScalarWhereInput[]
  }

  export type LocationAreaEncounterRateUncheckedUpdateManyWithoutEncounter_methodNestedInput = {
    create?: XOR<LocationAreaEncounterRateCreateWithoutEncounter_methodInput, LocationAreaEncounterRateUncheckedCreateWithoutEncounter_methodInput> | LocationAreaEncounterRateCreateWithoutEncounter_methodInput[] | LocationAreaEncounterRateUncheckedCreateWithoutEncounter_methodInput[]
    connectOrCreate?: LocationAreaEncounterRateCreateOrConnectWithoutEncounter_methodInput | LocationAreaEncounterRateCreateOrConnectWithoutEncounter_methodInput[]
    upsert?: LocationAreaEncounterRateUpsertWithWhereUniqueWithoutEncounter_methodInput | LocationAreaEncounterRateUpsertWithWhereUniqueWithoutEncounter_methodInput[]
    createMany?: LocationAreaEncounterRateCreateManyEncounter_methodInputEnvelope
    set?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    disconnect?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    delete?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    connect?: LocationAreaEncounterRateWhereUniqueInput | LocationAreaEncounterRateWhereUniqueInput[]
    update?: LocationAreaEncounterRateUpdateWithWhereUniqueWithoutEncounter_methodInput | LocationAreaEncounterRateUpdateWithWhereUniqueWithoutEncounter_methodInput[]
    updateMany?: LocationAreaEncounterRateUpdateManyWithWhereWithoutEncounter_methodInput | LocationAreaEncounterRateUpdateManyWithWhereWithoutEncounter_methodInput[]
    deleteMany?: LocationAreaEncounterRateScalarWhereInput | LocationAreaEncounterRateScalarWhereInput[]
  }

  export type VersionGroupCreateNestedOneWithoutSlotsInput = {
    create?: XOR<VersionGroupCreateWithoutSlotsInput, VersionGroupUncheckedCreateWithoutSlotsInput>
    connectOrCreate?: VersionGroupCreateOrConnectWithoutSlotsInput
    connect?: VersionGroupWhereUniqueInput
  }

  export type EncounterMethodCreateNestedOneWithoutSlotsInput = {
    create?: XOR<EncounterMethodCreateWithoutSlotsInput, EncounterMethodUncheckedCreateWithoutSlotsInput>
    connectOrCreate?: EncounterMethodCreateOrConnectWithoutSlotsInput
    connect?: EncounterMethodWhereUniqueInput
  }

  export type EncounterCreateNestedManyWithoutSlotInput = {
    create?: XOR<EncounterCreateWithoutSlotInput, EncounterUncheckedCreateWithoutSlotInput> | EncounterCreateWithoutSlotInput[] | EncounterUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutSlotInput | EncounterCreateOrConnectWithoutSlotInput[]
    createMany?: EncounterCreateManySlotInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type EncounterUncheckedCreateNestedManyWithoutSlotInput = {
    create?: XOR<EncounterCreateWithoutSlotInput, EncounterUncheckedCreateWithoutSlotInput> | EncounterCreateWithoutSlotInput[] | EncounterUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutSlotInput | EncounterCreateOrConnectWithoutSlotInput[]
    createMany?: EncounterCreateManySlotInputEnvelope
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
  }

  export type VersionGroupUpdateOneRequiredWithoutSlotsNestedInput = {
    create?: XOR<VersionGroupCreateWithoutSlotsInput, VersionGroupUncheckedCreateWithoutSlotsInput>
    connectOrCreate?: VersionGroupCreateOrConnectWithoutSlotsInput
    upsert?: VersionGroupUpsertWithoutSlotsInput
    connect?: VersionGroupWhereUniqueInput
    update?: XOR<XOR<VersionGroupUpdateToOneWithWhereWithoutSlotsInput, VersionGroupUpdateWithoutSlotsInput>, VersionGroupUncheckedUpdateWithoutSlotsInput>
  }

  export type EncounterMethodUpdateOneRequiredWithoutSlotsNestedInput = {
    create?: XOR<EncounterMethodCreateWithoutSlotsInput, EncounterMethodUncheckedCreateWithoutSlotsInput>
    connectOrCreate?: EncounterMethodCreateOrConnectWithoutSlotsInput
    upsert?: EncounterMethodUpsertWithoutSlotsInput
    connect?: EncounterMethodWhereUniqueInput
    update?: XOR<XOR<EncounterMethodUpdateToOneWithWhereWithoutSlotsInput, EncounterMethodUpdateWithoutSlotsInput>, EncounterMethodUncheckedUpdateWithoutSlotsInput>
  }

  export type EncounterUpdateManyWithoutSlotNestedInput = {
    create?: XOR<EncounterCreateWithoutSlotInput, EncounterUncheckedCreateWithoutSlotInput> | EncounterCreateWithoutSlotInput[] | EncounterUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutSlotInput | EncounterCreateOrConnectWithoutSlotInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutSlotInput | EncounterUpsertWithWhereUniqueWithoutSlotInput[]
    createMany?: EncounterCreateManySlotInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutSlotInput | EncounterUpdateWithWhereUniqueWithoutSlotInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutSlotInput | EncounterUpdateManyWithWhereWithoutSlotInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type EncounterUncheckedUpdateManyWithoutSlotNestedInput = {
    create?: XOR<EncounterCreateWithoutSlotInput, EncounterUncheckedCreateWithoutSlotInput> | EncounterCreateWithoutSlotInput[] | EncounterUncheckedCreateWithoutSlotInput[]
    connectOrCreate?: EncounterCreateOrConnectWithoutSlotInput | EncounterCreateOrConnectWithoutSlotInput[]
    upsert?: EncounterUpsertWithWhereUniqueWithoutSlotInput | EncounterUpsertWithWhereUniqueWithoutSlotInput[]
    createMany?: EncounterCreateManySlotInputEnvelope
    set?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    disconnect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    delete?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    connect?: EncounterWhereUniqueInput | EncounterWhereUniqueInput[]
    update?: EncounterUpdateWithWhereUniqueWithoutSlotInput | EncounterUpdateWithWhereUniqueWithoutSlotInput[]
    updateMany?: EncounterUpdateManyWithWhereWithoutSlotInput | EncounterUpdateManyWithWhereWithoutSlotInput[]
    deleteMany?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
  }

  export type VersionCreateNestedOneWithoutEncountersInput = {
    create?: XOR<VersionCreateWithoutEncountersInput, VersionUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: VersionCreateOrConnectWithoutEncountersInput
    connect?: VersionWhereUniqueInput
  }

  export type PokemonCreateNestedOneWithoutEncountersInput = {
    create?: XOR<PokemonCreateWithoutEncountersInput, PokemonUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: PokemonCreateOrConnectWithoutEncountersInput
    connect?: PokemonWhereUniqueInput
  }

  export type LocationAreaCreateNestedOneWithoutEncountersInput = {
    create?: XOR<LocationAreaCreateWithoutEncountersInput, LocationAreaUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: LocationAreaCreateOrConnectWithoutEncountersInput
    connect?: LocationAreaWhereUniqueInput
  }

  export type EncounterSlotCreateNestedOneWithoutEncountersInput = {
    create?: XOR<EncounterSlotCreateWithoutEncountersInput, EncounterSlotUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: EncounterSlotCreateOrConnectWithoutEncountersInput
    connect?: EncounterSlotWhereUniqueInput
  }

  export type EncounterConditionValueMapCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EncounterConditionValueMapCreateWithoutEncounterInput, EncounterConditionValueMapUncheckedCreateWithoutEncounterInput> | EncounterConditionValueMapCreateWithoutEncounterInput[] | EncounterConditionValueMapUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterConditionValueMapCreateOrConnectWithoutEncounterInput | EncounterConditionValueMapCreateOrConnectWithoutEncounterInput[]
    createMany?: EncounterConditionValueMapCreateManyEncounterInputEnvelope
    connect?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
  }

  export type EncounterConditionValueMapUncheckedCreateNestedManyWithoutEncounterInput = {
    create?: XOR<EncounterConditionValueMapCreateWithoutEncounterInput, EncounterConditionValueMapUncheckedCreateWithoutEncounterInput> | EncounterConditionValueMapCreateWithoutEncounterInput[] | EncounterConditionValueMapUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterConditionValueMapCreateOrConnectWithoutEncounterInput | EncounterConditionValueMapCreateOrConnectWithoutEncounterInput[]
    createMany?: EncounterConditionValueMapCreateManyEncounterInputEnvelope
    connect?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
  }

  export type VersionUpdateOneRequiredWithoutEncountersNestedInput = {
    create?: XOR<VersionCreateWithoutEncountersInput, VersionUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: VersionCreateOrConnectWithoutEncountersInput
    upsert?: VersionUpsertWithoutEncountersInput
    connect?: VersionWhereUniqueInput
    update?: XOR<XOR<VersionUpdateToOneWithWhereWithoutEncountersInput, VersionUpdateWithoutEncountersInput>, VersionUncheckedUpdateWithoutEncountersInput>
  }

  export type PokemonUpdateOneRequiredWithoutEncountersNestedInput = {
    create?: XOR<PokemonCreateWithoutEncountersInput, PokemonUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: PokemonCreateOrConnectWithoutEncountersInput
    upsert?: PokemonUpsertWithoutEncountersInput
    connect?: PokemonWhereUniqueInput
    update?: XOR<XOR<PokemonUpdateToOneWithWhereWithoutEncountersInput, PokemonUpdateWithoutEncountersInput>, PokemonUncheckedUpdateWithoutEncountersInput>
  }

  export type LocationAreaUpdateOneRequiredWithoutEncountersNestedInput = {
    create?: XOR<LocationAreaCreateWithoutEncountersInput, LocationAreaUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: LocationAreaCreateOrConnectWithoutEncountersInput
    upsert?: LocationAreaUpsertWithoutEncountersInput
    connect?: LocationAreaWhereUniqueInput
    update?: XOR<XOR<LocationAreaUpdateToOneWithWhereWithoutEncountersInput, LocationAreaUpdateWithoutEncountersInput>, LocationAreaUncheckedUpdateWithoutEncountersInput>
  }

  export type EncounterSlotUpdateOneRequiredWithoutEncountersNestedInput = {
    create?: XOR<EncounterSlotCreateWithoutEncountersInput, EncounterSlotUncheckedCreateWithoutEncountersInput>
    connectOrCreate?: EncounterSlotCreateOrConnectWithoutEncountersInput
    upsert?: EncounterSlotUpsertWithoutEncountersInput
    connect?: EncounterSlotWhereUniqueInput
    update?: XOR<XOR<EncounterSlotUpdateToOneWithWhereWithoutEncountersInput, EncounterSlotUpdateWithoutEncountersInput>, EncounterSlotUncheckedUpdateWithoutEncountersInput>
  }

  export type EncounterConditionValueMapUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EncounterConditionValueMapCreateWithoutEncounterInput, EncounterConditionValueMapUncheckedCreateWithoutEncounterInput> | EncounterConditionValueMapCreateWithoutEncounterInput[] | EncounterConditionValueMapUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterConditionValueMapCreateOrConnectWithoutEncounterInput | EncounterConditionValueMapCreateOrConnectWithoutEncounterInput[]
    upsert?: EncounterConditionValueMapUpsertWithWhereUniqueWithoutEncounterInput | EncounterConditionValueMapUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EncounterConditionValueMapCreateManyEncounterInputEnvelope
    set?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
    disconnect?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
    delete?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
    connect?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
    update?: EncounterConditionValueMapUpdateWithWhereUniqueWithoutEncounterInput | EncounterConditionValueMapUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EncounterConditionValueMapUpdateManyWithWhereWithoutEncounterInput | EncounterConditionValueMapUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EncounterConditionValueMapScalarWhereInput | EncounterConditionValueMapScalarWhereInput[]
  }

  export type EncounterConditionValueMapUncheckedUpdateManyWithoutEncounterNestedInput = {
    create?: XOR<EncounterConditionValueMapCreateWithoutEncounterInput, EncounterConditionValueMapUncheckedCreateWithoutEncounterInput> | EncounterConditionValueMapCreateWithoutEncounterInput[] | EncounterConditionValueMapUncheckedCreateWithoutEncounterInput[]
    connectOrCreate?: EncounterConditionValueMapCreateOrConnectWithoutEncounterInput | EncounterConditionValueMapCreateOrConnectWithoutEncounterInput[]
    upsert?: EncounterConditionValueMapUpsertWithWhereUniqueWithoutEncounterInput | EncounterConditionValueMapUpsertWithWhereUniqueWithoutEncounterInput[]
    createMany?: EncounterConditionValueMapCreateManyEncounterInputEnvelope
    set?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
    disconnect?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
    delete?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
    connect?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
    update?: EncounterConditionValueMapUpdateWithWhereUniqueWithoutEncounterInput | EncounterConditionValueMapUpdateWithWhereUniqueWithoutEncounterInput[]
    updateMany?: EncounterConditionValueMapUpdateManyWithWhereWithoutEncounterInput | EncounterConditionValueMapUpdateManyWithWhereWithoutEncounterInput[]
    deleteMany?: EncounterConditionValueMapScalarWhereInput | EncounterConditionValueMapScalarWhereInput[]
  }

  export type EncounterConditionValueCreateNestedManyWithoutConditionInput = {
    create?: XOR<EncounterConditionValueCreateWithoutConditionInput, EncounterConditionValueUncheckedCreateWithoutConditionInput> | EncounterConditionValueCreateWithoutConditionInput[] | EncounterConditionValueUncheckedCreateWithoutConditionInput[]
    connectOrCreate?: EncounterConditionValueCreateOrConnectWithoutConditionInput | EncounterConditionValueCreateOrConnectWithoutConditionInput[]
    createMany?: EncounterConditionValueCreateManyConditionInputEnvelope
    connect?: EncounterConditionValueWhereUniqueInput | EncounterConditionValueWhereUniqueInput[]
  }

  export type EncounterConditionValueUncheckedCreateNestedManyWithoutConditionInput = {
    create?: XOR<EncounterConditionValueCreateWithoutConditionInput, EncounterConditionValueUncheckedCreateWithoutConditionInput> | EncounterConditionValueCreateWithoutConditionInput[] | EncounterConditionValueUncheckedCreateWithoutConditionInput[]
    connectOrCreate?: EncounterConditionValueCreateOrConnectWithoutConditionInput | EncounterConditionValueCreateOrConnectWithoutConditionInput[]
    createMany?: EncounterConditionValueCreateManyConditionInputEnvelope
    connect?: EncounterConditionValueWhereUniqueInput | EncounterConditionValueWhereUniqueInput[]
  }

  export type EncounterConditionValueUpdateManyWithoutConditionNestedInput = {
    create?: XOR<EncounterConditionValueCreateWithoutConditionInput, EncounterConditionValueUncheckedCreateWithoutConditionInput> | EncounterConditionValueCreateWithoutConditionInput[] | EncounterConditionValueUncheckedCreateWithoutConditionInput[]
    connectOrCreate?: EncounterConditionValueCreateOrConnectWithoutConditionInput | EncounterConditionValueCreateOrConnectWithoutConditionInput[]
    upsert?: EncounterConditionValueUpsertWithWhereUniqueWithoutConditionInput | EncounterConditionValueUpsertWithWhereUniqueWithoutConditionInput[]
    createMany?: EncounterConditionValueCreateManyConditionInputEnvelope
    set?: EncounterConditionValueWhereUniqueInput | EncounterConditionValueWhereUniqueInput[]
    disconnect?: EncounterConditionValueWhereUniqueInput | EncounterConditionValueWhereUniqueInput[]
    delete?: EncounterConditionValueWhereUniqueInput | EncounterConditionValueWhereUniqueInput[]
    connect?: EncounterConditionValueWhereUniqueInput | EncounterConditionValueWhereUniqueInput[]
    update?: EncounterConditionValueUpdateWithWhereUniqueWithoutConditionInput | EncounterConditionValueUpdateWithWhereUniqueWithoutConditionInput[]
    updateMany?: EncounterConditionValueUpdateManyWithWhereWithoutConditionInput | EncounterConditionValueUpdateManyWithWhereWithoutConditionInput[]
    deleteMany?: EncounterConditionValueScalarWhereInput | EncounterConditionValueScalarWhereInput[]
  }

  export type EncounterConditionValueUncheckedUpdateManyWithoutConditionNestedInput = {
    create?: XOR<EncounterConditionValueCreateWithoutConditionInput, EncounterConditionValueUncheckedCreateWithoutConditionInput> | EncounterConditionValueCreateWithoutConditionInput[] | EncounterConditionValueUncheckedCreateWithoutConditionInput[]
    connectOrCreate?: EncounterConditionValueCreateOrConnectWithoutConditionInput | EncounterConditionValueCreateOrConnectWithoutConditionInput[]
    upsert?: EncounterConditionValueUpsertWithWhereUniqueWithoutConditionInput | EncounterConditionValueUpsertWithWhereUniqueWithoutConditionInput[]
    createMany?: EncounterConditionValueCreateManyConditionInputEnvelope
    set?: EncounterConditionValueWhereUniqueInput | EncounterConditionValueWhereUniqueInput[]
    disconnect?: EncounterConditionValueWhereUniqueInput | EncounterConditionValueWhereUniqueInput[]
    delete?: EncounterConditionValueWhereUniqueInput | EncounterConditionValueWhereUniqueInput[]
    connect?: EncounterConditionValueWhereUniqueInput | EncounterConditionValueWhereUniqueInput[]
    update?: EncounterConditionValueUpdateWithWhereUniqueWithoutConditionInput | EncounterConditionValueUpdateWithWhereUniqueWithoutConditionInput[]
    updateMany?: EncounterConditionValueUpdateManyWithWhereWithoutConditionInput | EncounterConditionValueUpdateManyWithWhereWithoutConditionInput[]
    deleteMany?: EncounterConditionValueScalarWhereInput | EncounterConditionValueScalarWhereInput[]
  }

  export type EncounterConditionCreateNestedOneWithoutValuesInput = {
    create?: XOR<EncounterConditionCreateWithoutValuesInput, EncounterConditionUncheckedCreateWithoutValuesInput>
    connectOrCreate?: EncounterConditionCreateOrConnectWithoutValuesInput
    connect?: EncounterConditionWhereUniqueInput
  }

  export type EncounterConditionValueMapCreateNestedManyWithoutValueInput = {
    create?: XOR<EncounterConditionValueMapCreateWithoutValueInput, EncounterConditionValueMapUncheckedCreateWithoutValueInput> | EncounterConditionValueMapCreateWithoutValueInput[] | EncounterConditionValueMapUncheckedCreateWithoutValueInput[]
    connectOrCreate?: EncounterConditionValueMapCreateOrConnectWithoutValueInput | EncounterConditionValueMapCreateOrConnectWithoutValueInput[]
    createMany?: EncounterConditionValueMapCreateManyValueInputEnvelope
    connect?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
  }

  export type EncounterConditionValueMapUncheckedCreateNestedManyWithoutValueInput = {
    create?: XOR<EncounterConditionValueMapCreateWithoutValueInput, EncounterConditionValueMapUncheckedCreateWithoutValueInput> | EncounterConditionValueMapCreateWithoutValueInput[] | EncounterConditionValueMapUncheckedCreateWithoutValueInput[]
    connectOrCreate?: EncounterConditionValueMapCreateOrConnectWithoutValueInput | EncounterConditionValueMapCreateOrConnectWithoutValueInput[]
    createMany?: EncounterConditionValueMapCreateManyValueInputEnvelope
    connect?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
  }

  export type EncounterConditionUpdateOneRequiredWithoutValuesNestedInput = {
    create?: XOR<EncounterConditionCreateWithoutValuesInput, EncounterConditionUncheckedCreateWithoutValuesInput>
    connectOrCreate?: EncounterConditionCreateOrConnectWithoutValuesInput
    upsert?: EncounterConditionUpsertWithoutValuesInput
    connect?: EncounterConditionWhereUniqueInput
    update?: XOR<XOR<EncounterConditionUpdateToOneWithWhereWithoutValuesInput, EncounterConditionUpdateWithoutValuesInput>, EncounterConditionUncheckedUpdateWithoutValuesInput>
  }

  export type EncounterConditionValueMapUpdateManyWithoutValueNestedInput = {
    create?: XOR<EncounterConditionValueMapCreateWithoutValueInput, EncounterConditionValueMapUncheckedCreateWithoutValueInput> | EncounterConditionValueMapCreateWithoutValueInput[] | EncounterConditionValueMapUncheckedCreateWithoutValueInput[]
    connectOrCreate?: EncounterConditionValueMapCreateOrConnectWithoutValueInput | EncounterConditionValueMapCreateOrConnectWithoutValueInput[]
    upsert?: EncounterConditionValueMapUpsertWithWhereUniqueWithoutValueInput | EncounterConditionValueMapUpsertWithWhereUniqueWithoutValueInput[]
    createMany?: EncounterConditionValueMapCreateManyValueInputEnvelope
    set?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
    disconnect?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
    delete?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
    connect?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
    update?: EncounterConditionValueMapUpdateWithWhereUniqueWithoutValueInput | EncounterConditionValueMapUpdateWithWhereUniqueWithoutValueInput[]
    updateMany?: EncounterConditionValueMapUpdateManyWithWhereWithoutValueInput | EncounterConditionValueMapUpdateManyWithWhereWithoutValueInput[]
    deleteMany?: EncounterConditionValueMapScalarWhereInput | EncounterConditionValueMapScalarWhereInput[]
  }

  export type EncounterConditionValueMapUncheckedUpdateManyWithoutValueNestedInput = {
    create?: XOR<EncounterConditionValueMapCreateWithoutValueInput, EncounterConditionValueMapUncheckedCreateWithoutValueInput> | EncounterConditionValueMapCreateWithoutValueInput[] | EncounterConditionValueMapUncheckedCreateWithoutValueInput[]
    connectOrCreate?: EncounterConditionValueMapCreateOrConnectWithoutValueInput | EncounterConditionValueMapCreateOrConnectWithoutValueInput[]
    upsert?: EncounterConditionValueMapUpsertWithWhereUniqueWithoutValueInput | EncounterConditionValueMapUpsertWithWhereUniqueWithoutValueInput[]
    createMany?: EncounterConditionValueMapCreateManyValueInputEnvelope
    set?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
    disconnect?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
    delete?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
    connect?: EncounterConditionValueMapWhereUniqueInput | EncounterConditionValueMapWhereUniqueInput[]
    update?: EncounterConditionValueMapUpdateWithWhereUniqueWithoutValueInput | EncounterConditionValueMapUpdateWithWhereUniqueWithoutValueInput[]
    updateMany?: EncounterConditionValueMapUpdateManyWithWhereWithoutValueInput | EncounterConditionValueMapUpdateManyWithWhereWithoutValueInput[]
    deleteMany?: EncounterConditionValueMapScalarWhereInput | EncounterConditionValueMapScalarWhereInput[]
  }

  export type EncounterCreateNestedOneWithoutConditionsInput = {
    create?: XOR<EncounterCreateWithoutConditionsInput, EncounterUncheckedCreateWithoutConditionsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutConditionsInput
    connect?: EncounterWhereUniqueInput
  }

  export type EncounterConditionValueCreateNestedOneWithoutMapsInput = {
    create?: XOR<EncounterConditionValueCreateWithoutMapsInput, EncounterConditionValueUncheckedCreateWithoutMapsInput>
    connectOrCreate?: EncounterConditionValueCreateOrConnectWithoutMapsInput
    connect?: EncounterConditionValueWhereUniqueInput
  }

  export type EncounterUpdateOneRequiredWithoutConditionsNestedInput = {
    create?: XOR<EncounterCreateWithoutConditionsInput, EncounterUncheckedCreateWithoutConditionsInput>
    connectOrCreate?: EncounterCreateOrConnectWithoutConditionsInput
    upsert?: EncounterUpsertWithoutConditionsInput
    connect?: EncounterWhereUniqueInput
    update?: XOR<XOR<EncounterUpdateToOneWithWhereWithoutConditionsInput, EncounterUpdateWithoutConditionsInput>, EncounterUncheckedUpdateWithoutConditionsInput>
  }

  export type EncounterConditionValueUpdateOneRequiredWithoutMapsNestedInput = {
    create?: XOR<EncounterConditionValueCreateWithoutMapsInput, EncounterConditionValueUncheckedCreateWithoutMapsInput>
    connectOrCreate?: EncounterConditionValueCreateOrConnectWithoutMapsInput
    upsert?: EncounterConditionValueUpsertWithoutMapsInput
    connect?: EncounterConditionValueWhereUniqueInput
    update?: XOR<XOR<EncounterConditionValueUpdateToOneWithWhereWithoutMapsInput, EncounterConditionValueUpdateWithoutMapsInput>, EncounterConditionValueUncheckedUpdateWithoutMapsInput>
  }

  export type LocationAreaCreateNestedOneWithoutEncounterRatesInput = {
    create?: XOR<LocationAreaCreateWithoutEncounterRatesInput, LocationAreaUncheckedCreateWithoutEncounterRatesInput>
    connectOrCreate?: LocationAreaCreateOrConnectWithoutEncounterRatesInput
    connect?: LocationAreaWhereUniqueInput
  }

  export type EncounterMethodCreateNestedOneWithoutLocation_area_encounter_ratesInput = {
    create?: XOR<EncounterMethodCreateWithoutLocation_area_encounter_ratesInput, EncounterMethodUncheckedCreateWithoutLocation_area_encounter_ratesInput>
    connectOrCreate?: EncounterMethodCreateOrConnectWithoutLocation_area_encounter_ratesInput
    connect?: EncounterMethodWhereUniqueInput
  }

  export type VersionCreateNestedOneWithoutEncounterRatesInput = {
    create?: XOR<VersionCreateWithoutEncounterRatesInput, VersionUncheckedCreateWithoutEncounterRatesInput>
    connectOrCreate?: VersionCreateOrConnectWithoutEncounterRatesInput
    connect?: VersionWhereUniqueInput
  }

  export type LocationAreaUpdateOneRequiredWithoutEncounterRatesNestedInput = {
    create?: XOR<LocationAreaCreateWithoutEncounterRatesInput, LocationAreaUncheckedCreateWithoutEncounterRatesInput>
    connectOrCreate?: LocationAreaCreateOrConnectWithoutEncounterRatesInput
    upsert?: LocationAreaUpsertWithoutEncounterRatesInput
    connect?: LocationAreaWhereUniqueInput
    update?: XOR<XOR<LocationAreaUpdateToOneWithWhereWithoutEncounterRatesInput, LocationAreaUpdateWithoutEncounterRatesInput>, LocationAreaUncheckedUpdateWithoutEncounterRatesInput>
  }

  export type EncounterMethodUpdateOneRequiredWithoutLocation_area_encounter_ratesNestedInput = {
    create?: XOR<EncounterMethodCreateWithoutLocation_area_encounter_ratesInput, EncounterMethodUncheckedCreateWithoutLocation_area_encounter_ratesInput>
    connectOrCreate?: EncounterMethodCreateOrConnectWithoutLocation_area_encounter_ratesInput
    upsert?: EncounterMethodUpsertWithoutLocation_area_encounter_ratesInput
    connect?: EncounterMethodWhereUniqueInput
    update?: XOR<XOR<EncounterMethodUpdateToOneWithWhereWithoutLocation_area_encounter_ratesInput, EncounterMethodUpdateWithoutLocation_area_encounter_ratesInput>, EncounterMethodUncheckedUpdateWithoutLocation_area_encounter_ratesInput>
  }

  export type VersionUpdateOneRequiredWithoutEncounterRatesNestedInput = {
    create?: XOR<VersionCreateWithoutEncounterRatesInput, VersionUncheckedCreateWithoutEncounterRatesInput>
    connectOrCreate?: VersionCreateOrConnectWithoutEncounterRatesInput
    upsert?: VersionUpsertWithoutEncounterRatesInput
    connect?: VersionWhereUniqueInput
    update?: XOR<XOR<VersionUpdateToOneWithWhereWithoutEncounterRatesInput, VersionUpdateWithoutEncounterRatesInput>, VersionUncheckedUpdateWithoutEncounterRatesInput>
  }

  export type MoveCreateNestedManyWithoutDamage_classInput = {
    create?: XOR<MoveCreateWithoutDamage_classInput, MoveUncheckedCreateWithoutDamage_classInput> | MoveCreateWithoutDamage_classInput[] | MoveUncheckedCreateWithoutDamage_classInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutDamage_classInput | MoveCreateOrConnectWithoutDamage_classInput[]
    createMany?: MoveCreateManyDamage_classInputEnvelope
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
  }

  export type MoveUncheckedCreateNestedManyWithoutDamage_classInput = {
    create?: XOR<MoveCreateWithoutDamage_classInput, MoveUncheckedCreateWithoutDamage_classInput> | MoveCreateWithoutDamage_classInput[] | MoveUncheckedCreateWithoutDamage_classInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutDamage_classInput | MoveCreateOrConnectWithoutDamage_classInput[]
    createMany?: MoveCreateManyDamage_classInputEnvelope
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
  }

  export type MoveUpdateManyWithoutDamage_classNestedInput = {
    create?: XOR<MoveCreateWithoutDamage_classInput, MoveUncheckedCreateWithoutDamage_classInput> | MoveCreateWithoutDamage_classInput[] | MoveUncheckedCreateWithoutDamage_classInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutDamage_classInput | MoveCreateOrConnectWithoutDamage_classInput[]
    upsert?: MoveUpsertWithWhereUniqueWithoutDamage_classInput | MoveUpsertWithWhereUniqueWithoutDamage_classInput[]
    createMany?: MoveCreateManyDamage_classInputEnvelope
    set?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    disconnect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    delete?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    update?: MoveUpdateWithWhereUniqueWithoutDamage_classInput | MoveUpdateWithWhereUniqueWithoutDamage_classInput[]
    updateMany?: MoveUpdateManyWithWhereWithoutDamage_classInput | MoveUpdateManyWithWhereWithoutDamage_classInput[]
    deleteMany?: MoveScalarWhereInput | MoveScalarWhereInput[]
  }

  export type MoveUncheckedUpdateManyWithoutDamage_classNestedInput = {
    create?: XOR<MoveCreateWithoutDamage_classInput, MoveUncheckedCreateWithoutDamage_classInput> | MoveCreateWithoutDamage_classInput[] | MoveUncheckedCreateWithoutDamage_classInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutDamage_classInput | MoveCreateOrConnectWithoutDamage_classInput[]
    upsert?: MoveUpsertWithWhereUniqueWithoutDamage_classInput | MoveUpsertWithWhereUniqueWithoutDamage_classInput[]
    createMany?: MoveCreateManyDamage_classInputEnvelope
    set?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    disconnect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    delete?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    update?: MoveUpdateWithWhereUniqueWithoutDamage_classInput | MoveUpdateWithWhereUniqueWithoutDamage_classInput[]
    updateMany?: MoveUpdateManyWithWhereWithoutDamage_classInput | MoveUpdateManyWithWhereWithoutDamage_classInput[]
    deleteMany?: MoveScalarWhereInput | MoveScalarWhereInput[]
  }

  export type MoveCreateNestedManyWithoutEffectInput = {
    create?: XOR<MoveCreateWithoutEffectInput, MoveUncheckedCreateWithoutEffectInput> | MoveCreateWithoutEffectInput[] | MoveUncheckedCreateWithoutEffectInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutEffectInput | MoveCreateOrConnectWithoutEffectInput[]
    createMany?: MoveCreateManyEffectInputEnvelope
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
  }

  export type MoveUncheckedCreateNestedManyWithoutEffectInput = {
    create?: XOR<MoveCreateWithoutEffectInput, MoveUncheckedCreateWithoutEffectInput> | MoveCreateWithoutEffectInput[] | MoveUncheckedCreateWithoutEffectInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutEffectInput | MoveCreateOrConnectWithoutEffectInput[]
    createMany?: MoveCreateManyEffectInputEnvelope
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
  }

  export type MoveUpdateManyWithoutEffectNestedInput = {
    create?: XOR<MoveCreateWithoutEffectInput, MoveUncheckedCreateWithoutEffectInput> | MoveCreateWithoutEffectInput[] | MoveUncheckedCreateWithoutEffectInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutEffectInput | MoveCreateOrConnectWithoutEffectInput[]
    upsert?: MoveUpsertWithWhereUniqueWithoutEffectInput | MoveUpsertWithWhereUniqueWithoutEffectInput[]
    createMany?: MoveCreateManyEffectInputEnvelope
    set?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    disconnect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    delete?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    update?: MoveUpdateWithWhereUniqueWithoutEffectInput | MoveUpdateWithWhereUniqueWithoutEffectInput[]
    updateMany?: MoveUpdateManyWithWhereWithoutEffectInput | MoveUpdateManyWithWhereWithoutEffectInput[]
    deleteMany?: MoveScalarWhereInput | MoveScalarWhereInput[]
  }

  export type MoveUncheckedUpdateManyWithoutEffectNestedInput = {
    create?: XOR<MoveCreateWithoutEffectInput, MoveUncheckedCreateWithoutEffectInput> | MoveCreateWithoutEffectInput[] | MoveUncheckedCreateWithoutEffectInput[]
    connectOrCreate?: MoveCreateOrConnectWithoutEffectInput | MoveCreateOrConnectWithoutEffectInput[]
    upsert?: MoveUpsertWithWhereUniqueWithoutEffectInput | MoveUpsertWithWhereUniqueWithoutEffectInput[]
    createMany?: MoveCreateManyEffectInputEnvelope
    set?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    disconnect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    delete?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    connect?: MoveWhereUniqueInput | MoveWhereUniqueInput[]
    update?: MoveUpdateWithWhereUniqueWithoutEffectInput | MoveUpdateWithWhereUniqueWithoutEffectInput[]
    updateMany?: MoveUpdateManyWithWhereWithoutEffectInput | MoveUpdateManyWithWhereWithoutEffectInput[]
    deleteMany?: MoveScalarWhereInput | MoveScalarWhereInput[]
  }

  export type PokemonMoveCreateNestedManyWithoutMethodInput = {
    create?: XOR<PokemonMoveCreateWithoutMethodInput, PokemonMoveUncheckedCreateWithoutMethodInput> | PokemonMoveCreateWithoutMethodInput[] | PokemonMoveUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: PokemonMoveCreateOrConnectWithoutMethodInput | PokemonMoveCreateOrConnectWithoutMethodInput[]
    createMany?: PokemonMoveCreateManyMethodInputEnvelope
    connect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
  }

  export type PokemonMoveUncheckedCreateNestedManyWithoutMethodInput = {
    create?: XOR<PokemonMoveCreateWithoutMethodInput, PokemonMoveUncheckedCreateWithoutMethodInput> | PokemonMoveCreateWithoutMethodInput[] | PokemonMoveUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: PokemonMoveCreateOrConnectWithoutMethodInput | PokemonMoveCreateOrConnectWithoutMethodInput[]
    createMany?: PokemonMoveCreateManyMethodInputEnvelope
    connect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
  }

  export type PokemonMoveUpdateManyWithoutMethodNestedInput = {
    create?: XOR<PokemonMoveCreateWithoutMethodInput, PokemonMoveUncheckedCreateWithoutMethodInput> | PokemonMoveCreateWithoutMethodInput[] | PokemonMoveUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: PokemonMoveCreateOrConnectWithoutMethodInput | PokemonMoveCreateOrConnectWithoutMethodInput[]
    upsert?: PokemonMoveUpsertWithWhereUniqueWithoutMethodInput | PokemonMoveUpsertWithWhereUniqueWithoutMethodInput[]
    createMany?: PokemonMoveCreateManyMethodInputEnvelope
    set?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    disconnect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    delete?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    connect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    update?: PokemonMoveUpdateWithWhereUniqueWithoutMethodInput | PokemonMoveUpdateWithWhereUniqueWithoutMethodInput[]
    updateMany?: PokemonMoveUpdateManyWithWhereWithoutMethodInput | PokemonMoveUpdateManyWithWhereWithoutMethodInput[]
    deleteMany?: PokemonMoveScalarWhereInput | PokemonMoveScalarWhereInput[]
  }

  export type PokemonMoveUncheckedUpdateManyWithoutMethodNestedInput = {
    create?: XOR<PokemonMoveCreateWithoutMethodInput, PokemonMoveUncheckedCreateWithoutMethodInput> | PokemonMoveCreateWithoutMethodInput[] | PokemonMoveUncheckedCreateWithoutMethodInput[]
    connectOrCreate?: PokemonMoveCreateOrConnectWithoutMethodInput | PokemonMoveCreateOrConnectWithoutMethodInput[]
    upsert?: PokemonMoveUpsertWithWhereUniqueWithoutMethodInput | PokemonMoveUpsertWithWhereUniqueWithoutMethodInput[]
    createMany?: PokemonMoveCreateManyMethodInputEnvelope
    set?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    disconnect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    delete?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    connect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    update?: PokemonMoveUpdateWithWhereUniqueWithoutMethodInput | PokemonMoveUpdateWithWhereUniqueWithoutMethodInput[]
    updateMany?: PokemonMoveUpdateManyWithWhereWithoutMethodInput | PokemonMoveUpdateManyWithWhereWithoutMethodInput[]
    deleteMany?: PokemonMoveScalarWhereInput | PokemonMoveScalarWhereInput[]
  }

  export type TypeCreateNestedOneWithoutMoveInput = {
    create?: XOR<TypeCreateWithoutMoveInput, TypeUncheckedCreateWithoutMoveInput>
    connectOrCreate?: TypeCreateOrConnectWithoutMoveInput
    connect?: TypeWhereUniqueInput
  }

  export type MoveDamageClassCreateNestedOneWithoutMovesInput = {
    create?: XOR<MoveDamageClassCreateWithoutMovesInput, MoveDamageClassUncheckedCreateWithoutMovesInput>
    connectOrCreate?: MoveDamageClassCreateOrConnectWithoutMovesInput
    connect?: MoveDamageClassWhereUniqueInput
  }

  export type MoveEffectCreateNestedOneWithoutMovesInput = {
    create?: XOR<MoveEffectCreateWithoutMovesInput, MoveEffectUncheckedCreateWithoutMovesInput>
    connectOrCreate?: MoveEffectCreateOrConnectWithoutMovesInput
    connect?: MoveEffectWhereUniqueInput
  }

  export type PokemonMoveCreateNestedManyWithoutMoveInput = {
    create?: XOR<PokemonMoveCreateWithoutMoveInput, PokemonMoveUncheckedCreateWithoutMoveInput> | PokemonMoveCreateWithoutMoveInput[] | PokemonMoveUncheckedCreateWithoutMoveInput[]
    connectOrCreate?: PokemonMoveCreateOrConnectWithoutMoveInput | PokemonMoveCreateOrConnectWithoutMoveInput[]
    createMany?: PokemonMoveCreateManyMoveInputEnvelope
    connect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
  }

  export type PokemonMoveUncheckedCreateNestedManyWithoutMoveInput = {
    create?: XOR<PokemonMoveCreateWithoutMoveInput, PokemonMoveUncheckedCreateWithoutMoveInput> | PokemonMoveCreateWithoutMoveInput[] | PokemonMoveUncheckedCreateWithoutMoveInput[]
    connectOrCreate?: PokemonMoveCreateOrConnectWithoutMoveInput | PokemonMoveCreateOrConnectWithoutMoveInput[]
    createMany?: PokemonMoveCreateManyMoveInputEnvelope
    connect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TypeUpdateOneRequiredWithoutMoveNestedInput = {
    create?: XOR<TypeCreateWithoutMoveInput, TypeUncheckedCreateWithoutMoveInput>
    connectOrCreate?: TypeCreateOrConnectWithoutMoveInput
    upsert?: TypeUpsertWithoutMoveInput
    connect?: TypeWhereUniqueInput
    update?: XOR<XOR<TypeUpdateToOneWithWhereWithoutMoveInput, TypeUpdateWithoutMoveInput>, TypeUncheckedUpdateWithoutMoveInput>
  }

  export type MoveDamageClassUpdateOneRequiredWithoutMovesNestedInput = {
    create?: XOR<MoveDamageClassCreateWithoutMovesInput, MoveDamageClassUncheckedCreateWithoutMovesInput>
    connectOrCreate?: MoveDamageClassCreateOrConnectWithoutMovesInput
    upsert?: MoveDamageClassUpsertWithoutMovesInput
    connect?: MoveDamageClassWhereUniqueInput
    update?: XOR<XOR<MoveDamageClassUpdateToOneWithWhereWithoutMovesInput, MoveDamageClassUpdateWithoutMovesInput>, MoveDamageClassUncheckedUpdateWithoutMovesInput>
  }

  export type MoveEffectUpdateOneRequiredWithoutMovesNestedInput = {
    create?: XOR<MoveEffectCreateWithoutMovesInput, MoveEffectUncheckedCreateWithoutMovesInput>
    connectOrCreate?: MoveEffectCreateOrConnectWithoutMovesInput
    upsert?: MoveEffectUpsertWithoutMovesInput
    connect?: MoveEffectWhereUniqueInput
    update?: XOR<XOR<MoveEffectUpdateToOneWithWhereWithoutMovesInput, MoveEffectUpdateWithoutMovesInput>, MoveEffectUncheckedUpdateWithoutMovesInput>
  }

  export type PokemonMoveUpdateManyWithoutMoveNestedInput = {
    create?: XOR<PokemonMoveCreateWithoutMoveInput, PokemonMoveUncheckedCreateWithoutMoveInput> | PokemonMoveCreateWithoutMoveInput[] | PokemonMoveUncheckedCreateWithoutMoveInput[]
    connectOrCreate?: PokemonMoveCreateOrConnectWithoutMoveInput | PokemonMoveCreateOrConnectWithoutMoveInput[]
    upsert?: PokemonMoveUpsertWithWhereUniqueWithoutMoveInput | PokemonMoveUpsertWithWhereUniqueWithoutMoveInput[]
    createMany?: PokemonMoveCreateManyMoveInputEnvelope
    set?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    disconnect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    delete?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    connect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    update?: PokemonMoveUpdateWithWhereUniqueWithoutMoveInput | PokemonMoveUpdateWithWhereUniqueWithoutMoveInput[]
    updateMany?: PokemonMoveUpdateManyWithWhereWithoutMoveInput | PokemonMoveUpdateManyWithWhereWithoutMoveInput[]
    deleteMany?: PokemonMoveScalarWhereInput | PokemonMoveScalarWhereInput[]
  }

  export type PokemonMoveUncheckedUpdateManyWithoutMoveNestedInput = {
    create?: XOR<PokemonMoveCreateWithoutMoveInput, PokemonMoveUncheckedCreateWithoutMoveInput> | PokemonMoveCreateWithoutMoveInput[] | PokemonMoveUncheckedCreateWithoutMoveInput[]
    connectOrCreate?: PokemonMoveCreateOrConnectWithoutMoveInput | PokemonMoveCreateOrConnectWithoutMoveInput[]
    upsert?: PokemonMoveUpsertWithWhereUniqueWithoutMoveInput | PokemonMoveUpsertWithWhereUniqueWithoutMoveInput[]
    createMany?: PokemonMoveCreateManyMoveInputEnvelope
    set?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    disconnect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    delete?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    connect?: PokemonMoveWhereUniqueInput | PokemonMoveWhereUniqueInput[]
    update?: PokemonMoveUpdateWithWhereUniqueWithoutMoveInput | PokemonMoveUpdateWithWhereUniqueWithoutMoveInput[]
    updateMany?: PokemonMoveUpdateManyWithWhereWithoutMoveInput | PokemonMoveUpdateManyWithWhereWithoutMoveInput[]
    deleteMany?: PokemonMoveScalarWhereInput | PokemonMoveScalarWhereInput[]
  }

  export type VersionGroupCreateNestedOneWithoutMovesInput = {
    create?: XOR<VersionGroupCreateWithoutMovesInput, VersionGroupUncheckedCreateWithoutMovesInput>
    connectOrCreate?: VersionGroupCreateOrConnectWithoutMovesInput
    connect?: VersionGroupWhereUniqueInput
  }

  export type MoveMethodCreateNestedOneWithoutMovesInput = {
    create?: XOR<MoveMethodCreateWithoutMovesInput, MoveMethodUncheckedCreateWithoutMovesInput>
    connectOrCreate?: MoveMethodCreateOrConnectWithoutMovesInput
    connect?: MoveMethodWhereUniqueInput
  }

  export type MoveCreateNestedOneWithoutPokemon_movesInput = {
    create?: XOR<MoveCreateWithoutPokemon_movesInput, MoveUncheckedCreateWithoutPokemon_movesInput>
    connectOrCreate?: MoveCreateOrConnectWithoutPokemon_movesInput
    connect?: MoveWhereUniqueInput
  }

  export type PokemonCreateNestedOneWithoutMoveInput = {
    create?: XOR<PokemonCreateWithoutMoveInput, PokemonUncheckedCreateWithoutMoveInput>
    connectOrCreate?: PokemonCreateOrConnectWithoutMoveInput
    connect?: PokemonWhereUniqueInput
  }

  export type VersionGroupUpdateOneRequiredWithoutMovesNestedInput = {
    create?: XOR<VersionGroupCreateWithoutMovesInput, VersionGroupUncheckedCreateWithoutMovesInput>
    connectOrCreate?: VersionGroupCreateOrConnectWithoutMovesInput
    upsert?: VersionGroupUpsertWithoutMovesInput
    connect?: VersionGroupWhereUniqueInput
    update?: XOR<XOR<VersionGroupUpdateToOneWithWhereWithoutMovesInput, VersionGroupUpdateWithoutMovesInput>, VersionGroupUncheckedUpdateWithoutMovesInput>
  }

  export type MoveMethodUpdateOneRequiredWithoutMovesNestedInput = {
    create?: XOR<MoveMethodCreateWithoutMovesInput, MoveMethodUncheckedCreateWithoutMovesInput>
    connectOrCreate?: MoveMethodCreateOrConnectWithoutMovesInput
    upsert?: MoveMethodUpsertWithoutMovesInput
    connect?: MoveMethodWhereUniqueInput
    update?: XOR<XOR<MoveMethodUpdateToOneWithWhereWithoutMovesInput, MoveMethodUpdateWithoutMovesInput>, MoveMethodUncheckedUpdateWithoutMovesInput>
  }

  export type MoveUpdateOneRequiredWithoutPokemon_movesNestedInput = {
    create?: XOR<MoveCreateWithoutPokemon_movesInput, MoveUncheckedCreateWithoutPokemon_movesInput>
    connectOrCreate?: MoveCreateOrConnectWithoutPokemon_movesInput
    upsert?: MoveUpsertWithoutPokemon_movesInput
    connect?: MoveWhereUniqueInput
    update?: XOR<XOR<MoveUpdateToOneWithWhereWithoutPokemon_movesInput, MoveUpdateWithoutPokemon_movesInput>, MoveUncheckedUpdateWithoutPokemon_movesInput>
  }

  export type PokemonUpdateOneRequiredWithoutMoveNestedInput = {
    create?: XOR<PokemonCreateWithoutMoveInput, PokemonUncheckedCreateWithoutMoveInput>
    connectOrCreate?: PokemonCreateOrConnectWithoutMoveInput
    upsert?: PokemonUpsertWithoutMoveInput
    connect?: PokemonWhereUniqueInput
    update?: XOR<XOR<PokemonUpdateToOneWithWhereWithoutMoveInput, PokemonUpdateWithoutMoveInput>, PokemonUncheckedUpdateWithoutMoveInput>
  }

  export type RegionCreateNestedOneWithoutPokedexInput = {
    create?: XOR<RegionCreateWithoutPokedexInput, RegionUncheckedCreateWithoutPokedexInput>
    connectOrCreate?: RegionCreateOrConnectWithoutPokedexInput
    connect?: RegionWhereUniqueInput
  }

  export type PokedexVersionGroupCreateNestedManyWithoutPokedexInput = {
    create?: XOR<PokedexVersionGroupCreateWithoutPokedexInput, PokedexVersionGroupUncheckedCreateWithoutPokedexInput> | PokedexVersionGroupCreateWithoutPokedexInput[] | PokedexVersionGroupUncheckedCreateWithoutPokedexInput[]
    connectOrCreate?: PokedexVersionGroupCreateOrConnectWithoutPokedexInput | PokedexVersionGroupCreateOrConnectWithoutPokedexInput[]
    createMany?: PokedexVersionGroupCreateManyPokedexInputEnvelope
    connect?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
  }

  export type PokemonDexNumberCreateNestedManyWithoutPokedexInput = {
    create?: XOR<PokemonDexNumberCreateWithoutPokedexInput, PokemonDexNumberUncheckedCreateWithoutPokedexInput> | PokemonDexNumberCreateWithoutPokedexInput[] | PokemonDexNumberUncheckedCreateWithoutPokedexInput[]
    connectOrCreate?: PokemonDexNumberCreateOrConnectWithoutPokedexInput | PokemonDexNumberCreateOrConnectWithoutPokedexInput[]
    createMany?: PokemonDexNumberCreateManyPokedexInputEnvelope
    connect?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
  }

  export type PokedexVersionGroupUncheckedCreateNestedManyWithoutPokedexInput = {
    create?: XOR<PokedexVersionGroupCreateWithoutPokedexInput, PokedexVersionGroupUncheckedCreateWithoutPokedexInput> | PokedexVersionGroupCreateWithoutPokedexInput[] | PokedexVersionGroupUncheckedCreateWithoutPokedexInput[]
    connectOrCreate?: PokedexVersionGroupCreateOrConnectWithoutPokedexInput | PokedexVersionGroupCreateOrConnectWithoutPokedexInput[]
    createMany?: PokedexVersionGroupCreateManyPokedexInputEnvelope
    connect?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
  }

  export type PokemonDexNumberUncheckedCreateNestedManyWithoutPokedexInput = {
    create?: XOR<PokemonDexNumberCreateWithoutPokedexInput, PokemonDexNumberUncheckedCreateWithoutPokedexInput> | PokemonDexNumberCreateWithoutPokedexInput[] | PokemonDexNumberUncheckedCreateWithoutPokedexInput[]
    connectOrCreate?: PokemonDexNumberCreateOrConnectWithoutPokedexInput | PokemonDexNumberCreateOrConnectWithoutPokedexInput[]
    createMany?: PokemonDexNumberCreateManyPokedexInputEnvelope
    connect?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
  }

  export type RegionUpdateOneRequiredWithoutPokedexNestedInput = {
    create?: XOR<RegionCreateWithoutPokedexInput, RegionUncheckedCreateWithoutPokedexInput>
    connectOrCreate?: RegionCreateOrConnectWithoutPokedexInput
    upsert?: RegionUpsertWithoutPokedexInput
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutPokedexInput, RegionUpdateWithoutPokedexInput>, RegionUncheckedUpdateWithoutPokedexInput>
  }

  export type PokedexVersionGroupUpdateManyWithoutPokedexNestedInput = {
    create?: XOR<PokedexVersionGroupCreateWithoutPokedexInput, PokedexVersionGroupUncheckedCreateWithoutPokedexInput> | PokedexVersionGroupCreateWithoutPokedexInput[] | PokedexVersionGroupUncheckedCreateWithoutPokedexInput[]
    connectOrCreate?: PokedexVersionGroupCreateOrConnectWithoutPokedexInput | PokedexVersionGroupCreateOrConnectWithoutPokedexInput[]
    upsert?: PokedexVersionGroupUpsertWithWhereUniqueWithoutPokedexInput | PokedexVersionGroupUpsertWithWhereUniqueWithoutPokedexInput[]
    createMany?: PokedexVersionGroupCreateManyPokedexInputEnvelope
    set?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
    disconnect?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
    delete?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
    connect?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
    update?: PokedexVersionGroupUpdateWithWhereUniqueWithoutPokedexInput | PokedexVersionGroupUpdateWithWhereUniqueWithoutPokedexInput[]
    updateMany?: PokedexVersionGroupUpdateManyWithWhereWithoutPokedexInput | PokedexVersionGroupUpdateManyWithWhereWithoutPokedexInput[]
    deleteMany?: PokedexVersionGroupScalarWhereInput | PokedexVersionGroupScalarWhereInput[]
  }

  export type PokemonDexNumberUpdateManyWithoutPokedexNestedInput = {
    create?: XOR<PokemonDexNumberCreateWithoutPokedexInput, PokemonDexNumberUncheckedCreateWithoutPokedexInput> | PokemonDexNumberCreateWithoutPokedexInput[] | PokemonDexNumberUncheckedCreateWithoutPokedexInput[]
    connectOrCreate?: PokemonDexNumberCreateOrConnectWithoutPokedexInput | PokemonDexNumberCreateOrConnectWithoutPokedexInput[]
    upsert?: PokemonDexNumberUpsertWithWhereUniqueWithoutPokedexInput | PokemonDexNumberUpsertWithWhereUniqueWithoutPokedexInput[]
    createMany?: PokemonDexNumberCreateManyPokedexInputEnvelope
    set?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
    disconnect?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
    delete?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
    connect?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
    update?: PokemonDexNumberUpdateWithWhereUniqueWithoutPokedexInput | PokemonDexNumberUpdateWithWhereUniqueWithoutPokedexInput[]
    updateMany?: PokemonDexNumberUpdateManyWithWhereWithoutPokedexInput | PokemonDexNumberUpdateManyWithWhereWithoutPokedexInput[]
    deleteMany?: PokemonDexNumberScalarWhereInput | PokemonDexNumberScalarWhereInput[]
  }

  export type PokedexVersionGroupUncheckedUpdateManyWithoutPokedexNestedInput = {
    create?: XOR<PokedexVersionGroupCreateWithoutPokedexInput, PokedexVersionGroupUncheckedCreateWithoutPokedexInput> | PokedexVersionGroupCreateWithoutPokedexInput[] | PokedexVersionGroupUncheckedCreateWithoutPokedexInput[]
    connectOrCreate?: PokedexVersionGroupCreateOrConnectWithoutPokedexInput | PokedexVersionGroupCreateOrConnectWithoutPokedexInput[]
    upsert?: PokedexVersionGroupUpsertWithWhereUniqueWithoutPokedexInput | PokedexVersionGroupUpsertWithWhereUniqueWithoutPokedexInput[]
    createMany?: PokedexVersionGroupCreateManyPokedexInputEnvelope
    set?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
    disconnect?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
    delete?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
    connect?: PokedexVersionGroupWhereUniqueInput | PokedexVersionGroupWhereUniqueInput[]
    update?: PokedexVersionGroupUpdateWithWhereUniqueWithoutPokedexInput | PokedexVersionGroupUpdateWithWhereUniqueWithoutPokedexInput[]
    updateMany?: PokedexVersionGroupUpdateManyWithWhereWithoutPokedexInput | PokedexVersionGroupUpdateManyWithWhereWithoutPokedexInput[]
    deleteMany?: PokedexVersionGroupScalarWhereInput | PokedexVersionGroupScalarWhereInput[]
  }

  export type PokemonDexNumberUncheckedUpdateManyWithoutPokedexNestedInput = {
    create?: XOR<PokemonDexNumberCreateWithoutPokedexInput, PokemonDexNumberUncheckedCreateWithoutPokedexInput> | PokemonDexNumberCreateWithoutPokedexInput[] | PokemonDexNumberUncheckedCreateWithoutPokedexInput[]
    connectOrCreate?: PokemonDexNumberCreateOrConnectWithoutPokedexInput | PokemonDexNumberCreateOrConnectWithoutPokedexInput[]
    upsert?: PokemonDexNumberUpsertWithWhereUniqueWithoutPokedexInput | PokemonDexNumberUpsertWithWhereUniqueWithoutPokedexInput[]
    createMany?: PokemonDexNumberCreateManyPokedexInputEnvelope
    set?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
    disconnect?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
    delete?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
    connect?: PokemonDexNumberWhereUniqueInput | PokemonDexNumberWhereUniqueInput[]
    update?: PokemonDexNumberUpdateWithWhereUniqueWithoutPokedexInput | PokemonDexNumberUpdateWithWhereUniqueWithoutPokedexInput[]
    updateMany?: PokemonDexNumberUpdateManyWithWhereWithoutPokedexInput | PokemonDexNumberUpdateManyWithWhereWithoutPokedexInput[]
    deleteMany?: PokemonDexNumberScalarWhereInput | PokemonDexNumberScalarWhereInput[]
  }

  export type VersionGroupCreateNestedOneWithoutPokedex_version_groupsInput = {
    create?: XOR<VersionGroupCreateWithoutPokedex_version_groupsInput, VersionGroupUncheckedCreateWithoutPokedex_version_groupsInput>
    connectOrCreate?: VersionGroupCreateOrConnectWithoutPokedex_version_groupsInput
    connect?: VersionGroupWhereUniqueInput
  }

  export type PokedexCreateNestedOneWithoutPokedex_version_groupsInput = {
    create?: XOR<PokedexCreateWithoutPokedex_version_groupsInput, PokedexUncheckedCreateWithoutPokedex_version_groupsInput>
    connectOrCreate?: PokedexCreateOrConnectWithoutPokedex_version_groupsInput
    connect?: PokedexWhereUniqueInput
  }

  export type VersionGroupUpdateOneRequiredWithoutPokedex_version_groupsNestedInput = {
    create?: XOR<VersionGroupCreateWithoutPokedex_version_groupsInput, VersionGroupUncheckedCreateWithoutPokedex_version_groupsInput>
    connectOrCreate?: VersionGroupCreateOrConnectWithoutPokedex_version_groupsInput
    upsert?: VersionGroupUpsertWithoutPokedex_version_groupsInput
    connect?: VersionGroupWhereUniqueInput
    update?: XOR<XOR<VersionGroupUpdateToOneWithWhereWithoutPokedex_version_groupsInput, VersionGroupUpdateWithoutPokedex_version_groupsInput>, VersionGroupUncheckedUpdateWithoutPokedex_version_groupsInput>
  }

  export type PokedexUpdateOneRequiredWithoutPokedex_version_groupsNestedInput = {
    create?: XOR<PokedexCreateWithoutPokedex_version_groupsInput, PokedexUncheckedCreateWithoutPokedex_version_groupsInput>
    connectOrCreate?: PokedexCreateOrConnectWithoutPokedex_version_groupsInput
    upsert?: PokedexUpsertWithoutPokedex_version_groupsInput
    connect?: PokedexWhereUniqueInput
    update?: XOR<XOR<PokedexUpdateToOneWithWhereWithoutPokedex_version_groupsInput, PokedexUpdateWithoutPokedex_version_groupsInput>, PokedexUncheckedUpdateWithoutPokedex_version_groupsInput>
  }

  export type PokemonCreateNestedOneWithoutDex_numbersInput = {
    create?: XOR<PokemonCreateWithoutDex_numbersInput, PokemonUncheckedCreateWithoutDex_numbersInput>
    connectOrCreate?: PokemonCreateOrConnectWithoutDex_numbersInput
    connect?: PokemonWhereUniqueInput
  }

  export type PokedexCreateNestedOneWithoutPokemon_dex_numbersInput = {
    create?: XOR<PokedexCreateWithoutPokemon_dex_numbersInput, PokedexUncheckedCreateWithoutPokemon_dex_numbersInput>
    connectOrCreate?: PokedexCreateOrConnectWithoutPokemon_dex_numbersInput
    connect?: PokedexWhereUniqueInput
  }

  export type PokemonUpdateOneRequiredWithoutDex_numbersNestedInput = {
    create?: XOR<PokemonCreateWithoutDex_numbersInput, PokemonUncheckedCreateWithoutDex_numbersInput>
    connectOrCreate?: PokemonCreateOrConnectWithoutDex_numbersInput
    upsert?: PokemonUpsertWithoutDex_numbersInput
    connect?: PokemonWhereUniqueInput
    update?: XOR<XOR<PokemonUpdateToOneWithWhereWithoutDex_numbersInput, PokemonUpdateWithoutDex_numbersInput>, PokemonUncheckedUpdateWithoutDex_numbersInput>
  }

  export type PokedexUpdateOneRequiredWithoutPokemon_dex_numbersNestedInput = {
    create?: XOR<PokedexCreateWithoutPokemon_dex_numbersInput, PokedexUncheckedCreateWithoutPokemon_dex_numbersInput>
    connectOrCreate?: PokedexCreateOrConnectWithoutPokemon_dex_numbersInput
    upsert?: PokedexUpsertWithoutPokemon_dex_numbersInput
    connect?: PokedexWhereUniqueInput
    update?: XOR<XOR<PokedexUpdateToOneWithWhereWithoutPokemon_dex_numbersInput, PokedexUpdateWithoutPokemon_dex_numbersInput>, PokedexUncheckedUpdateWithoutPokemon_dex_numbersInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type PokemonAbilityCreateWithoutPokemonInput = {
    id: number
    is_hidden: boolean
    ability: AbilityCreateNestedOneWithoutPokemonInput
  }

  export type PokemonAbilityUncheckedCreateWithoutPokemonInput = {
    id: number
    ability_id: number
    is_hidden: boolean
  }

  export type PokemonAbilityCreateOrConnectWithoutPokemonInput = {
    where: PokemonAbilityWhereUniqueInput
    create: XOR<PokemonAbilityCreateWithoutPokemonInput, PokemonAbilityUncheckedCreateWithoutPokemonInput>
  }

  export type PokemonAbilityCreateManyPokemonInputEnvelope = {
    data: PokemonAbilityCreateManyPokemonInput | PokemonAbilityCreateManyPokemonInput[]
    skipDuplicates?: boolean
  }

  export type PokemonNatureCreateWithoutPokemonInput = {
    id: number
    nature: NatureCreateNestedOneWithoutPokemonInput
  }

  export type PokemonNatureUncheckedCreateWithoutPokemonInput = {
    id: number
    nature_id: number
  }

  export type PokemonNatureCreateOrConnectWithoutPokemonInput = {
    where: PokemonNatureWhereUniqueInput
    create: XOR<PokemonNatureCreateWithoutPokemonInput, PokemonNatureUncheckedCreateWithoutPokemonInput>
  }

  export type PokemonNatureCreateManyPokemonInputEnvelope = {
    data: PokemonNatureCreateManyPokemonInput | PokemonNatureCreateManyPokemonInput[]
    skipDuplicates?: boolean
  }

  export type PokemonStatCreateWithoutPokemonInput = {
    id: number
    base_stat: number
    stat: StatCreateNestedOneWithoutPokemon_statsInput
  }

  export type PokemonStatUncheckedCreateWithoutPokemonInput = {
    id: number
    stat_id: number
    base_stat: number
  }

  export type PokemonStatCreateOrConnectWithoutPokemonInput = {
    where: PokemonStatWhereUniqueInput
    create: XOR<PokemonStatCreateWithoutPokemonInput, PokemonStatUncheckedCreateWithoutPokemonInput>
  }

  export type PokemonStatCreateManyPokemonInputEnvelope = {
    data: PokemonStatCreateManyPokemonInput | PokemonStatCreateManyPokemonInput[]
    skipDuplicates?: boolean
  }

  export type PokemonTypeCreateWithoutPokemonInput = {
    id: number
    type: TypeCreateNestedOneWithoutPokemonInput
  }

  export type PokemonTypeUncheckedCreateWithoutPokemonInput = {
    id: number
    type_id: number
  }

  export type PokemonTypeCreateOrConnectWithoutPokemonInput = {
    where: PokemonTypeWhereUniqueInput
    create: XOR<PokemonTypeCreateWithoutPokemonInput, PokemonTypeUncheckedCreateWithoutPokemonInput>
  }

  export type PokemonTypeCreateManyPokemonInputEnvelope = {
    data: PokemonTypeCreateManyPokemonInput | PokemonTypeCreateManyPokemonInput[]
    skipDuplicates?: boolean
  }

  export type PokemonEggGroupCreateWithoutPokemonInput = {
    id: number
    egg_group: EggGroupCreateNestedOneWithoutPokemon_egg_groupInput
  }

  export type PokemonEggGroupUncheckedCreateWithoutPokemonInput = {
    id: number
    egg_group_id: number
  }

  export type PokemonEggGroupCreateOrConnectWithoutPokemonInput = {
    where: PokemonEggGroupWhereUniqueInput
    create: XOR<PokemonEggGroupCreateWithoutPokemonInput, PokemonEggGroupUncheckedCreateWithoutPokemonInput>
  }

  export type PokemonEggGroupCreateManyPokemonInputEnvelope = {
    data: PokemonEggGroupCreateManyPokemonInput | PokemonEggGroupCreateManyPokemonInput[]
    skipDuplicates?: boolean
  }

  export type EncounterCreateWithoutPokemonInput = {
    id: number
    min_level: number
    max_level: number
    version: VersionCreateNestedOneWithoutEncountersInput
    location_area: LocationAreaCreateNestedOneWithoutEncountersInput
    slot: EncounterSlotCreateNestedOneWithoutEncountersInput
    conditions?: EncounterConditionValueMapCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutPokemonInput = {
    id: number
    version_id: number
    location_area_id: number
    encounter_slot_id: number
    min_level: number
    max_level: number
    conditions?: EncounterConditionValueMapUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutPokemonInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutPokemonInput, EncounterUncheckedCreateWithoutPokemonInput>
  }

  export type EncounterCreateManyPokemonInputEnvelope = {
    data: EncounterCreateManyPokemonInput | EncounterCreateManyPokemonInput[]
    skipDuplicates?: boolean
  }

  export type PokemonDexNumberCreateWithoutPokemonInput = {
    id: number
    pokedex_number: number
    pokedex: PokedexCreateNestedOneWithoutPokemon_dex_numbersInput
  }

  export type PokemonDexNumberUncheckedCreateWithoutPokemonInput = {
    id: number
    pokedex_id: number
    pokedex_number: number
  }

  export type PokemonDexNumberCreateOrConnectWithoutPokemonInput = {
    where: PokemonDexNumberWhereUniqueInput
    create: XOR<PokemonDexNumberCreateWithoutPokemonInput, PokemonDexNumberUncheckedCreateWithoutPokemonInput>
  }

  export type PokemonDexNumberCreateManyPokemonInputEnvelope = {
    data: PokemonDexNumberCreateManyPokemonInput | PokemonDexNumberCreateManyPokemonInput[]
    skipDuplicates?: boolean
  }

  export type PokemonMoveCreateWithoutPokemonInput = {
    id: number
    level: number
    version_group: VersionGroupCreateNestedOneWithoutMovesInput
    method: MoveMethodCreateNestedOneWithoutMovesInput
    move: MoveCreateNestedOneWithoutPokemon_movesInput
  }

  export type PokemonMoveUncheckedCreateWithoutPokemonInput = {
    id: number
    version_group_id: number
    move_method_id: number
    move_id: number
    level: number
  }

  export type PokemonMoveCreateOrConnectWithoutPokemonInput = {
    where: PokemonMoveWhereUniqueInput
    create: XOR<PokemonMoveCreateWithoutPokemonInput, PokemonMoveUncheckedCreateWithoutPokemonInput>
  }

  export type PokemonMoveCreateManyPokemonInputEnvelope = {
    data: PokemonMoveCreateManyPokemonInput | PokemonMoveCreateManyPokemonInput[]
    skipDuplicates?: boolean
  }

  export type PokemonAbilityUpsertWithWhereUniqueWithoutPokemonInput = {
    where: PokemonAbilityWhereUniqueInput
    update: XOR<PokemonAbilityUpdateWithoutPokemonInput, PokemonAbilityUncheckedUpdateWithoutPokemonInput>
    create: XOR<PokemonAbilityCreateWithoutPokemonInput, PokemonAbilityUncheckedCreateWithoutPokemonInput>
  }

  export type PokemonAbilityUpdateWithWhereUniqueWithoutPokemonInput = {
    where: PokemonAbilityWhereUniqueInput
    data: XOR<PokemonAbilityUpdateWithoutPokemonInput, PokemonAbilityUncheckedUpdateWithoutPokemonInput>
  }

  export type PokemonAbilityUpdateManyWithWhereWithoutPokemonInput = {
    where: PokemonAbilityScalarWhereInput
    data: XOR<PokemonAbilityUpdateManyMutationInput, PokemonAbilityUncheckedUpdateManyWithoutPokemonInput>
  }

  export type PokemonAbilityScalarWhereInput = {
    AND?: PokemonAbilityScalarWhereInput | PokemonAbilityScalarWhereInput[]
    OR?: PokemonAbilityScalarWhereInput[]
    NOT?: PokemonAbilityScalarWhereInput | PokemonAbilityScalarWhereInput[]
    id?: IntFilter<"PokemonAbility"> | number
    pokemon_id?: IntFilter<"PokemonAbility"> | number
    ability_id?: IntFilter<"PokemonAbility"> | number
    is_hidden?: BoolFilter<"PokemonAbility"> | boolean
  }

  export type PokemonNatureUpsertWithWhereUniqueWithoutPokemonInput = {
    where: PokemonNatureWhereUniqueInput
    update: XOR<PokemonNatureUpdateWithoutPokemonInput, PokemonNatureUncheckedUpdateWithoutPokemonInput>
    create: XOR<PokemonNatureCreateWithoutPokemonInput, PokemonNatureUncheckedCreateWithoutPokemonInput>
  }

  export type PokemonNatureUpdateWithWhereUniqueWithoutPokemonInput = {
    where: PokemonNatureWhereUniqueInput
    data: XOR<PokemonNatureUpdateWithoutPokemonInput, PokemonNatureUncheckedUpdateWithoutPokemonInput>
  }

  export type PokemonNatureUpdateManyWithWhereWithoutPokemonInput = {
    where: PokemonNatureScalarWhereInput
    data: XOR<PokemonNatureUpdateManyMutationInput, PokemonNatureUncheckedUpdateManyWithoutPokemonInput>
  }

  export type PokemonNatureScalarWhereInput = {
    AND?: PokemonNatureScalarWhereInput | PokemonNatureScalarWhereInput[]
    OR?: PokemonNatureScalarWhereInput[]
    NOT?: PokemonNatureScalarWhereInput | PokemonNatureScalarWhereInput[]
    id?: IntFilter<"PokemonNature"> | number
    pokemon_id?: IntFilter<"PokemonNature"> | number
    nature_id?: IntFilter<"PokemonNature"> | number
  }

  export type PokemonStatUpsertWithWhereUniqueWithoutPokemonInput = {
    where: PokemonStatWhereUniqueInput
    update: XOR<PokemonStatUpdateWithoutPokemonInput, PokemonStatUncheckedUpdateWithoutPokemonInput>
    create: XOR<PokemonStatCreateWithoutPokemonInput, PokemonStatUncheckedCreateWithoutPokemonInput>
  }

  export type PokemonStatUpdateWithWhereUniqueWithoutPokemonInput = {
    where: PokemonStatWhereUniqueInput
    data: XOR<PokemonStatUpdateWithoutPokemonInput, PokemonStatUncheckedUpdateWithoutPokemonInput>
  }

  export type PokemonStatUpdateManyWithWhereWithoutPokemonInput = {
    where: PokemonStatScalarWhereInput
    data: XOR<PokemonStatUpdateManyMutationInput, PokemonStatUncheckedUpdateManyWithoutPokemonInput>
  }

  export type PokemonStatScalarWhereInput = {
    AND?: PokemonStatScalarWhereInput | PokemonStatScalarWhereInput[]
    OR?: PokemonStatScalarWhereInput[]
    NOT?: PokemonStatScalarWhereInput | PokemonStatScalarWhereInput[]
    id?: IntFilter<"PokemonStat"> | number
    pokemon_id?: IntFilter<"PokemonStat"> | number
    stat_id?: IntFilter<"PokemonStat"> | number
    base_stat?: IntFilter<"PokemonStat"> | number
  }

  export type PokemonTypeUpsertWithWhereUniqueWithoutPokemonInput = {
    where: PokemonTypeWhereUniqueInput
    update: XOR<PokemonTypeUpdateWithoutPokemonInput, PokemonTypeUncheckedUpdateWithoutPokemonInput>
    create: XOR<PokemonTypeCreateWithoutPokemonInput, PokemonTypeUncheckedCreateWithoutPokemonInput>
  }

  export type PokemonTypeUpdateWithWhereUniqueWithoutPokemonInput = {
    where: PokemonTypeWhereUniqueInput
    data: XOR<PokemonTypeUpdateWithoutPokemonInput, PokemonTypeUncheckedUpdateWithoutPokemonInput>
  }

  export type PokemonTypeUpdateManyWithWhereWithoutPokemonInput = {
    where: PokemonTypeScalarWhereInput
    data: XOR<PokemonTypeUpdateManyMutationInput, PokemonTypeUncheckedUpdateManyWithoutPokemonInput>
  }

  export type PokemonTypeScalarWhereInput = {
    AND?: PokemonTypeScalarWhereInput | PokemonTypeScalarWhereInput[]
    OR?: PokemonTypeScalarWhereInput[]
    NOT?: PokemonTypeScalarWhereInput | PokemonTypeScalarWhereInput[]
    id?: IntFilter<"PokemonType"> | number
    pokemon_id?: IntFilter<"PokemonType"> | number
    type_id?: IntFilter<"PokemonType"> | number
  }

  export type PokemonEggGroupUpsertWithWhereUniqueWithoutPokemonInput = {
    where: PokemonEggGroupWhereUniqueInput
    update: XOR<PokemonEggGroupUpdateWithoutPokemonInput, PokemonEggGroupUncheckedUpdateWithoutPokemonInput>
    create: XOR<PokemonEggGroupCreateWithoutPokemonInput, PokemonEggGroupUncheckedCreateWithoutPokemonInput>
  }

  export type PokemonEggGroupUpdateWithWhereUniqueWithoutPokemonInput = {
    where: PokemonEggGroupWhereUniqueInput
    data: XOR<PokemonEggGroupUpdateWithoutPokemonInput, PokemonEggGroupUncheckedUpdateWithoutPokemonInput>
  }

  export type PokemonEggGroupUpdateManyWithWhereWithoutPokemonInput = {
    where: PokemonEggGroupScalarWhereInput
    data: XOR<PokemonEggGroupUpdateManyMutationInput, PokemonEggGroupUncheckedUpdateManyWithoutPokemonInput>
  }

  export type PokemonEggGroupScalarWhereInput = {
    AND?: PokemonEggGroupScalarWhereInput | PokemonEggGroupScalarWhereInput[]
    OR?: PokemonEggGroupScalarWhereInput[]
    NOT?: PokemonEggGroupScalarWhereInput | PokemonEggGroupScalarWhereInput[]
    id?: IntFilter<"PokemonEggGroup"> | number
    pokemon_id?: IntFilter<"PokemonEggGroup"> | number
    egg_group_id?: IntFilter<"PokemonEggGroup"> | number
  }

  export type EncounterUpsertWithWhereUniqueWithoutPokemonInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutPokemonInput, EncounterUncheckedUpdateWithoutPokemonInput>
    create: XOR<EncounterCreateWithoutPokemonInput, EncounterUncheckedCreateWithoutPokemonInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutPokemonInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutPokemonInput, EncounterUncheckedUpdateWithoutPokemonInput>
  }

  export type EncounterUpdateManyWithWhereWithoutPokemonInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutPokemonInput>
  }

  export type EncounterScalarWhereInput = {
    AND?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    OR?: EncounterScalarWhereInput[]
    NOT?: EncounterScalarWhereInput | EncounterScalarWhereInput[]
    id?: IntFilter<"Encounter"> | number
    version_id?: IntFilter<"Encounter"> | number
    pokemon_id?: IntFilter<"Encounter"> | number
    location_area_id?: IntFilter<"Encounter"> | number
    encounter_slot_id?: IntFilter<"Encounter"> | number
    min_level?: IntFilter<"Encounter"> | number
    max_level?: IntFilter<"Encounter"> | number
  }

  export type PokemonDexNumberUpsertWithWhereUniqueWithoutPokemonInput = {
    where: PokemonDexNumberWhereUniqueInput
    update: XOR<PokemonDexNumberUpdateWithoutPokemonInput, PokemonDexNumberUncheckedUpdateWithoutPokemonInput>
    create: XOR<PokemonDexNumberCreateWithoutPokemonInput, PokemonDexNumberUncheckedCreateWithoutPokemonInput>
  }

  export type PokemonDexNumberUpdateWithWhereUniqueWithoutPokemonInput = {
    where: PokemonDexNumberWhereUniqueInput
    data: XOR<PokemonDexNumberUpdateWithoutPokemonInput, PokemonDexNumberUncheckedUpdateWithoutPokemonInput>
  }

  export type PokemonDexNumberUpdateManyWithWhereWithoutPokemonInput = {
    where: PokemonDexNumberScalarWhereInput
    data: XOR<PokemonDexNumberUpdateManyMutationInput, PokemonDexNumberUncheckedUpdateManyWithoutPokemonInput>
  }

  export type PokemonDexNumberScalarWhereInput = {
    AND?: PokemonDexNumberScalarWhereInput | PokemonDexNumberScalarWhereInput[]
    OR?: PokemonDexNumberScalarWhereInput[]
    NOT?: PokemonDexNumberScalarWhereInput | PokemonDexNumberScalarWhereInput[]
    id?: IntFilter<"PokemonDexNumber"> | number
    pokemon_id?: IntFilter<"PokemonDexNumber"> | number
    pokedex_id?: IntFilter<"PokemonDexNumber"> | number
    pokedex_number?: IntFilter<"PokemonDexNumber"> | number
  }

  export type PokemonMoveUpsertWithWhereUniqueWithoutPokemonInput = {
    where: PokemonMoveWhereUniqueInput
    update: XOR<PokemonMoveUpdateWithoutPokemonInput, PokemonMoveUncheckedUpdateWithoutPokemonInput>
    create: XOR<PokemonMoveCreateWithoutPokemonInput, PokemonMoveUncheckedCreateWithoutPokemonInput>
  }

  export type PokemonMoveUpdateWithWhereUniqueWithoutPokemonInput = {
    where: PokemonMoveWhereUniqueInput
    data: XOR<PokemonMoveUpdateWithoutPokemonInput, PokemonMoveUncheckedUpdateWithoutPokemonInput>
  }

  export type PokemonMoveUpdateManyWithWhereWithoutPokemonInput = {
    where: PokemonMoveScalarWhereInput
    data: XOR<PokemonMoveUpdateManyMutationInput, PokemonMoveUncheckedUpdateManyWithoutPokemonInput>
  }

  export type PokemonMoveScalarWhereInput = {
    AND?: PokemonMoveScalarWhereInput | PokemonMoveScalarWhereInput[]
    OR?: PokemonMoveScalarWhereInput[]
    NOT?: PokemonMoveScalarWhereInput | PokemonMoveScalarWhereInput[]
    id?: IntFilter<"PokemonMove"> | number
    version_group_id?: IntFilter<"PokemonMove"> | number
    move_method_id?: IntFilter<"PokemonMove"> | number
    move_id?: IntFilter<"PokemonMove"> | number
    pokemon_id?: IntFilter<"PokemonMove"> | number
    level?: IntFilter<"PokemonMove"> | number
  }

  export type PokemonAbilityCreateWithoutAbilityInput = {
    id: number
    is_hidden: boolean
    pokemon: PokemonCreateNestedOneWithoutAbilitiesInput
  }

  export type PokemonAbilityUncheckedCreateWithoutAbilityInput = {
    id: number
    pokemon_id: number
    is_hidden: boolean
  }

  export type PokemonAbilityCreateOrConnectWithoutAbilityInput = {
    where: PokemonAbilityWhereUniqueInput
    create: XOR<PokemonAbilityCreateWithoutAbilityInput, PokemonAbilityUncheckedCreateWithoutAbilityInput>
  }

  export type PokemonAbilityCreateManyAbilityInputEnvelope = {
    data: PokemonAbilityCreateManyAbilityInput | PokemonAbilityCreateManyAbilityInput[]
    skipDuplicates?: boolean
  }

  export type PokemonAbilityUpsertWithWhereUniqueWithoutAbilityInput = {
    where: PokemonAbilityWhereUniqueInput
    update: XOR<PokemonAbilityUpdateWithoutAbilityInput, PokemonAbilityUncheckedUpdateWithoutAbilityInput>
    create: XOR<PokemonAbilityCreateWithoutAbilityInput, PokemonAbilityUncheckedCreateWithoutAbilityInput>
  }

  export type PokemonAbilityUpdateWithWhereUniqueWithoutAbilityInput = {
    where: PokemonAbilityWhereUniqueInput
    data: XOR<PokemonAbilityUpdateWithoutAbilityInput, PokemonAbilityUncheckedUpdateWithoutAbilityInput>
  }

  export type PokemonAbilityUpdateManyWithWhereWithoutAbilityInput = {
    where: PokemonAbilityScalarWhereInput
    data: XOR<PokemonAbilityUpdateManyMutationInput, PokemonAbilityUncheckedUpdateManyWithoutAbilityInput>
  }

  export type PokemonCreateWithoutAbilitiesInput = {
    id: number
    name: string
    natures?: PokemonNatureCreateNestedManyWithoutPokemonInput
    stats?: PokemonStatCreateNestedManyWithoutPokemonInput
    types?: PokemonTypeCreateNestedManyWithoutPokemonInput
    egg_groups?: PokemonEggGroupCreateNestedManyWithoutPokemonInput
    encounters?: EncounterCreateNestedManyWithoutPokemonInput
    dex_numbers?: PokemonDexNumberCreateNestedManyWithoutPokemonInput
    move?: PokemonMoveCreateNestedManyWithoutPokemonInput
  }

  export type PokemonUncheckedCreateWithoutAbilitiesInput = {
    id: number
    name: string
    natures?: PokemonNatureUncheckedCreateNestedManyWithoutPokemonInput
    stats?: PokemonStatUncheckedCreateNestedManyWithoutPokemonInput
    types?: PokemonTypeUncheckedCreateNestedManyWithoutPokemonInput
    egg_groups?: PokemonEggGroupUncheckedCreateNestedManyWithoutPokemonInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutPokemonInput
    dex_numbers?: PokemonDexNumberUncheckedCreateNestedManyWithoutPokemonInput
    move?: PokemonMoveUncheckedCreateNestedManyWithoutPokemonInput
  }

  export type PokemonCreateOrConnectWithoutAbilitiesInput = {
    where: PokemonWhereUniqueInput
    create: XOR<PokemonCreateWithoutAbilitiesInput, PokemonUncheckedCreateWithoutAbilitiesInput>
  }

  export type AbilityCreateWithoutPokemonInput = {
    id: number
    name: string
    description: string
  }

  export type AbilityUncheckedCreateWithoutPokemonInput = {
    id: number
    name: string
    description: string
  }

  export type AbilityCreateOrConnectWithoutPokemonInput = {
    where: AbilityWhereUniqueInput
    create: XOR<AbilityCreateWithoutPokemonInput, AbilityUncheckedCreateWithoutPokemonInput>
  }

  export type PokemonUpsertWithoutAbilitiesInput = {
    update: XOR<PokemonUpdateWithoutAbilitiesInput, PokemonUncheckedUpdateWithoutAbilitiesInput>
    create: XOR<PokemonCreateWithoutAbilitiesInput, PokemonUncheckedCreateWithoutAbilitiesInput>
    where?: PokemonWhereInput
  }

  export type PokemonUpdateToOneWithWhereWithoutAbilitiesInput = {
    where?: PokemonWhereInput
    data: XOR<PokemonUpdateWithoutAbilitiesInput, PokemonUncheckedUpdateWithoutAbilitiesInput>
  }

  export type PokemonUpdateWithoutAbilitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    natures?: PokemonNatureUpdateManyWithoutPokemonNestedInput
    stats?: PokemonStatUpdateManyWithoutPokemonNestedInput
    types?: PokemonTypeUpdateManyWithoutPokemonNestedInput
    egg_groups?: PokemonEggGroupUpdateManyWithoutPokemonNestedInput
    encounters?: EncounterUpdateManyWithoutPokemonNestedInput
    dex_numbers?: PokemonDexNumberUpdateManyWithoutPokemonNestedInput
    move?: PokemonMoveUpdateManyWithoutPokemonNestedInput
  }

  export type PokemonUncheckedUpdateWithoutAbilitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    natures?: PokemonNatureUncheckedUpdateManyWithoutPokemonNestedInput
    stats?: PokemonStatUncheckedUpdateManyWithoutPokemonNestedInput
    types?: PokemonTypeUncheckedUpdateManyWithoutPokemonNestedInput
    egg_groups?: PokemonEggGroupUncheckedUpdateManyWithoutPokemonNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutPokemonNestedInput
    dex_numbers?: PokemonDexNumberUncheckedUpdateManyWithoutPokemonNestedInput
    move?: PokemonMoveUncheckedUpdateManyWithoutPokemonNestedInput
  }

  export type AbilityUpsertWithoutPokemonInput = {
    update: XOR<AbilityUpdateWithoutPokemonInput, AbilityUncheckedUpdateWithoutPokemonInput>
    create: XOR<AbilityCreateWithoutPokemonInput, AbilityUncheckedCreateWithoutPokemonInput>
    where?: AbilityWhereInput
  }

  export type AbilityUpdateToOneWithWhereWithoutPokemonInput = {
    where?: AbilityWhereInput
    data: XOR<AbilityUpdateWithoutPokemonInput, AbilityUncheckedUpdateWithoutPokemonInput>
  }

  export type AbilityUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type AbilityUncheckedUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type StatCreateWithoutNatures_increaseInput = {
    id: number
    name: string
    natures_decrease?: NatureCreateNestedManyWithoutStat_decreasedInput
    pokemon_stats?: PokemonStatCreateNestedManyWithoutStatInput
  }

  export type StatUncheckedCreateWithoutNatures_increaseInput = {
    id: number
    name: string
    natures_decrease?: NatureUncheckedCreateNestedManyWithoutStat_decreasedInput
    pokemon_stats?: PokemonStatUncheckedCreateNestedManyWithoutStatInput
  }

  export type StatCreateOrConnectWithoutNatures_increaseInput = {
    where: StatWhereUniqueInput
    create: XOR<StatCreateWithoutNatures_increaseInput, StatUncheckedCreateWithoutNatures_increaseInput>
  }

  export type StatCreateWithoutNatures_decreaseInput = {
    id: number
    name: string
    natures_increase?: NatureCreateNestedManyWithoutStat_increasedInput
    pokemon_stats?: PokemonStatCreateNestedManyWithoutStatInput
  }

  export type StatUncheckedCreateWithoutNatures_decreaseInput = {
    id: number
    name: string
    natures_increase?: NatureUncheckedCreateNestedManyWithoutStat_increasedInput
    pokemon_stats?: PokemonStatUncheckedCreateNestedManyWithoutStatInput
  }

  export type StatCreateOrConnectWithoutNatures_decreaseInput = {
    where: StatWhereUniqueInput
    create: XOR<StatCreateWithoutNatures_decreaseInput, StatUncheckedCreateWithoutNatures_decreaseInput>
  }

  export type PokemonNatureCreateWithoutNatureInput = {
    id: number
    pokemon: PokemonCreateNestedOneWithoutNaturesInput
  }

  export type PokemonNatureUncheckedCreateWithoutNatureInput = {
    id: number
    pokemon_id: number
  }

  export type PokemonNatureCreateOrConnectWithoutNatureInput = {
    where: PokemonNatureWhereUniqueInput
    create: XOR<PokemonNatureCreateWithoutNatureInput, PokemonNatureUncheckedCreateWithoutNatureInput>
  }

  export type PokemonNatureCreateManyNatureInputEnvelope = {
    data: PokemonNatureCreateManyNatureInput | PokemonNatureCreateManyNatureInput[]
    skipDuplicates?: boolean
  }

  export type StatUpsertWithoutNatures_increaseInput = {
    update: XOR<StatUpdateWithoutNatures_increaseInput, StatUncheckedUpdateWithoutNatures_increaseInput>
    create: XOR<StatCreateWithoutNatures_increaseInput, StatUncheckedCreateWithoutNatures_increaseInput>
    where?: StatWhereInput
  }

  export type StatUpdateToOneWithWhereWithoutNatures_increaseInput = {
    where?: StatWhereInput
    data: XOR<StatUpdateWithoutNatures_increaseInput, StatUncheckedUpdateWithoutNatures_increaseInput>
  }

  export type StatUpdateWithoutNatures_increaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    natures_decrease?: NatureUpdateManyWithoutStat_decreasedNestedInput
    pokemon_stats?: PokemonStatUpdateManyWithoutStatNestedInput
  }

  export type StatUncheckedUpdateWithoutNatures_increaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    natures_decrease?: NatureUncheckedUpdateManyWithoutStat_decreasedNestedInput
    pokemon_stats?: PokemonStatUncheckedUpdateManyWithoutStatNestedInput
  }

  export type StatUpsertWithoutNatures_decreaseInput = {
    update: XOR<StatUpdateWithoutNatures_decreaseInput, StatUncheckedUpdateWithoutNatures_decreaseInput>
    create: XOR<StatCreateWithoutNatures_decreaseInput, StatUncheckedCreateWithoutNatures_decreaseInput>
    where?: StatWhereInput
  }

  export type StatUpdateToOneWithWhereWithoutNatures_decreaseInput = {
    where?: StatWhereInput
    data: XOR<StatUpdateWithoutNatures_decreaseInput, StatUncheckedUpdateWithoutNatures_decreaseInput>
  }

  export type StatUpdateWithoutNatures_decreaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    natures_increase?: NatureUpdateManyWithoutStat_increasedNestedInput
    pokemon_stats?: PokemonStatUpdateManyWithoutStatNestedInput
  }

  export type StatUncheckedUpdateWithoutNatures_decreaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    natures_increase?: NatureUncheckedUpdateManyWithoutStat_increasedNestedInput
    pokemon_stats?: PokemonStatUncheckedUpdateManyWithoutStatNestedInput
  }

  export type PokemonNatureUpsertWithWhereUniqueWithoutNatureInput = {
    where: PokemonNatureWhereUniqueInput
    update: XOR<PokemonNatureUpdateWithoutNatureInput, PokemonNatureUncheckedUpdateWithoutNatureInput>
    create: XOR<PokemonNatureCreateWithoutNatureInput, PokemonNatureUncheckedCreateWithoutNatureInput>
  }

  export type PokemonNatureUpdateWithWhereUniqueWithoutNatureInput = {
    where: PokemonNatureWhereUniqueInput
    data: XOR<PokemonNatureUpdateWithoutNatureInput, PokemonNatureUncheckedUpdateWithoutNatureInput>
  }

  export type PokemonNatureUpdateManyWithWhereWithoutNatureInput = {
    where: PokemonNatureScalarWhereInput
    data: XOR<PokemonNatureUpdateManyMutationInput, PokemonNatureUncheckedUpdateManyWithoutNatureInput>
  }

  export type PokemonCreateWithoutNaturesInput = {
    id: number
    name: string
    abilities?: PokemonAbilityCreateNestedManyWithoutPokemonInput
    stats?: PokemonStatCreateNestedManyWithoutPokemonInput
    types?: PokemonTypeCreateNestedManyWithoutPokemonInput
    egg_groups?: PokemonEggGroupCreateNestedManyWithoutPokemonInput
    encounters?: EncounterCreateNestedManyWithoutPokemonInput
    dex_numbers?: PokemonDexNumberCreateNestedManyWithoutPokemonInput
    move?: PokemonMoveCreateNestedManyWithoutPokemonInput
  }

  export type PokemonUncheckedCreateWithoutNaturesInput = {
    id: number
    name: string
    abilities?: PokemonAbilityUncheckedCreateNestedManyWithoutPokemonInput
    stats?: PokemonStatUncheckedCreateNestedManyWithoutPokemonInput
    types?: PokemonTypeUncheckedCreateNestedManyWithoutPokemonInput
    egg_groups?: PokemonEggGroupUncheckedCreateNestedManyWithoutPokemonInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutPokemonInput
    dex_numbers?: PokemonDexNumberUncheckedCreateNestedManyWithoutPokemonInput
    move?: PokemonMoveUncheckedCreateNestedManyWithoutPokemonInput
  }

  export type PokemonCreateOrConnectWithoutNaturesInput = {
    where: PokemonWhereUniqueInput
    create: XOR<PokemonCreateWithoutNaturesInput, PokemonUncheckedCreateWithoutNaturesInput>
  }

  export type NatureCreateWithoutPokemonInput = {
    id: number
    name: string
    stat_increased: StatCreateNestedOneWithoutNatures_increaseInput
    stat_decreased: StatCreateNestedOneWithoutNatures_decreaseInput
  }

  export type NatureUncheckedCreateWithoutPokemonInput = {
    id: number
    name: string
    increased_stat_id: number
    decreased_stat_id: number
  }

  export type NatureCreateOrConnectWithoutPokemonInput = {
    where: NatureWhereUniqueInput
    create: XOR<NatureCreateWithoutPokemonInput, NatureUncheckedCreateWithoutPokemonInput>
  }

  export type PokemonUpsertWithoutNaturesInput = {
    update: XOR<PokemonUpdateWithoutNaturesInput, PokemonUncheckedUpdateWithoutNaturesInput>
    create: XOR<PokemonCreateWithoutNaturesInput, PokemonUncheckedCreateWithoutNaturesInput>
    where?: PokemonWhereInput
  }

  export type PokemonUpdateToOneWithWhereWithoutNaturesInput = {
    where?: PokemonWhereInput
    data: XOR<PokemonUpdateWithoutNaturesInput, PokemonUncheckedUpdateWithoutNaturesInput>
  }

  export type PokemonUpdateWithoutNaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abilities?: PokemonAbilityUpdateManyWithoutPokemonNestedInput
    stats?: PokemonStatUpdateManyWithoutPokemonNestedInput
    types?: PokemonTypeUpdateManyWithoutPokemonNestedInput
    egg_groups?: PokemonEggGroupUpdateManyWithoutPokemonNestedInput
    encounters?: EncounterUpdateManyWithoutPokemonNestedInput
    dex_numbers?: PokemonDexNumberUpdateManyWithoutPokemonNestedInput
    move?: PokemonMoveUpdateManyWithoutPokemonNestedInput
  }

  export type PokemonUncheckedUpdateWithoutNaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abilities?: PokemonAbilityUncheckedUpdateManyWithoutPokemonNestedInput
    stats?: PokemonStatUncheckedUpdateManyWithoutPokemonNestedInput
    types?: PokemonTypeUncheckedUpdateManyWithoutPokemonNestedInput
    egg_groups?: PokemonEggGroupUncheckedUpdateManyWithoutPokemonNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutPokemonNestedInput
    dex_numbers?: PokemonDexNumberUncheckedUpdateManyWithoutPokemonNestedInput
    move?: PokemonMoveUncheckedUpdateManyWithoutPokemonNestedInput
  }

  export type NatureUpsertWithoutPokemonInput = {
    update: XOR<NatureUpdateWithoutPokemonInput, NatureUncheckedUpdateWithoutPokemonInput>
    create: XOR<NatureCreateWithoutPokemonInput, NatureUncheckedCreateWithoutPokemonInput>
    where?: NatureWhereInput
  }

  export type NatureUpdateToOneWithWhereWithoutPokemonInput = {
    where?: NatureWhereInput
    data: XOR<NatureUpdateWithoutPokemonInput, NatureUncheckedUpdateWithoutPokemonInput>
  }

  export type NatureUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    stat_increased?: StatUpdateOneRequiredWithoutNatures_increaseNestedInput
    stat_decreased?: StatUpdateOneRequiredWithoutNatures_decreaseNestedInput
  }

  export type NatureUncheckedUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    increased_stat_id?: IntFieldUpdateOperationsInput | number
    decreased_stat_id?: IntFieldUpdateOperationsInput | number
  }

  export type NatureCreateWithoutStat_increasedInput = {
    id: number
    name: string
    stat_decreased: StatCreateNestedOneWithoutNatures_decreaseInput
    pokemon?: PokemonNatureCreateNestedManyWithoutNatureInput
  }

  export type NatureUncheckedCreateWithoutStat_increasedInput = {
    id: number
    name: string
    decreased_stat_id: number
    pokemon?: PokemonNatureUncheckedCreateNestedManyWithoutNatureInput
  }

  export type NatureCreateOrConnectWithoutStat_increasedInput = {
    where: NatureWhereUniqueInput
    create: XOR<NatureCreateWithoutStat_increasedInput, NatureUncheckedCreateWithoutStat_increasedInput>
  }

  export type NatureCreateManyStat_increasedInputEnvelope = {
    data: NatureCreateManyStat_increasedInput | NatureCreateManyStat_increasedInput[]
    skipDuplicates?: boolean
  }

  export type NatureCreateWithoutStat_decreasedInput = {
    id: number
    name: string
    stat_increased: StatCreateNestedOneWithoutNatures_increaseInput
    pokemon?: PokemonNatureCreateNestedManyWithoutNatureInput
  }

  export type NatureUncheckedCreateWithoutStat_decreasedInput = {
    id: number
    name: string
    increased_stat_id: number
    pokemon?: PokemonNatureUncheckedCreateNestedManyWithoutNatureInput
  }

  export type NatureCreateOrConnectWithoutStat_decreasedInput = {
    where: NatureWhereUniqueInput
    create: XOR<NatureCreateWithoutStat_decreasedInput, NatureUncheckedCreateWithoutStat_decreasedInput>
  }

  export type NatureCreateManyStat_decreasedInputEnvelope = {
    data: NatureCreateManyStat_decreasedInput | NatureCreateManyStat_decreasedInput[]
    skipDuplicates?: boolean
  }

  export type PokemonStatCreateWithoutStatInput = {
    id: number
    base_stat: number
    pokemon: PokemonCreateNestedOneWithoutStatsInput
  }

  export type PokemonStatUncheckedCreateWithoutStatInput = {
    id: number
    pokemon_id: number
    base_stat: number
  }

  export type PokemonStatCreateOrConnectWithoutStatInput = {
    where: PokemonStatWhereUniqueInput
    create: XOR<PokemonStatCreateWithoutStatInput, PokemonStatUncheckedCreateWithoutStatInput>
  }

  export type PokemonStatCreateManyStatInputEnvelope = {
    data: PokemonStatCreateManyStatInput | PokemonStatCreateManyStatInput[]
    skipDuplicates?: boolean
  }

  export type NatureUpsertWithWhereUniqueWithoutStat_increasedInput = {
    where: NatureWhereUniqueInput
    update: XOR<NatureUpdateWithoutStat_increasedInput, NatureUncheckedUpdateWithoutStat_increasedInput>
    create: XOR<NatureCreateWithoutStat_increasedInput, NatureUncheckedCreateWithoutStat_increasedInput>
  }

  export type NatureUpdateWithWhereUniqueWithoutStat_increasedInput = {
    where: NatureWhereUniqueInput
    data: XOR<NatureUpdateWithoutStat_increasedInput, NatureUncheckedUpdateWithoutStat_increasedInput>
  }

  export type NatureUpdateManyWithWhereWithoutStat_increasedInput = {
    where: NatureScalarWhereInput
    data: XOR<NatureUpdateManyMutationInput, NatureUncheckedUpdateManyWithoutStat_increasedInput>
  }

  export type NatureScalarWhereInput = {
    AND?: NatureScalarWhereInput | NatureScalarWhereInput[]
    OR?: NatureScalarWhereInput[]
    NOT?: NatureScalarWhereInput | NatureScalarWhereInput[]
    id?: IntFilter<"Nature"> | number
    name?: StringFilter<"Nature"> | string
    increased_stat_id?: IntFilter<"Nature"> | number
    decreased_stat_id?: IntFilter<"Nature"> | number
  }

  export type NatureUpsertWithWhereUniqueWithoutStat_decreasedInput = {
    where: NatureWhereUniqueInput
    update: XOR<NatureUpdateWithoutStat_decreasedInput, NatureUncheckedUpdateWithoutStat_decreasedInput>
    create: XOR<NatureCreateWithoutStat_decreasedInput, NatureUncheckedCreateWithoutStat_decreasedInput>
  }

  export type NatureUpdateWithWhereUniqueWithoutStat_decreasedInput = {
    where: NatureWhereUniqueInput
    data: XOR<NatureUpdateWithoutStat_decreasedInput, NatureUncheckedUpdateWithoutStat_decreasedInput>
  }

  export type NatureUpdateManyWithWhereWithoutStat_decreasedInput = {
    where: NatureScalarWhereInput
    data: XOR<NatureUpdateManyMutationInput, NatureUncheckedUpdateManyWithoutStat_decreasedInput>
  }

  export type PokemonStatUpsertWithWhereUniqueWithoutStatInput = {
    where: PokemonStatWhereUniqueInput
    update: XOR<PokemonStatUpdateWithoutStatInput, PokemonStatUncheckedUpdateWithoutStatInput>
    create: XOR<PokemonStatCreateWithoutStatInput, PokemonStatUncheckedCreateWithoutStatInput>
  }

  export type PokemonStatUpdateWithWhereUniqueWithoutStatInput = {
    where: PokemonStatWhereUniqueInput
    data: XOR<PokemonStatUpdateWithoutStatInput, PokemonStatUncheckedUpdateWithoutStatInput>
  }

  export type PokemonStatUpdateManyWithWhereWithoutStatInput = {
    where: PokemonStatScalarWhereInput
    data: XOR<PokemonStatUpdateManyMutationInput, PokemonStatUncheckedUpdateManyWithoutStatInput>
  }

  export type PokemonCreateWithoutStatsInput = {
    id: number
    name: string
    abilities?: PokemonAbilityCreateNestedManyWithoutPokemonInput
    natures?: PokemonNatureCreateNestedManyWithoutPokemonInput
    types?: PokemonTypeCreateNestedManyWithoutPokemonInput
    egg_groups?: PokemonEggGroupCreateNestedManyWithoutPokemonInput
    encounters?: EncounterCreateNestedManyWithoutPokemonInput
    dex_numbers?: PokemonDexNumberCreateNestedManyWithoutPokemonInput
    move?: PokemonMoveCreateNestedManyWithoutPokemonInput
  }

  export type PokemonUncheckedCreateWithoutStatsInput = {
    id: number
    name: string
    abilities?: PokemonAbilityUncheckedCreateNestedManyWithoutPokemonInput
    natures?: PokemonNatureUncheckedCreateNestedManyWithoutPokemonInput
    types?: PokemonTypeUncheckedCreateNestedManyWithoutPokemonInput
    egg_groups?: PokemonEggGroupUncheckedCreateNestedManyWithoutPokemonInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutPokemonInput
    dex_numbers?: PokemonDexNumberUncheckedCreateNestedManyWithoutPokemonInput
    move?: PokemonMoveUncheckedCreateNestedManyWithoutPokemonInput
  }

  export type PokemonCreateOrConnectWithoutStatsInput = {
    where: PokemonWhereUniqueInput
    create: XOR<PokemonCreateWithoutStatsInput, PokemonUncheckedCreateWithoutStatsInput>
  }

  export type StatCreateWithoutPokemon_statsInput = {
    id: number
    name: string
    natures_increase?: NatureCreateNestedManyWithoutStat_increasedInput
    natures_decrease?: NatureCreateNestedManyWithoutStat_decreasedInput
  }

  export type StatUncheckedCreateWithoutPokemon_statsInput = {
    id: number
    name: string
    natures_increase?: NatureUncheckedCreateNestedManyWithoutStat_increasedInput
    natures_decrease?: NatureUncheckedCreateNestedManyWithoutStat_decreasedInput
  }

  export type StatCreateOrConnectWithoutPokemon_statsInput = {
    where: StatWhereUniqueInput
    create: XOR<StatCreateWithoutPokemon_statsInput, StatUncheckedCreateWithoutPokemon_statsInput>
  }

  export type PokemonUpsertWithoutStatsInput = {
    update: XOR<PokemonUpdateWithoutStatsInput, PokemonUncheckedUpdateWithoutStatsInput>
    create: XOR<PokemonCreateWithoutStatsInput, PokemonUncheckedCreateWithoutStatsInput>
    where?: PokemonWhereInput
  }

  export type PokemonUpdateToOneWithWhereWithoutStatsInput = {
    where?: PokemonWhereInput
    data: XOR<PokemonUpdateWithoutStatsInput, PokemonUncheckedUpdateWithoutStatsInput>
  }

  export type PokemonUpdateWithoutStatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abilities?: PokemonAbilityUpdateManyWithoutPokemonNestedInput
    natures?: PokemonNatureUpdateManyWithoutPokemonNestedInput
    types?: PokemonTypeUpdateManyWithoutPokemonNestedInput
    egg_groups?: PokemonEggGroupUpdateManyWithoutPokemonNestedInput
    encounters?: EncounterUpdateManyWithoutPokemonNestedInput
    dex_numbers?: PokemonDexNumberUpdateManyWithoutPokemonNestedInput
    move?: PokemonMoveUpdateManyWithoutPokemonNestedInput
  }

  export type PokemonUncheckedUpdateWithoutStatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abilities?: PokemonAbilityUncheckedUpdateManyWithoutPokemonNestedInput
    natures?: PokemonNatureUncheckedUpdateManyWithoutPokemonNestedInput
    types?: PokemonTypeUncheckedUpdateManyWithoutPokemonNestedInput
    egg_groups?: PokemonEggGroupUncheckedUpdateManyWithoutPokemonNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutPokemonNestedInput
    dex_numbers?: PokemonDexNumberUncheckedUpdateManyWithoutPokemonNestedInput
    move?: PokemonMoveUncheckedUpdateManyWithoutPokemonNestedInput
  }

  export type StatUpsertWithoutPokemon_statsInput = {
    update: XOR<StatUpdateWithoutPokemon_statsInput, StatUncheckedUpdateWithoutPokemon_statsInput>
    create: XOR<StatCreateWithoutPokemon_statsInput, StatUncheckedCreateWithoutPokemon_statsInput>
    where?: StatWhereInput
  }

  export type StatUpdateToOneWithWhereWithoutPokemon_statsInput = {
    where?: StatWhereInput
    data: XOR<StatUpdateWithoutPokemon_statsInput, StatUncheckedUpdateWithoutPokemon_statsInput>
  }

  export type StatUpdateWithoutPokemon_statsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    natures_increase?: NatureUpdateManyWithoutStat_increasedNestedInput
    natures_decrease?: NatureUpdateManyWithoutStat_decreasedNestedInput
  }

  export type StatUncheckedUpdateWithoutPokemon_statsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    natures_increase?: NatureUncheckedUpdateManyWithoutStat_increasedNestedInput
    natures_decrease?: NatureUncheckedUpdateManyWithoutStat_decreasedNestedInput
  }

  export type GenerationCreateWithoutTypesInput = {
    id: number
    name: string
    region: RegionCreateNestedOneWithoutGenerationsInput
    versionGroups?: VersionGroupCreateNestedManyWithoutGenerationInput
  }

  export type GenerationUncheckedCreateWithoutTypesInput = {
    id: number
    name: string
    region_id: number
    versionGroups?: VersionGroupUncheckedCreateNestedManyWithoutGenerationInput
  }

  export type GenerationCreateOrConnectWithoutTypesInput = {
    where: GenerationWhereUniqueInput
    create: XOR<GenerationCreateWithoutTypesInput, GenerationUncheckedCreateWithoutTypesInput>
  }

  export type PokemonTypeCreateWithoutTypeInput = {
    id: number
    pokemon: PokemonCreateNestedOneWithoutTypesInput
  }

  export type PokemonTypeUncheckedCreateWithoutTypeInput = {
    id: number
    pokemon_id: number
  }

  export type PokemonTypeCreateOrConnectWithoutTypeInput = {
    where: PokemonTypeWhereUniqueInput
    create: XOR<PokemonTypeCreateWithoutTypeInput, PokemonTypeUncheckedCreateWithoutTypeInput>
  }

  export type PokemonTypeCreateManyTypeInputEnvelope = {
    data: PokemonTypeCreateManyTypeInput | PokemonTypeCreateManyTypeInput[]
    skipDuplicates?: boolean
  }

  export type TypeEffectivenessCreateWithoutAttackerInput = {
    id: number
    damage_factor: number
    defender: TypeCreateNestedOneWithoutDefendingInput
  }

  export type TypeEffectivenessUncheckedCreateWithoutAttackerInput = {
    id: number
    target_type_id: number
    damage_factor: number
  }

  export type TypeEffectivenessCreateOrConnectWithoutAttackerInput = {
    where: TypeEffectivenessWhereUniqueInput
    create: XOR<TypeEffectivenessCreateWithoutAttackerInput, TypeEffectivenessUncheckedCreateWithoutAttackerInput>
  }

  export type TypeEffectivenessCreateManyAttackerInputEnvelope = {
    data: TypeEffectivenessCreateManyAttackerInput | TypeEffectivenessCreateManyAttackerInput[]
    skipDuplicates?: boolean
  }

  export type TypeEffectivenessCreateWithoutDefenderInput = {
    id: number
    damage_factor: number
    attacker: TypeCreateNestedOneWithoutAttackingInput
  }

  export type TypeEffectivenessUncheckedCreateWithoutDefenderInput = {
    id: number
    type_id: number
    damage_factor: number
  }

  export type TypeEffectivenessCreateOrConnectWithoutDefenderInput = {
    where: TypeEffectivenessWhereUniqueInput
    create: XOR<TypeEffectivenessCreateWithoutDefenderInput, TypeEffectivenessUncheckedCreateWithoutDefenderInput>
  }

  export type TypeEffectivenessCreateManyDefenderInputEnvelope = {
    data: TypeEffectivenessCreateManyDefenderInput | TypeEffectivenessCreateManyDefenderInput[]
    skipDuplicates?: boolean
  }

  export type MoveCreateWithoutTypeInput = {
    id: number
    name: string
    generation_id: number
    pp: number
    accuracy?: number | null
    priority: number
    damage_class: MoveDamageClassCreateNestedOneWithoutMovesInput
    effect: MoveEffectCreateNestedOneWithoutMovesInput
    pokemon_moves?: PokemonMoveCreateNestedManyWithoutMoveInput
  }

  export type MoveUncheckedCreateWithoutTypeInput = {
    id: number
    name: string
    generation_id: number
    pp: number
    accuracy?: number | null
    priority: number
    move_damage_class_id: number
    move_effect_id: number
    pokemon_moves?: PokemonMoveUncheckedCreateNestedManyWithoutMoveInput
  }

  export type MoveCreateOrConnectWithoutTypeInput = {
    where: MoveWhereUniqueInput
    create: XOR<MoveCreateWithoutTypeInput, MoveUncheckedCreateWithoutTypeInput>
  }

  export type MoveCreateManyTypeInputEnvelope = {
    data: MoveCreateManyTypeInput | MoveCreateManyTypeInput[]
    skipDuplicates?: boolean
  }

  export type GenerationUpsertWithoutTypesInput = {
    update: XOR<GenerationUpdateWithoutTypesInput, GenerationUncheckedUpdateWithoutTypesInput>
    create: XOR<GenerationCreateWithoutTypesInput, GenerationUncheckedCreateWithoutTypesInput>
    where?: GenerationWhereInput
  }

  export type GenerationUpdateToOneWithWhereWithoutTypesInput = {
    where?: GenerationWhereInput
    data: XOR<GenerationUpdateWithoutTypesInput, GenerationUncheckedUpdateWithoutTypesInput>
  }

  export type GenerationUpdateWithoutTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutGenerationsNestedInput
    versionGroups?: VersionGroupUpdateManyWithoutGenerationNestedInput
  }

  export type GenerationUncheckedUpdateWithoutTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
    versionGroups?: VersionGroupUncheckedUpdateManyWithoutGenerationNestedInput
  }

  export type PokemonTypeUpsertWithWhereUniqueWithoutTypeInput = {
    where: PokemonTypeWhereUniqueInput
    update: XOR<PokemonTypeUpdateWithoutTypeInput, PokemonTypeUncheckedUpdateWithoutTypeInput>
    create: XOR<PokemonTypeCreateWithoutTypeInput, PokemonTypeUncheckedCreateWithoutTypeInput>
  }

  export type PokemonTypeUpdateWithWhereUniqueWithoutTypeInput = {
    where: PokemonTypeWhereUniqueInput
    data: XOR<PokemonTypeUpdateWithoutTypeInput, PokemonTypeUncheckedUpdateWithoutTypeInput>
  }

  export type PokemonTypeUpdateManyWithWhereWithoutTypeInput = {
    where: PokemonTypeScalarWhereInput
    data: XOR<PokemonTypeUpdateManyMutationInput, PokemonTypeUncheckedUpdateManyWithoutTypeInput>
  }

  export type TypeEffectivenessUpsertWithWhereUniqueWithoutAttackerInput = {
    where: TypeEffectivenessWhereUniqueInput
    update: XOR<TypeEffectivenessUpdateWithoutAttackerInput, TypeEffectivenessUncheckedUpdateWithoutAttackerInput>
    create: XOR<TypeEffectivenessCreateWithoutAttackerInput, TypeEffectivenessUncheckedCreateWithoutAttackerInput>
  }

  export type TypeEffectivenessUpdateWithWhereUniqueWithoutAttackerInput = {
    where: TypeEffectivenessWhereUniqueInput
    data: XOR<TypeEffectivenessUpdateWithoutAttackerInput, TypeEffectivenessUncheckedUpdateWithoutAttackerInput>
  }

  export type TypeEffectivenessUpdateManyWithWhereWithoutAttackerInput = {
    where: TypeEffectivenessScalarWhereInput
    data: XOR<TypeEffectivenessUpdateManyMutationInput, TypeEffectivenessUncheckedUpdateManyWithoutAttackerInput>
  }

  export type TypeEffectivenessScalarWhereInput = {
    AND?: TypeEffectivenessScalarWhereInput | TypeEffectivenessScalarWhereInput[]
    OR?: TypeEffectivenessScalarWhereInput[]
    NOT?: TypeEffectivenessScalarWhereInput | TypeEffectivenessScalarWhereInput[]
    id?: IntFilter<"TypeEffectiveness"> | number
    type_id?: IntFilter<"TypeEffectiveness"> | number
    target_type_id?: IntFilter<"TypeEffectiveness"> | number
    damage_factor?: IntFilter<"TypeEffectiveness"> | number
  }

  export type TypeEffectivenessUpsertWithWhereUniqueWithoutDefenderInput = {
    where: TypeEffectivenessWhereUniqueInput
    update: XOR<TypeEffectivenessUpdateWithoutDefenderInput, TypeEffectivenessUncheckedUpdateWithoutDefenderInput>
    create: XOR<TypeEffectivenessCreateWithoutDefenderInput, TypeEffectivenessUncheckedCreateWithoutDefenderInput>
  }

  export type TypeEffectivenessUpdateWithWhereUniqueWithoutDefenderInput = {
    where: TypeEffectivenessWhereUniqueInput
    data: XOR<TypeEffectivenessUpdateWithoutDefenderInput, TypeEffectivenessUncheckedUpdateWithoutDefenderInput>
  }

  export type TypeEffectivenessUpdateManyWithWhereWithoutDefenderInput = {
    where: TypeEffectivenessScalarWhereInput
    data: XOR<TypeEffectivenessUpdateManyMutationInput, TypeEffectivenessUncheckedUpdateManyWithoutDefenderInput>
  }

  export type MoveUpsertWithWhereUniqueWithoutTypeInput = {
    where: MoveWhereUniqueInput
    update: XOR<MoveUpdateWithoutTypeInput, MoveUncheckedUpdateWithoutTypeInput>
    create: XOR<MoveCreateWithoutTypeInput, MoveUncheckedCreateWithoutTypeInput>
  }

  export type MoveUpdateWithWhereUniqueWithoutTypeInput = {
    where: MoveWhereUniqueInput
    data: XOR<MoveUpdateWithoutTypeInput, MoveUncheckedUpdateWithoutTypeInput>
  }

  export type MoveUpdateManyWithWhereWithoutTypeInput = {
    where: MoveScalarWhereInput
    data: XOR<MoveUpdateManyMutationInput, MoveUncheckedUpdateManyWithoutTypeInput>
  }

  export type MoveScalarWhereInput = {
    AND?: MoveScalarWhereInput | MoveScalarWhereInput[]
    OR?: MoveScalarWhereInput[]
    NOT?: MoveScalarWhereInput | MoveScalarWhereInput[]
    id?: IntFilter<"Move"> | number
    name?: StringFilter<"Move"> | string
    generation_id?: IntFilter<"Move"> | number
    type_id?: IntFilter<"Move"> | number
    pp?: IntFilter<"Move"> | number
    accuracy?: IntNullableFilter<"Move"> | number | null
    priority?: IntFilter<"Move"> | number
    move_damage_class_id?: IntFilter<"Move"> | number
    move_effect_id?: IntFilter<"Move"> | number
  }

  export type TypeCreateWithoutAttackingInput = {
    id: number
    name: string
    generation: GenerationCreateNestedOneWithoutTypesInput
    pokemon?: PokemonTypeCreateNestedManyWithoutTypeInput
    defending?: TypeEffectivenessCreateNestedManyWithoutDefenderInput
    move?: MoveCreateNestedManyWithoutTypeInput
  }

  export type TypeUncheckedCreateWithoutAttackingInput = {
    id: number
    name: string
    generation_id: number
    pokemon?: PokemonTypeUncheckedCreateNestedManyWithoutTypeInput
    defending?: TypeEffectivenessUncheckedCreateNestedManyWithoutDefenderInput
    move?: MoveUncheckedCreateNestedManyWithoutTypeInput
  }

  export type TypeCreateOrConnectWithoutAttackingInput = {
    where: TypeWhereUniqueInput
    create: XOR<TypeCreateWithoutAttackingInput, TypeUncheckedCreateWithoutAttackingInput>
  }

  export type TypeCreateWithoutDefendingInput = {
    id: number
    name: string
    generation: GenerationCreateNestedOneWithoutTypesInput
    pokemon?: PokemonTypeCreateNestedManyWithoutTypeInput
    attacking?: TypeEffectivenessCreateNestedManyWithoutAttackerInput
    move?: MoveCreateNestedManyWithoutTypeInput
  }

  export type TypeUncheckedCreateWithoutDefendingInput = {
    id: number
    name: string
    generation_id: number
    pokemon?: PokemonTypeUncheckedCreateNestedManyWithoutTypeInput
    attacking?: TypeEffectivenessUncheckedCreateNestedManyWithoutAttackerInput
    move?: MoveUncheckedCreateNestedManyWithoutTypeInput
  }

  export type TypeCreateOrConnectWithoutDefendingInput = {
    where: TypeWhereUniqueInput
    create: XOR<TypeCreateWithoutDefendingInput, TypeUncheckedCreateWithoutDefendingInput>
  }

  export type TypeUpsertWithoutAttackingInput = {
    update: XOR<TypeUpdateWithoutAttackingInput, TypeUncheckedUpdateWithoutAttackingInput>
    create: XOR<TypeCreateWithoutAttackingInput, TypeUncheckedCreateWithoutAttackingInput>
    where?: TypeWhereInput
  }

  export type TypeUpdateToOneWithWhereWithoutAttackingInput = {
    where?: TypeWhereInput
    data: XOR<TypeUpdateWithoutAttackingInput, TypeUncheckedUpdateWithoutAttackingInput>
  }

  export type TypeUpdateWithoutAttackingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation?: GenerationUpdateOneRequiredWithoutTypesNestedInput
    pokemon?: PokemonTypeUpdateManyWithoutTypeNestedInput
    defending?: TypeEffectivenessUpdateManyWithoutDefenderNestedInput
    move?: MoveUpdateManyWithoutTypeNestedInput
  }

  export type TypeUncheckedUpdateWithoutAttackingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    pokemon?: PokemonTypeUncheckedUpdateManyWithoutTypeNestedInput
    defending?: TypeEffectivenessUncheckedUpdateManyWithoutDefenderNestedInput
    move?: MoveUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type TypeUpsertWithoutDefendingInput = {
    update: XOR<TypeUpdateWithoutDefendingInput, TypeUncheckedUpdateWithoutDefendingInput>
    create: XOR<TypeCreateWithoutDefendingInput, TypeUncheckedCreateWithoutDefendingInput>
    where?: TypeWhereInput
  }

  export type TypeUpdateToOneWithWhereWithoutDefendingInput = {
    where?: TypeWhereInput
    data: XOR<TypeUpdateWithoutDefendingInput, TypeUncheckedUpdateWithoutDefendingInput>
  }

  export type TypeUpdateWithoutDefendingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation?: GenerationUpdateOneRequiredWithoutTypesNestedInput
    pokemon?: PokemonTypeUpdateManyWithoutTypeNestedInput
    attacking?: TypeEffectivenessUpdateManyWithoutAttackerNestedInput
    move?: MoveUpdateManyWithoutTypeNestedInput
  }

  export type TypeUncheckedUpdateWithoutDefendingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    pokemon?: PokemonTypeUncheckedUpdateManyWithoutTypeNestedInput
    attacking?: TypeEffectivenessUncheckedUpdateManyWithoutAttackerNestedInput
    move?: MoveUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type PokemonCreateWithoutTypesInput = {
    id: number
    name: string
    abilities?: PokemonAbilityCreateNestedManyWithoutPokemonInput
    natures?: PokemonNatureCreateNestedManyWithoutPokemonInput
    stats?: PokemonStatCreateNestedManyWithoutPokemonInput
    egg_groups?: PokemonEggGroupCreateNestedManyWithoutPokemonInput
    encounters?: EncounterCreateNestedManyWithoutPokemonInput
    dex_numbers?: PokemonDexNumberCreateNestedManyWithoutPokemonInput
    move?: PokemonMoveCreateNestedManyWithoutPokemonInput
  }

  export type PokemonUncheckedCreateWithoutTypesInput = {
    id: number
    name: string
    abilities?: PokemonAbilityUncheckedCreateNestedManyWithoutPokemonInput
    natures?: PokemonNatureUncheckedCreateNestedManyWithoutPokemonInput
    stats?: PokemonStatUncheckedCreateNestedManyWithoutPokemonInput
    egg_groups?: PokemonEggGroupUncheckedCreateNestedManyWithoutPokemonInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutPokemonInput
    dex_numbers?: PokemonDexNumberUncheckedCreateNestedManyWithoutPokemonInput
    move?: PokemonMoveUncheckedCreateNestedManyWithoutPokemonInput
  }

  export type PokemonCreateOrConnectWithoutTypesInput = {
    where: PokemonWhereUniqueInput
    create: XOR<PokemonCreateWithoutTypesInput, PokemonUncheckedCreateWithoutTypesInput>
  }

  export type TypeCreateWithoutPokemonInput = {
    id: number
    name: string
    generation: GenerationCreateNestedOneWithoutTypesInput
    attacking?: TypeEffectivenessCreateNestedManyWithoutAttackerInput
    defending?: TypeEffectivenessCreateNestedManyWithoutDefenderInput
    move?: MoveCreateNestedManyWithoutTypeInput
  }

  export type TypeUncheckedCreateWithoutPokemonInput = {
    id: number
    name: string
    generation_id: number
    attacking?: TypeEffectivenessUncheckedCreateNestedManyWithoutAttackerInput
    defending?: TypeEffectivenessUncheckedCreateNestedManyWithoutDefenderInput
    move?: MoveUncheckedCreateNestedManyWithoutTypeInput
  }

  export type TypeCreateOrConnectWithoutPokemonInput = {
    where: TypeWhereUniqueInput
    create: XOR<TypeCreateWithoutPokemonInput, TypeUncheckedCreateWithoutPokemonInput>
  }

  export type PokemonUpsertWithoutTypesInput = {
    update: XOR<PokemonUpdateWithoutTypesInput, PokemonUncheckedUpdateWithoutTypesInput>
    create: XOR<PokemonCreateWithoutTypesInput, PokemonUncheckedCreateWithoutTypesInput>
    where?: PokemonWhereInput
  }

  export type PokemonUpdateToOneWithWhereWithoutTypesInput = {
    where?: PokemonWhereInput
    data: XOR<PokemonUpdateWithoutTypesInput, PokemonUncheckedUpdateWithoutTypesInput>
  }

  export type PokemonUpdateWithoutTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abilities?: PokemonAbilityUpdateManyWithoutPokemonNestedInput
    natures?: PokemonNatureUpdateManyWithoutPokemonNestedInput
    stats?: PokemonStatUpdateManyWithoutPokemonNestedInput
    egg_groups?: PokemonEggGroupUpdateManyWithoutPokemonNestedInput
    encounters?: EncounterUpdateManyWithoutPokemonNestedInput
    dex_numbers?: PokemonDexNumberUpdateManyWithoutPokemonNestedInput
    move?: PokemonMoveUpdateManyWithoutPokemonNestedInput
  }

  export type PokemonUncheckedUpdateWithoutTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abilities?: PokemonAbilityUncheckedUpdateManyWithoutPokemonNestedInput
    natures?: PokemonNatureUncheckedUpdateManyWithoutPokemonNestedInput
    stats?: PokemonStatUncheckedUpdateManyWithoutPokemonNestedInput
    egg_groups?: PokemonEggGroupUncheckedUpdateManyWithoutPokemonNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutPokemonNestedInput
    dex_numbers?: PokemonDexNumberUncheckedUpdateManyWithoutPokemonNestedInput
    move?: PokemonMoveUncheckedUpdateManyWithoutPokemonNestedInput
  }

  export type TypeUpsertWithoutPokemonInput = {
    update: XOR<TypeUpdateWithoutPokemonInput, TypeUncheckedUpdateWithoutPokemonInput>
    create: XOR<TypeCreateWithoutPokemonInput, TypeUncheckedCreateWithoutPokemonInput>
    where?: TypeWhereInput
  }

  export type TypeUpdateToOneWithWhereWithoutPokemonInput = {
    where?: TypeWhereInput
    data: XOR<TypeUpdateWithoutPokemonInput, TypeUncheckedUpdateWithoutPokemonInput>
  }

  export type TypeUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation?: GenerationUpdateOneRequiredWithoutTypesNestedInput
    attacking?: TypeEffectivenessUpdateManyWithoutAttackerNestedInput
    defending?: TypeEffectivenessUpdateManyWithoutDefenderNestedInput
    move?: MoveUpdateManyWithoutTypeNestedInput
  }

  export type TypeUncheckedUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    attacking?: TypeEffectivenessUncheckedUpdateManyWithoutAttackerNestedInput
    defending?: TypeEffectivenessUncheckedUpdateManyWithoutDefenderNestedInput
    move?: MoveUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type PokemonEggGroupCreateWithoutEgg_groupInput = {
    id: number
    pokemon: PokemonCreateNestedOneWithoutEgg_groupsInput
  }

  export type PokemonEggGroupUncheckedCreateWithoutEgg_groupInput = {
    id: number
    pokemon_id: number
  }

  export type PokemonEggGroupCreateOrConnectWithoutEgg_groupInput = {
    where: PokemonEggGroupWhereUniqueInput
    create: XOR<PokemonEggGroupCreateWithoutEgg_groupInput, PokemonEggGroupUncheckedCreateWithoutEgg_groupInput>
  }

  export type PokemonEggGroupCreateManyEgg_groupInputEnvelope = {
    data: PokemonEggGroupCreateManyEgg_groupInput | PokemonEggGroupCreateManyEgg_groupInput[]
    skipDuplicates?: boolean
  }

  export type PokemonEggGroupUpsertWithWhereUniqueWithoutEgg_groupInput = {
    where: PokemonEggGroupWhereUniqueInput
    update: XOR<PokemonEggGroupUpdateWithoutEgg_groupInput, PokemonEggGroupUncheckedUpdateWithoutEgg_groupInput>
    create: XOR<PokemonEggGroupCreateWithoutEgg_groupInput, PokemonEggGroupUncheckedCreateWithoutEgg_groupInput>
  }

  export type PokemonEggGroupUpdateWithWhereUniqueWithoutEgg_groupInput = {
    where: PokemonEggGroupWhereUniqueInput
    data: XOR<PokemonEggGroupUpdateWithoutEgg_groupInput, PokemonEggGroupUncheckedUpdateWithoutEgg_groupInput>
  }

  export type PokemonEggGroupUpdateManyWithWhereWithoutEgg_groupInput = {
    where: PokemonEggGroupScalarWhereInput
    data: XOR<PokemonEggGroupUpdateManyMutationInput, PokemonEggGroupUncheckedUpdateManyWithoutEgg_groupInput>
  }

  export type PokemonCreateWithoutEgg_groupsInput = {
    id: number
    name: string
    abilities?: PokemonAbilityCreateNestedManyWithoutPokemonInput
    natures?: PokemonNatureCreateNestedManyWithoutPokemonInput
    stats?: PokemonStatCreateNestedManyWithoutPokemonInput
    types?: PokemonTypeCreateNestedManyWithoutPokemonInput
    encounters?: EncounterCreateNestedManyWithoutPokemonInput
    dex_numbers?: PokemonDexNumberCreateNestedManyWithoutPokemonInput
    move?: PokemonMoveCreateNestedManyWithoutPokemonInput
  }

  export type PokemonUncheckedCreateWithoutEgg_groupsInput = {
    id: number
    name: string
    abilities?: PokemonAbilityUncheckedCreateNestedManyWithoutPokemonInput
    natures?: PokemonNatureUncheckedCreateNestedManyWithoutPokemonInput
    stats?: PokemonStatUncheckedCreateNestedManyWithoutPokemonInput
    types?: PokemonTypeUncheckedCreateNestedManyWithoutPokemonInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutPokemonInput
    dex_numbers?: PokemonDexNumberUncheckedCreateNestedManyWithoutPokemonInput
    move?: PokemonMoveUncheckedCreateNestedManyWithoutPokemonInput
  }

  export type PokemonCreateOrConnectWithoutEgg_groupsInput = {
    where: PokemonWhereUniqueInput
    create: XOR<PokemonCreateWithoutEgg_groupsInput, PokemonUncheckedCreateWithoutEgg_groupsInput>
  }

  export type EggGroupCreateWithoutPokemon_egg_groupInput = {
    id: number
    name: string
  }

  export type EggGroupUncheckedCreateWithoutPokemon_egg_groupInput = {
    id: number
    name: string
  }

  export type EggGroupCreateOrConnectWithoutPokemon_egg_groupInput = {
    where: EggGroupWhereUniqueInput
    create: XOR<EggGroupCreateWithoutPokemon_egg_groupInput, EggGroupUncheckedCreateWithoutPokemon_egg_groupInput>
  }

  export type PokemonUpsertWithoutEgg_groupsInput = {
    update: XOR<PokemonUpdateWithoutEgg_groupsInput, PokemonUncheckedUpdateWithoutEgg_groupsInput>
    create: XOR<PokemonCreateWithoutEgg_groupsInput, PokemonUncheckedCreateWithoutEgg_groupsInput>
    where?: PokemonWhereInput
  }

  export type PokemonUpdateToOneWithWhereWithoutEgg_groupsInput = {
    where?: PokemonWhereInput
    data: XOR<PokemonUpdateWithoutEgg_groupsInput, PokemonUncheckedUpdateWithoutEgg_groupsInput>
  }

  export type PokemonUpdateWithoutEgg_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abilities?: PokemonAbilityUpdateManyWithoutPokemonNestedInput
    natures?: PokemonNatureUpdateManyWithoutPokemonNestedInput
    stats?: PokemonStatUpdateManyWithoutPokemonNestedInput
    types?: PokemonTypeUpdateManyWithoutPokemonNestedInput
    encounters?: EncounterUpdateManyWithoutPokemonNestedInput
    dex_numbers?: PokemonDexNumberUpdateManyWithoutPokemonNestedInput
    move?: PokemonMoveUpdateManyWithoutPokemonNestedInput
  }

  export type PokemonUncheckedUpdateWithoutEgg_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abilities?: PokemonAbilityUncheckedUpdateManyWithoutPokemonNestedInput
    natures?: PokemonNatureUncheckedUpdateManyWithoutPokemonNestedInput
    stats?: PokemonStatUncheckedUpdateManyWithoutPokemonNestedInput
    types?: PokemonTypeUncheckedUpdateManyWithoutPokemonNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutPokemonNestedInput
    dex_numbers?: PokemonDexNumberUncheckedUpdateManyWithoutPokemonNestedInput
    move?: PokemonMoveUncheckedUpdateManyWithoutPokemonNestedInput
  }

  export type EggGroupUpsertWithoutPokemon_egg_groupInput = {
    update: XOR<EggGroupUpdateWithoutPokemon_egg_groupInput, EggGroupUncheckedUpdateWithoutPokemon_egg_groupInput>
    create: XOR<EggGroupCreateWithoutPokemon_egg_groupInput, EggGroupUncheckedCreateWithoutPokemon_egg_groupInput>
    where?: EggGroupWhereInput
  }

  export type EggGroupUpdateToOneWithWhereWithoutPokemon_egg_groupInput = {
    where?: EggGroupWhereInput
    data: XOR<EggGroupUpdateWithoutPokemon_egg_groupInput, EggGroupUncheckedUpdateWithoutPokemon_egg_groupInput>
  }

  export type EggGroupUpdateWithoutPokemon_egg_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EggGroupUncheckedUpdateWithoutPokemon_egg_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LocationCreateWithoutRegionInput = {
    id: number
    name: string
    areas?: LocationAreaCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutRegionInput = {
    id: number
    name: string
    areas?: LocationAreaUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutRegionInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutRegionInput, LocationUncheckedCreateWithoutRegionInput>
  }

  export type LocationCreateManyRegionInputEnvelope = {
    data: LocationCreateManyRegionInput | LocationCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type VersionGroupRegionCreateWithoutRegionInput = {
    id: number
    version_group: VersionGroupCreateNestedOneWithoutRegionsInput
  }

  export type VersionGroupRegionUncheckedCreateWithoutRegionInput = {
    id: number
    version_group_id: number
  }

  export type VersionGroupRegionCreateOrConnectWithoutRegionInput = {
    where: VersionGroupRegionWhereUniqueInput
    create: XOR<VersionGroupRegionCreateWithoutRegionInput, VersionGroupRegionUncheckedCreateWithoutRegionInput>
  }

  export type VersionGroupRegionCreateManyRegionInputEnvelope = {
    data: VersionGroupRegionCreateManyRegionInput | VersionGroupRegionCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type GenerationCreateWithoutRegionInput = {
    id: number
    name: string
    types?: TypeCreateNestedManyWithoutGenerationInput
    versionGroups?: VersionGroupCreateNestedManyWithoutGenerationInput
  }

  export type GenerationUncheckedCreateWithoutRegionInput = {
    id: number
    name: string
    types?: TypeUncheckedCreateNestedManyWithoutGenerationInput
    versionGroups?: VersionGroupUncheckedCreateNestedManyWithoutGenerationInput
  }

  export type GenerationCreateOrConnectWithoutRegionInput = {
    where: GenerationWhereUniqueInput
    create: XOR<GenerationCreateWithoutRegionInput, GenerationUncheckedCreateWithoutRegionInput>
  }

  export type PokedexCreateWithoutRegionInput = {
    id: number
    name: string
    pokedex_version_groups?: PokedexVersionGroupCreateNestedManyWithoutPokedexInput
    pokemon_dex_numbers?: PokemonDexNumberCreateNestedManyWithoutPokedexInput
  }

  export type PokedexUncheckedCreateWithoutRegionInput = {
    id: number
    name: string
    pokedex_version_groups?: PokedexVersionGroupUncheckedCreateNestedManyWithoutPokedexInput
    pokemon_dex_numbers?: PokemonDexNumberUncheckedCreateNestedManyWithoutPokedexInput
  }

  export type PokedexCreateOrConnectWithoutRegionInput = {
    where: PokedexWhereUniqueInput
    create: XOR<PokedexCreateWithoutRegionInput, PokedexUncheckedCreateWithoutRegionInput>
  }

  export type PokedexCreateManyRegionInputEnvelope = {
    data: PokedexCreateManyRegionInput | PokedexCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithWhereUniqueWithoutRegionInput = {
    where: LocationWhereUniqueInput
    update: XOR<LocationUpdateWithoutRegionInput, LocationUncheckedUpdateWithoutRegionInput>
    create: XOR<LocationCreateWithoutRegionInput, LocationUncheckedCreateWithoutRegionInput>
  }

  export type LocationUpdateWithWhereUniqueWithoutRegionInput = {
    where: LocationWhereUniqueInput
    data: XOR<LocationUpdateWithoutRegionInput, LocationUncheckedUpdateWithoutRegionInput>
  }

  export type LocationUpdateManyWithWhereWithoutRegionInput = {
    where: LocationScalarWhereInput
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyWithoutRegionInput>
  }

  export type LocationScalarWhereInput = {
    AND?: LocationScalarWhereInput | LocationScalarWhereInput[]
    OR?: LocationScalarWhereInput[]
    NOT?: LocationScalarWhereInput | LocationScalarWhereInput[]
    id?: IntFilter<"Location"> | number
    name?: StringFilter<"Location"> | string
    region_id?: IntFilter<"Location"> | number
  }

  export type VersionGroupRegionUpsertWithWhereUniqueWithoutRegionInput = {
    where: VersionGroupRegionWhereUniqueInput
    update: XOR<VersionGroupRegionUpdateWithoutRegionInput, VersionGroupRegionUncheckedUpdateWithoutRegionInput>
    create: XOR<VersionGroupRegionCreateWithoutRegionInput, VersionGroupRegionUncheckedCreateWithoutRegionInput>
  }

  export type VersionGroupRegionUpdateWithWhereUniqueWithoutRegionInput = {
    where: VersionGroupRegionWhereUniqueInput
    data: XOR<VersionGroupRegionUpdateWithoutRegionInput, VersionGroupRegionUncheckedUpdateWithoutRegionInput>
  }

  export type VersionGroupRegionUpdateManyWithWhereWithoutRegionInput = {
    where: VersionGroupRegionScalarWhereInput
    data: XOR<VersionGroupRegionUpdateManyMutationInput, VersionGroupRegionUncheckedUpdateManyWithoutRegionInput>
  }

  export type VersionGroupRegionScalarWhereInput = {
    AND?: VersionGroupRegionScalarWhereInput | VersionGroupRegionScalarWhereInput[]
    OR?: VersionGroupRegionScalarWhereInput[]
    NOT?: VersionGroupRegionScalarWhereInput | VersionGroupRegionScalarWhereInput[]
    id?: IntFilter<"VersionGroupRegion"> | number
    version_group_id?: IntFilter<"VersionGroupRegion"> | number
    region_id?: IntFilter<"VersionGroupRegion"> | number
  }

  export type GenerationUpsertWithoutRegionInput = {
    update: XOR<GenerationUpdateWithoutRegionInput, GenerationUncheckedUpdateWithoutRegionInput>
    create: XOR<GenerationCreateWithoutRegionInput, GenerationUncheckedCreateWithoutRegionInput>
    where?: GenerationWhereInput
  }

  export type GenerationUpdateToOneWithWhereWithoutRegionInput = {
    where?: GenerationWhereInput
    data: XOR<GenerationUpdateWithoutRegionInput, GenerationUncheckedUpdateWithoutRegionInput>
  }

  export type GenerationUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    types?: TypeUpdateManyWithoutGenerationNestedInput
    versionGroups?: VersionGroupUpdateManyWithoutGenerationNestedInput
  }

  export type GenerationUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    types?: TypeUncheckedUpdateManyWithoutGenerationNestedInput
    versionGroups?: VersionGroupUncheckedUpdateManyWithoutGenerationNestedInput
  }

  export type PokedexUpsertWithWhereUniqueWithoutRegionInput = {
    where: PokedexWhereUniqueInput
    update: XOR<PokedexUpdateWithoutRegionInput, PokedexUncheckedUpdateWithoutRegionInput>
    create: XOR<PokedexCreateWithoutRegionInput, PokedexUncheckedCreateWithoutRegionInput>
  }

  export type PokedexUpdateWithWhereUniqueWithoutRegionInput = {
    where: PokedexWhereUniqueInput
    data: XOR<PokedexUpdateWithoutRegionInput, PokedexUncheckedUpdateWithoutRegionInput>
  }

  export type PokedexUpdateManyWithWhereWithoutRegionInput = {
    where: PokedexScalarWhereInput
    data: XOR<PokedexUpdateManyMutationInput, PokedexUncheckedUpdateManyWithoutRegionInput>
  }

  export type PokedexScalarWhereInput = {
    AND?: PokedexScalarWhereInput | PokedexScalarWhereInput[]
    OR?: PokedexScalarWhereInput[]
    NOT?: PokedexScalarWhereInput | PokedexScalarWhereInput[]
    id?: IntFilter<"Pokedex"> | number
    name?: StringFilter<"Pokedex"> | string
    region_id?: IntFilter<"Pokedex"> | number
  }

  export type RegionCreateWithoutGenerationsInput = {
    id: number
    name: string
    locations?: LocationCreateNestedManyWithoutRegionInput
    version_groups?: VersionGroupRegionCreateNestedManyWithoutRegionInput
    pokedex?: PokedexCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutGenerationsInput = {
    id: number
    name: string
    locations?: LocationUncheckedCreateNestedManyWithoutRegionInput
    version_groups?: VersionGroupRegionUncheckedCreateNestedManyWithoutRegionInput
    pokedex?: PokedexUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutGenerationsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutGenerationsInput, RegionUncheckedCreateWithoutGenerationsInput>
  }

  export type TypeCreateWithoutGenerationInput = {
    id: number
    name: string
    pokemon?: PokemonTypeCreateNestedManyWithoutTypeInput
    attacking?: TypeEffectivenessCreateNestedManyWithoutAttackerInput
    defending?: TypeEffectivenessCreateNestedManyWithoutDefenderInput
    move?: MoveCreateNestedManyWithoutTypeInput
  }

  export type TypeUncheckedCreateWithoutGenerationInput = {
    id: number
    name: string
    pokemon?: PokemonTypeUncheckedCreateNestedManyWithoutTypeInput
    attacking?: TypeEffectivenessUncheckedCreateNestedManyWithoutAttackerInput
    defending?: TypeEffectivenessUncheckedCreateNestedManyWithoutDefenderInput
    move?: MoveUncheckedCreateNestedManyWithoutTypeInput
  }

  export type TypeCreateOrConnectWithoutGenerationInput = {
    where: TypeWhereUniqueInput
    create: XOR<TypeCreateWithoutGenerationInput, TypeUncheckedCreateWithoutGenerationInput>
  }

  export type TypeCreateManyGenerationInputEnvelope = {
    data: TypeCreateManyGenerationInput | TypeCreateManyGenerationInput[]
    skipDuplicates?: boolean
  }

  export type VersionGroupCreateWithoutGenerationInput = {
    id: number
    name: string
    versions?: VersionCreateNestedManyWithoutVersionGroupInput
    regions?: VersionGroupRegionCreateNestedManyWithoutVersion_groupInput
    slots?: EncounterSlotCreateNestedManyWithoutVersion_groupInput
    moves?: PokemonMoveCreateNestedManyWithoutVersion_groupInput
    pokedex_version_groups?: PokedexVersionGroupCreateNestedManyWithoutVersion_groupInput
  }

  export type VersionGroupUncheckedCreateWithoutGenerationInput = {
    id: number
    name: string
    versions?: VersionUncheckedCreateNestedManyWithoutVersionGroupInput
    regions?: VersionGroupRegionUncheckedCreateNestedManyWithoutVersion_groupInput
    slots?: EncounterSlotUncheckedCreateNestedManyWithoutVersion_groupInput
    moves?: PokemonMoveUncheckedCreateNestedManyWithoutVersion_groupInput
    pokedex_version_groups?: PokedexVersionGroupUncheckedCreateNestedManyWithoutVersion_groupInput
  }

  export type VersionGroupCreateOrConnectWithoutGenerationInput = {
    where: VersionGroupWhereUniqueInput
    create: XOR<VersionGroupCreateWithoutGenerationInput, VersionGroupUncheckedCreateWithoutGenerationInput>
  }

  export type VersionGroupCreateManyGenerationInputEnvelope = {
    data: VersionGroupCreateManyGenerationInput | VersionGroupCreateManyGenerationInput[]
    skipDuplicates?: boolean
  }

  export type RegionUpsertWithoutGenerationsInput = {
    update: XOR<RegionUpdateWithoutGenerationsInput, RegionUncheckedUpdateWithoutGenerationsInput>
    create: XOR<RegionCreateWithoutGenerationsInput, RegionUncheckedCreateWithoutGenerationsInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutGenerationsInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutGenerationsInput, RegionUncheckedUpdateWithoutGenerationsInput>
  }

  export type RegionUpdateWithoutGenerationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: LocationUpdateManyWithoutRegionNestedInput
    version_groups?: VersionGroupRegionUpdateManyWithoutRegionNestedInput
    pokedex?: PokedexUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutGenerationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: LocationUncheckedUpdateManyWithoutRegionNestedInput
    version_groups?: VersionGroupRegionUncheckedUpdateManyWithoutRegionNestedInput
    pokedex?: PokedexUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type TypeUpsertWithWhereUniqueWithoutGenerationInput = {
    where: TypeWhereUniqueInput
    update: XOR<TypeUpdateWithoutGenerationInput, TypeUncheckedUpdateWithoutGenerationInput>
    create: XOR<TypeCreateWithoutGenerationInput, TypeUncheckedCreateWithoutGenerationInput>
  }

  export type TypeUpdateWithWhereUniqueWithoutGenerationInput = {
    where: TypeWhereUniqueInput
    data: XOR<TypeUpdateWithoutGenerationInput, TypeUncheckedUpdateWithoutGenerationInput>
  }

  export type TypeUpdateManyWithWhereWithoutGenerationInput = {
    where: TypeScalarWhereInput
    data: XOR<TypeUpdateManyMutationInput, TypeUncheckedUpdateManyWithoutGenerationInput>
  }

  export type TypeScalarWhereInput = {
    AND?: TypeScalarWhereInput | TypeScalarWhereInput[]
    OR?: TypeScalarWhereInput[]
    NOT?: TypeScalarWhereInput | TypeScalarWhereInput[]
    id?: IntFilter<"Type"> | number
    name?: StringFilter<"Type"> | string
    generation_id?: IntFilter<"Type"> | number
  }

  export type VersionGroupUpsertWithWhereUniqueWithoutGenerationInput = {
    where: VersionGroupWhereUniqueInput
    update: XOR<VersionGroupUpdateWithoutGenerationInput, VersionGroupUncheckedUpdateWithoutGenerationInput>
    create: XOR<VersionGroupCreateWithoutGenerationInput, VersionGroupUncheckedCreateWithoutGenerationInput>
  }

  export type VersionGroupUpdateWithWhereUniqueWithoutGenerationInput = {
    where: VersionGroupWhereUniqueInput
    data: XOR<VersionGroupUpdateWithoutGenerationInput, VersionGroupUncheckedUpdateWithoutGenerationInput>
  }

  export type VersionGroupUpdateManyWithWhereWithoutGenerationInput = {
    where: VersionGroupScalarWhereInput
    data: XOR<VersionGroupUpdateManyMutationInput, VersionGroupUncheckedUpdateManyWithoutGenerationInput>
  }

  export type VersionGroupScalarWhereInput = {
    AND?: VersionGroupScalarWhereInput | VersionGroupScalarWhereInput[]
    OR?: VersionGroupScalarWhereInput[]
    NOT?: VersionGroupScalarWhereInput | VersionGroupScalarWhereInput[]
    id?: IntFilter<"VersionGroup"> | number
    name?: StringFilter<"VersionGroup"> | string
    generation_id?: IntFilter<"VersionGroup"> | number
  }

  export type GenerationCreateWithoutVersionGroupsInput = {
    id: number
    name: string
    region: RegionCreateNestedOneWithoutGenerationsInput
    types?: TypeCreateNestedManyWithoutGenerationInput
  }

  export type GenerationUncheckedCreateWithoutVersionGroupsInput = {
    id: number
    name: string
    region_id: number
    types?: TypeUncheckedCreateNestedManyWithoutGenerationInput
  }

  export type GenerationCreateOrConnectWithoutVersionGroupsInput = {
    where: GenerationWhereUniqueInput
    create: XOR<GenerationCreateWithoutVersionGroupsInput, GenerationUncheckedCreateWithoutVersionGroupsInput>
  }

  export type VersionCreateWithoutVersionGroupInput = {
    id: number
    name: string
    encounters?: EncounterCreateNestedManyWithoutVersionInput
    encounterRates?: LocationAreaEncounterRateCreateNestedManyWithoutVersionInput
  }

  export type VersionUncheckedCreateWithoutVersionGroupInput = {
    id: number
    name: string
    encounters?: EncounterUncheckedCreateNestedManyWithoutVersionInput
    encounterRates?: LocationAreaEncounterRateUncheckedCreateNestedManyWithoutVersionInput
  }

  export type VersionCreateOrConnectWithoutVersionGroupInput = {
    where: VersionWhereUniqueInput
    create: XOR<VersionCreateWithoutVersionGroupInput, VersionUncheckedCreateWithoutVersionGroupInput>
  }

  export type VersionCreateManyVersionGroupInputEnvelope = {
    data: VersionCreateManyVersionGroupInput | VersionCreateManyVersionGroupInput[]
    skipDuplicates?: boolean
  }

  export type VersionGroupRegionCreateWithoutVersion_groupInput = {
    id: number
    region: RegionCreateNestedOneWithoutVersion_groupsInput
  }

  export type VersionGroupRegionUncheckedCreateWithoutVersion_groupInput = {
    id: number
    region_id: number
  }

  export type VersionGroupRegionCreateOrConnectWithoutVersion_groupInput = {
    where: VersionGroupRegionWhereUniqueInput
    create: XOR<VersionGroupRegionCreateWithoutVersion_groupInput, VersionGroupRegionUncheckedCreateWithoutVersion_groupInput>
  }

  export type VersionGroupRegionCreateManyVersion_groupInputEnvelope = {
    data: VersionGroupRegionCreateManyVersion_groupInput | VersionGroupRegionCreateManyVersion_groupInput[]
    skipDuplicates?: boolean
  }

  export type EncounterSlotCreateWithoutVersion_groupInput = {
    id: number
    slot: number
    rarity: number
    method: EncounterMethodCreateNestedOneWithoutSlotsInput
    encounters?: EncounterCreateNestedManyWithoutSlotInput
  }

  export type EncounterSlotUncheckedCreateWithoutVersion_groupInput = {
    id: number
    encounter_method_id: number
    slot: number
    rarity: number
    encounters?: EncounterUncheckedCreateNestedManyWithoutSlotInput
  }

  export type EncounterSlotCreateOrConnectWithoutVersion_groupInput = {
    where: EncounterSlotWhereUniqueInput
    create: XOR<EncounterSlotCreateWithoutVersion_groupInput, EncounterSlotUncheckedCreateWithoutVersion_groupInput>
  }

  export type EncounterSlotCreateManyVersion_groupInputEnvelope = {
    data: EncounterSlotCreateManyVersion_groupInput | EncounterSlotCreateManyVersion_groupInput[]
    skipDuplicates?: boolean
  }

  export type PokemonMoveCreateWithoutVersion_groupInput = {
    id: number
    level: number
    method: MoveMethodCreateNestedOneWithoutMovesInput
    move: MoveCreateNestedOneWithoutPokemon_movesInput
    pokemon: PokemonCreateNestedOneWithoutMoveInput
  }

  export type PokemonMoveUncheckedCreateWithoutVersion_groupInput = {
    id: number
    move_method_id: number
    move_id: number
    pokemon_id: number
    level: number
  }

  export type PokemonMoveCreateOrConnectWithoutVersion_groupInput = {
    where: PokemonMoveWhereUniqueInput
    create: XOR<PokemonMoveCreateWithoutVersion_groupInput, PokemonMoveUncheckedCreateWithoutVersion_groupInput>
  }

  export type PokemonMoveCreateManyVersion_groupInputEnvelope = {
    data: PokemonMoveCreateManyVersion_groupInput | PokemonMoveCreateManyVersion_groupInput[]
    skipDuplicates?: boolean
  }

  export type PokedexVersionGroupCreateWithoutVersion_groupInput = {
    id: number
    pokedex: PokedexCreateNestedOneWithoutPokedex_version_groupsInput
  }

  export type PokedexVersionGroupUncheckedCreateWithoutVersion_groupInput = {
    id: number
    pokedex_id: number
  }

  export type PokedexVersionGroupCreateOrConnectWithoutVersion_groupInput = {
    where: PokedexVersionGroupWhereUniqueInput
    create: XOR<PokedexVersionGroupCreateWithoutVersion_groupInput, PokedexVersionGroupUncheckedCreateWithoutVersion_groupInput>
  }

  export type PokedexVersionGroupCreateManyVersion_groupInputEnvelope = {
    data: PokedexVersionGroupCreateManyVersion_groupInput | PokedexVersionGroupCreateManyVersion_groupInput[]
    skipDuplicates?: boolean
  }

  export type GenerationUpsertWithoutVersionGroupsInput = {
    update: XOR<GenerationUpdateWithoutVersionGroupsInput, GenerationUncheckedUpdateWithoutVersionGroupsInput>
    create: XOR<GenerationCreateWithoutVersionGroupsInput, GenerationUncheckedCreateWithoutVersionGroupsInput>
    where?: GenerationWhereInput
  }

  export type GenerationUpdateToOneWithWhereWithoutVersionGroupsInput = {
    where?: GenerationWhereInput
    data: XOR<GenerationUpdateWithoutVersionGroupsInput, GenerationUncheckedUpdateWithoutVersionGroupsInput>
  }

  export type GenerationUpdateWithoutVersionGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutGenerationsNestedInput
    types?: TypeUpdateManyWithoutGenerationNestedInput
  }

  export type GenerationUncheckedUpdateWithoutVersionGroupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
    types?: TypeUncheckedUpdateManyWithoutGenerationNestedInput
  }

  export type VersionUpsertWithWhereUniqueWithoutVersionGroupInput = {
    where: VersionWhereUniqueInput
    update: XOR<VersionUpdateWithoutVersionGroupInput, VersionUncheckedUpdateWithoutVersionGroupInput>
    create: XOR<VersionCreateWithoutVersionGroupInput, VersionUncheckedCreateWithoutVersionGroupInput>
  }

  export type VersionUpdateWithWhereUniqueWithoutVersionGroupInput = {
    where: VersionWhereUniqueInput
    data: XOR<VersionUpdateWithoutVersionGroupInput, VersionUncheckedUpdateWithoutVersionGroupInput>
  }

  export type VersionUpdateManyWithWhereWithoutVersionGroupInput = {
    where: VersionScalarWhereInput
    data: XOR<VersionUpdateManyMutationInput, VersionUncheckedUpdateManyWithoutVersionGroupInput>
  }

  export type VersionScalarWhereInput = {
    AND?: VersionScalarWhereInput | VersionScalarWhereInput[]
    OR?: VersionScalarWhereInput[]
    NOT?: VersionScalarWhereInput | VersionScalarWhereInput[]
    id?: IntFilter<"Version"> | number
    name?: StringFilter<"Version"> | string
    version_group_id?: IntFilter<"Version"> | number
  }

  export type VersionGroupRegionUpsertWithWhereUniqueWithoutVersion_groupInput = {
    where: VersionGroupRegionWhereUniqueInput
    update: XOR<VersionGroupRegionUpdateWithoutVersion_groupInput, VersionGroupRegionUncheckedUpdateWithoutVersion_groupInput>
    create: XOR<VersionGroupRegionCreateWithoutVersion_groupInput, VersionGroupRegionUncheckedCreateWithoutVersion_groupInput>
  }

  export type VersionGroupRegionUpdateWithWhereUniqueWithoutVersion_groupInput = {
    where: VersionGroupRegionWhereUniqueInput
    data: XOR<VersionGroupRegionUpdateWithoutVersion_groupInput, VersionGroupRegionUncheckedUpdateWithoutVersion_groupInput>
  }

  export type VersionGroupRegionUpdateManyWithWhereWithoutVersion_groupInput = {
    where: VersionGroupRegionScalarWhereInput
    data: XOR<VersionGroupRegionUpdateManyMutationInput, VersionGroupRegionUncheckedUpdateManyWithoutVersion_groupInput>
  }

  export type EncounterSlotUpsertWithWhereUniqueWithoutVersion_groupInput = {
    where: EncounterSlotWhereUniqueInput
    update: XOR<EncounterSlotUpdateWithoutVersion_groupInput, EncounterSlotUncheckedUpdateWithoutVersion_groupInput>
    create: XOR<EncounterSlotCreateWithoutVersion_groupInput, EncounterSlotUncheckedCreateWithoutVersion_groupInput>
  }

  export type EncounterSlotUpdateWithWhereUniqueWithoutVersion_groupInput = {
    where: EncounterSlotWhereUniqueInput
    data: XOR<EncounterSlotUpdateWithoutVersion_groupInput, EncounterSlotUncheckedUpdateWithoutVersion_groupInput>
  }

  export type EncounterSlotUpdateManyWithWhereWithoutVersion_groupInput = {
    where: EncounterSlotScalarWhereInput
    data: XOR<EncounterSlotUpdateManyMutationInput, EncounterSlotUncheckedUpdateManyWithoutVersion_groupInput>
  }

  export type EncounterSlotScalarWhereInput = {
    AND?: EncounterSlotScalarWhereInput | EncounterSlotScalarWhereInput[]
    OR?: EncounterSlotScalarWhereInput[]
    NOT?: EncounterSlotScalarWhereInput | EncounterSlotScalarWhereInput[]
    id?: IntFilter<"EncounterSlot"> | number
    version_group_id?: IntFilter<"EncounterSlot"> | number
    encounter_method_id?: IntFilter<"EncounterSlot"> | number
    slot?: IntFilter<"EncounterSlot"> | number
    rarity?: IntFilter<"EncounterSlot"> | number
  }

  export type PokemonMoveUpsertWithWhereUniqueWithoutVersion_groupInput = {
    where: PokemonMoveWhereUniqueInput
    update: XOR<PokemonMoveUpdateWithoutVersion_groupInput, PokemonMoveUncheckedUpdateWithoutVersion_groupInput>
    create: XOR<PokemonMoveCreateWithoutVersion_groupInput, PokemonMoveUncheckedCreateWithoutVersion_groupInput>
  }

  export type PokemonMoveUpdateWithWhereUniqueWithoutVersion_groupInput = {
    where: PokemonMoveWhereUniqueInput
    data: XOR<PokemonMoveUpdateWithoutVersion_groupInput, PokemonMoveUncheckedUpdateWithoutVersion_groupInput>
  }

  export type PokemonMoveUpdateManyWithWhereWithoutVersion_groupInput = {
    where: PokemonMoveScalarWhereInput
    data: XOR<PokemonMoveUpdateManyMutationInput, PokemonMoveUncheckedUpdateManyWithoutVersion_groupInput>
  }

  export type PokedexVersionGroupUpsertWithWhereUniqueWithoutVersion_groupInput = {
    where: PokedexVersionGroupWhereUniqueInput
    update: XOR<PokedexVersionGroupUpdateWithoutVersion_groupInput, PokedexVersionGroupUncheckedUpdateWithoutVersion_groupInput>
    create: XOR<PokedexVersionGroupCreateWithoutVersion_groupInput, PokedexVersionGroupUncheckedCreateWithoutVersion_groupInput>
  }

  export type PokedexVersionGroupUpdateWithWhereUniqueWithoutVersion_groupInput = {
    where: PokedexVersionGroupWhereUniqueInput
    data: XOR<PokedexVersionGroupUpdateWithoutVersion_groupInput, PokedexVersionGroupUncheckedUpdateWithoutVersion_groupInput>
  }

  export type PokedexVersionGroupUpdateManyWithWhereWithoutVersion_groupInput = {
    where: PokedexVersionGroupScalarWhereInput
    data: XOR<PokedexVersionGroupUpdateManyMutationInput, PokedexVersionGroupUncheckedUpdateManyWithoutVersion_groupInput>
  }

  export type PokedexVersionGroupScalarWhereInput = {
    AND?: PokedexVersionGroupScalarWhereInput | PokedexVersionGroupScalarWhereInput[]
    OR?: PokedexVersionGroupScalarWhereInput[]
    NOT?: PokedexVersionGroupScalarWhereInput | PokedexVersionGroupScalarWhereInput[]
    id?: IntFilter<"PokedexVersionGroup"> | number
    version_group_id?: IntFilter<"PokedexVersionGroup"> | number
    pokedex_id?: IntFilter<"PokedexVersionGroup"> | number
  }

  export type RegionCreateWithoutVersion_groupsInput = {
    id: number
    name: string
    locations?: LocationCreateNestedManyWithoutRegionInput
    generations?: GenerationCreateNestedOneWithoutRegionInput
    pokedex?: PokedexCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutVersion_groupsInput = {
    id: number
    name: string
    locations?: LocationUncheckedCreateNestedManyWithoutRegionInput
    generations?: GenerationUncheckedCreateNestedOneWithoutRegionInput
    pokedex?: PokedexUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutVersion_groupsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutVersion_groupsInput, RegionUncheckedCreateWithoutVersion_groupsInput>
  }

  export type VersionGroupCreateWithoutRegionsInput = {
    id: number
    name: string
    generation: GenerationCreateNestedOneWithoutVersionGroupsInput
    versions?: VersionCreateNestedManyWithoutVersionGroupInput
    slots?: EncounterSlotCreateNestedManyWithoutVersion_groupInput
    moves?: PokemonMoveCreateNestedManyWithoutVersion_groupInput
    pokedex_version_groups?: PokedexVersionGroupCreateNestedManyWithoutVersion_groupInput
  }

  export type VersionGroupUncheckedCreateWithoutRegionsInput = {
    id: number
    name: string
    generation_id: number
    versions?: VersionUncheckedCreateNestedManyWithoutVersionGroupInput
    slots?: EncounterSlotUncheckedCreateNestedManyWithoutVersion_groupInput
    moves?: PokemonMoveUncheckedCreateNestedManyWithoutVersion_groupInput
    pokedex_version_groups?: PokedexVersionGroupUncheckedCreateNestedManyWithoutVersion_groupInput
  }

  export type VersionGroupCreateOrConnectWithoutRegionsInput = {
    where: VersionGroupWhereUniqueInput
    create: XOR<VersionGroupCreateWithoutRegionsInput, VersionGroupUncheckedCreateWithoutRegionsInput>
  }

  export type RegionUpsertWithoutVersion_groupsInput = {
    update: XOR<RegionUpdateWithoutVersion_groupsInput, RegionUncheckedUpdateWithoutVersion_groupsInput>
    create: XOR<RegionCreateWithoutVersion_groupsInput, RegionUncheckedCreateWithoutVersion_groupsInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutVersion_groupsInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutVersion_groupsInput, RegionUncheckedUpdateWithoutVersion_groupsInput>
  }

  export type RegionUpdateWithoutVersion_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: LocationUpdateManyWithoutRegionNestedInput
    generations?: GenerationUpdateOneWithoutRegionNestedInput
    pokedex?: PokedexUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutVersion_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: LocationUncheckedUpdateManyWithoutRegionNestedInput
    generations?: GenerationUncheckedUpdateOneWithoutRegionNestedInput
    pokedex?: PokedexUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type VersionGroupUpsertWithoutRegionsInput = {
    update: XOR<VersionGroupUpdateWithoutRegionsInput, VersionGroupUncheckedUpdateWithoutRegionsInput>
    create: XOR<VersionGroupCreateWithoutRegionsInput, VersionGroupUncheckedCreateWithoutRegionsInput>
    where?: VersionGroupWhereInput
  }

  export type VersionGroupUpdateToOneWithWhereWithoutRegionsInput = {
    where?: VersionGroupWhereInput
    data: XOR<VersionGroupUpdateWithoutRegionsInput, VersionGroupUncheckedUpdateWithoutRegionsInput>
  }

  export type VersionGroupUpdateWithoutRegionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation?: GenerationUpdateOneRequiredWithoutVersionGroupsNestedInput
    versions?: VersionUpdateManyWithoutVersionGroupNestedInput
    slots?: EncounterSlotUpdateManyWithoutVersion_groupNestedInput
    moves?: PokemonMoveUpdateManyWithoutVersion_groupNestedInput
    pokedex_version_groups?: PokedexVersionGroupUpdateManyWithoutVersion_groupNestedInput
  }

  export type VersionGroupUncheckedUpdateWithoutRegionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    versions?: VersionUncheckedUpdateManyWithoutVersionGroupNestedInput
    slots?: EncounterSlotUncheckedUpdateManyWithoutVersion_groupNestedInput
    moves?: PokemonMoveUncheckedUpdateManyWithoutVersion_groupNestedInput
    pokedex_version_groups?: PokedexVersionGroupUncheckedUpdateManyWithoutVersion_groupNestedInput
  }

  export type VersionGroupCreateWithoutVersionsInput = {
    id: number
    name: string
    generation: GenerationCreateNestedOneWithoutVersionGroupsInput
    regions?: VersionGroupRegionCreateNestedManyWithoutVersion_groupInput
    slots?: EncounterSlotCreateNestedManyWithoutVersion_groupInput
    moves?: PokemonMoveCreateNestedManyWithoutVersion_groupInput
    pokedex_version_groups?: PokedexVersionGroupCreateNestedManyWithoutVersion_groupInput
  }

  export type VersionGroupUncheckedCreateWithoutVersionsInput = {
    id: number
    name: string
    generation_id: number
    regions?: VersionGroupRegionUncheckedCreateNestedManyWithoutVersion_groupInput
    slots?: EncounterSlotUncheckedCreateNestedManyWithoutVersion_groupInput
    moves?: PokemonMoveUncheckedCreateNestedManyWithoutVersion_groupInput
    pokedex_version_groups?: PokedexVersionGroupUncheckedCreateNestedManyWithoutVersion_groupInput
  }

  export type VersionGroupCreateOrConnectWithoutVersionsInput = {
    where: VersionGroupWhereUniqueInput
    create: XOR<VersionGroupCreateWithoutVersionsInput, VersionGroupUncheckedCreateWithoutVersionsInput>
  }

  export type EncounterCreateWithoutVersionInput = {
    id: number
    min_level: number
    max_level: number
    pokemon: PokemonCreateNestedOneWithoutEncountersInput
    location_area: LocationAreaCreateNestedOneWithoutEncountersInput
    slot: EncounterSlotCreateNestedOneWithoutEncountersInput
    conditions?: EncounterConditionValueMapCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutVersionInput = {
    id: number
    pokemon_id: number
    location_area_id: number
    encounter_slot_id: number
    min_level: number
    max_level: number
    conditions?: EncounterConditionValueMapUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutVersionInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutVersionInput, EncounterUncheckedCreateWithoutVersionInput>
  }

  export type EncounterCreateManyVersionInputEnvelope = {
    data: EncounterCreateManyVersionInput | EncounterCreateManyVersionInput[]
    skipDuplicates?: boolean
  }

  export type LocationAreaEncounterRateCreateWithoutVersionInput = {
    id: number
    rate: number
    location_area: LocationAreaCreateNestedOneWithoutEncounterRatesInput
    encounter_method: EncounterMethodCreateNestedOneWithoutLocation_area_encounter_ratesInput
  }

  export type LocationAreaEncounterRateUncheckedCreateWithoutVersionInput = {
    id: number
    location_area_id: number
    encounter_method_id: number
    rate: number
  }

  export type LocationAreaEncounterRateCreateOrConnectWithoutVersionInput = {
    where: LocationAreaEncounterRateWhereUniqueInput
    create: XOR<LocationAreaEncounterRateCreateWithoutVersionInput, LocationAreaEncounterRateUncheckedCreateWithoutVersionInput>
  }

  export type LocationAreaEncounterRateCreateManyVersionInputEnvelope = {
    data: LocationAreaEncounterRateCreateManyVersionInput | LocationAreaEncounterRateCreateManyVersionInput[]
    skipDuplicates?: boolean
  }

  export type VersionGroupUpsertWithoutVersionsInput = {
    update: XOR<VersionGroupUpdateWithoutVersionsInput, VersionGroupUncheckedUpdateWithoutVersionsInput>
    create: XOR<VersionGroupCreateWithoutVersionsInput, VersionGroupUncheckedCreateWithoutVersionsInput>
    where?: VersionGroupWhereInput
  }

  export type VersionGroupUpdateToOneWithWhereWithoutVersionsInput = {
    where?: VersionGroupWhereInput
    data: XOR<VersionGroupUpdateWithoutVersionsInput, VersionGroupUncheckedUpdateWithoutVersionsInput>
  }

  export type VersionGroupUpdateWithoutVersionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation?: GenerationUpdateOneRequiredWithoutVersionGroupsNestedInput
    regions?: VersionGroupRegionUpdateManyWithoutVersion_groupNestedInput
    slots?: EncounterSlotUpdateManyWithoutVersion_groupNestedInput
    moves?: PokemonMoveUpdateManyWithoutVersion_groupNestedInput
    pokedex_version_groups?: PokedexVersionGroupUpdateManyWithoutVersion_groupNestedInput
  }

  export type VersionGroupUncheckedUpdateWithoutVersionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    regions?: VersionGroupRegionUncheckedUpdateManyWithoutVersion_groupNestedInput
    slots?: EncounterSlotUncheckedUpdateManyWithoutVersion_groupNestedInput
    moves?: PokemonMoveUncheckedUpdateManyWithoutVersion_groupNestedInput
    pokedex_version_groups?: PokedexVersionGroupUncheckedUpdateManyWithoutVersion_groupNestedInput
  }

  export type EncounterUpsertWithWhereUniqueWithoutVersionInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutVersionInput, EncounterUncheckedUpdateWithoutVersionInput>
    create: XOR<EncounterCreateWithoutVersionInput, EncounterUncheckedCreateWithoutVersionInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutVersionInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutVersionInput, EncounterUncheckedUpdateWithoutVersionInput>
  }

  export type EncounterUpdateManyWithWhereWithoutVersionInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutVersionInput>
  }

  export type LocationAreaEncounterRateUpsertWithWhereUniqueWithoutVersionInput = {
    where: LocationAreaEncounterRateWhereUniqueInput
    update: XOR<LocationAreaEncounterRateUpdateWithoutVersionInput, LocationAreaEncounterRateUncheckedUpdateWithoutVersionInput>
    create: XOR<LocationAreaEncounterRateCreateWithoutVersionInput, LocationAreaEncounterRateUncheckedCreateWithoutVersionInput>
  }

  export type LocationAreaEncounterRateUpdateWithWhereUniqueWithoutVersionInput = {
    where: LocationAreaEncounterRateWhereUniqueInput
    data: XOR<LocationAreaEncounterRateUpdateWithoutVersionInput, LocationAreaEncounterRateUncheckedUpdateWithoutVersionInput>
  }

  export type LocationAreaEncounterRateUpdateManyWithWhereWithoutVersionInput = {
    where: LocationAreaEncounterRateScalarWhereInput
    data: XOR<LocationAreaEncounterRateUpdateManyMutationInput, LocationAreaEncounterRateUncheckedUpdateManyWithoutVersionInput>
  }

  export type LocationAreaEncounterRateScalarWhereInput = {
    AND?: LocationAreaEncounterRateScalarWhereInput | LocationAreaEncounterRateScalarWhereInput[]
    OR?: LocationAreaEncounterRateScalarWhereInput[]
    NOT?: LocationAreaEncounterRateScalarWhereInput | LocationAreaEncounterRateScalarWhereInput[]
    id?: IntFilter<"LocationAreaEncounterRate"> | number
    location_area_id?: IntFilter<"LocationAreaEncounterRate"> | number
    encounter_method_id?: IntFilter<"LocationAreaEncounterRate"> | number
    version_id?: IntFilter<"LocationAreaEncounterRate"> | number
    rate?: IntFilter<"LocationAreaEncounterRate"> | number
  }

  export type RegionCreateWithoutLocationsInput = {
    id: number
    name: string
    version_groups?: VersionGroupRegionCreateNestedManyWithoutRegionInput
    generations?: GenerationCreateNestedOneWithoutRegionInput
    pokedex?: PokedexCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutLocationsInput = {
    id: number
    name: string
    version_groups?: VersionGroupRegionUncheckedCreateNestedManyWithoutRegionInput
    generations?: GenerationUncheckedCreateNestedOneWithoutRegionInput
    pokedex?: PokedexUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutLocationsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutLocationsInput, RegionUncheckedCreateWithoutLocationsInput>
  }

  export type LocationAreaCreateWithoutLocationInput = {
    id: number
    name: string
    encounters?: EncounterCreateNestedManyWithoutLocation_areaInput
    encounterRates?: LocationAreaEncounterRateCreateNestedManyWithoutLocation_areaInput
  }

  export type LocationAreaUncheckedCreateWithoutLocationInput = {
    id: number
    name: string
    encounters?: EncounterUncheckedCreateNestedManyWithoutLocation_areaInput
    encounterRates?: LocationAreaEncounterRateUncheckedCreateNestedManyWithoutLocation_areaInput
  }

  export type LocationAreaCreateOrConnectWithoutLocationInput = {
    where: LocationAreaWhereUniqueInput
    create: XOR<LocationAreaCreateWithoutLocationInput, LocationAreaUncheckedCreateWithoutLocationInput>
  }

  export type LocationAreaCreateManyLocationInputEnvelope = {
    data: LocationAreaCreateManyLocationInput | LocationAreaCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type RegionUpsertWithoutLocationsInput = {
    update: XOR<RegionUpdateWithoutLocationsInput, RegionUncheckedUpdateWithoutLocationsInput>
    create: XOR<RegionCreateWithoutLocationsInput, RegionUncheckedCreateWithoutLocationsInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutLocationsInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutLocationsInput, RegionUncheckedUpdateWithoutLocationsInput>
  }

  export type RegionUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    version_groups?: VersionGroupRegionUpdateManyWithoutRegionNestedInput
    generations?: GenerationUpdateOneWithoutRegionNestedInput
    pokedex?: PokedexUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutLocationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    version_groups?: VersionGroupRegionUncheckedUpdateManyWithoutRegionNestedInput
    generations?: GenerationUncheckedUpdateOneWithoutRegionNestedInput
    pokedex?: PokedexUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type LocationAreaUpsertWithWhereUniqueWithoutLocationInput = {
    where: LocationAreaWhereUniqueInput
    update: XOR<LocationAreaUpdateWithoutLocationInput, LocationAreaUncheckedUpdateWithoutLocationInput>
    create: XOR<LocationAreaCreateWithoutLocationInput, LocationAreaUncheckedCreateWithoutLocationInput>
  }

  export type LocationAreaUpdateWithWhereUniqueWithoutLocationInput = {
    where: LocationAreaWhereUniqueInput
    data: XOR<LocationAreaUpdateWithoutLocationInput, LocationAreaUncheckedUpdateWithoutLocationInput>
  }

  export type LocationAreaUpdateManyWithWhereWithoutLocationInput = {
    where: LocationAreaScalarWhereInput
    data: XOR<LocationAreaUpdateManyMutationInput, LocationAreaUncheckedUpdateManyWithoutLocationInput>
  }

  export type LocationAreaScalarWhereInput = {
    AND?: LocationAreaScalarWhereInput | LocationAreaScalarWhereInput[]
    OR?: LocationAreaScalarWhereInput[]
    NOT?: LocationAreaScalarWhereInput | LocationAreaScalarWhereInput[]
    id?: IntFilter<"LocationArea"> | number
    name?: StringFilter<"LocationArea"> | string
    location_id?: IntFilter<"LocationArea"> | number
  }

  export type LocationCreateWithoutAreasInput = {
    id: number
    name: string
    region: RegionCreateNestedOneWithoutLocationsInput
  }

  export type LocationUncheckedCreateWithoutAreasInput = {
    id: number
    name: string
    region_id: number
  }

  export type LocationCreateOrConnectWithoutAreasInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutAreasInput, LocationUncheckedCreateWithoutAreasInput>
  }

  export type EncounterCreateWithoutLocation_areaInput = {
    id: number
    min_level: number
    max_level: number
    version: VersionCreateNestedOneWithoutEncountersInput
    pokemon: PokemonCreateNestedOneWithoutEncountersInput
    slot: EncounterSlotCreateNestedOneWithoutEncountersInput
    conditions?: EncounterConditionValueMapCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutLocation_areaInput = {
    id: number
    version_id: number
    pokemon_id: number
    encounter_slot_id: number
    min_level: number
    max_level: number
    conditions?: EncounterConditionValueMapUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutLocation_areaInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutLocation_areaInput, EncounterUncheckedCreateWithoutLocation_areaInput>
  }

  export type EncounterCreateManyLocation_areaInputEnvelope = {
    data: EncounterCreateManyLocation_areaInput | EncounterCreateManyLocation_areaInput[]
    skipDuplicates?: boolean
  }

  export type LocationAreaEncounterRateCreateWithoutLocation_areaInput = {
    id: number
    rate: number
    encounter_method: EncounterMethodCreateNestedOneWithoutLocation_area_encounter_ratesInput
    version: VersionCreateNestedOneWithoutEncounterRatesInput
  }

  export type LocationAreaEncounterRateUncheckedCreateWithoutLocation_areaInput = {
    id: number
    encounter_method_id: number
    version_id: number
    rate: number
  }

  export type LocationAreaEncounterRateCreateOrConnectWithoutLocation_areaInput = {
    where: LocationAreaEncounterRateWhereUniqueInput
    create: XOR<LocationAreaEncounterRateCreateWithoutLocation_areaInput, LocationAreaEncounterRateUncheckedCreateWithoutLocation_areaInput>
  }

  export type LocationAreaEncounterRateCreateManyLocation_areaInputEnvelope = {
    data: LocationAreaEncounterRateCreateManyLocation_areaInput | LocationAreaEncounterRateCreateManyLocation_areaInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutAreasInput = {
    update: XOR<LocationUpdateWithoutAreasInput, LocationUncheckedUpdateWithoutAreasInput>
    create: XOR<LocationCreateWithoutAreasInput, LocationUncheckedCreateWithoutAreasInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutAreasInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutAreasInput, LocationUncheckedUpdateWithoutAreasInput>
  }

  export type LocationUpdateWithoutAreasInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutLocationsNestedInput
  }

  export type LocationUncheckedUpdateWithoutAreasInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterUpsertWithWhereUniqueWithoutLocation_areaInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutLocation_areaInput, EncounterUncheckedUpdateWithoutLocation_areaInput>
    create: XOR<EncounterCreateWithoutLocation_areaInput, EncounterUncheckedCreateWithoutLocation_areaInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutLocation_areaInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutLocation_areaInput, EncounterUncheckedUpdateWithoutLocation_areaInput>
  }

  export type EncounterUpdateManyWithWhereWithoutLocation_areaInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutLocation_areaInput>
  }

  export type LocationAreaEncounterRateUpsertWithWhereUniqueWithoutLocation_areaInput = {
    where: LocationAreaEncounterRateWhereUniqueInput
    update: XOR<LocationAreaEncounterRateUpdateWithoutLocation_areaInput, LocationAreaEncounterRateUncheckedUpdateWithoutLocation_areaInput>
    create: XOR<LocationAreaEncounterRateCreateWithoutLocation_areaInput, LocationAreaEncounterRateUncheckedCreateWithoutLocation_areaInput>
  }

  export type LocationAreaEncounterRateUpdateWithWhereUniqueWithoutLocation_areaInput = {
    where: LocationAreaEncounterRateWhereUniqueInput
    data: XOR<LocationAreaEncounterRateUpdateWithoutLocation_areaInput, LocationAreaEncounterRateUncheckedUpdateWithoutLocation_areaInput>
  }

  export type LocationAreaEncounterRateUpdateManyWithWhereWithoutLocation_areaInput = {
    where: LocationAreaEncounterRateScalarWhereInput
    data: XOR<LocationAreaEncounterRateUpdateManyMutationInput, LocationAreaEncounterRateUncheckedUpdateManyWithoutLocation_areaInput>
  }

  export type EncounterSlotCreateWithoutMethodInput = {
    id: number
    slot: number
    rarity: number
    version_group: VersionGroupCreateNestedOneWithoutSlotsInput
    encounters?: EncounterCreateNestedManyWithoutSlotInput
  }

  export type EncounterSlotUncheckedCreateWithoutMethodInput = {
    id: number
    version_group_id: number
    slot: number
    rarity: number
    encounters?: EncounterUncheckedCreateNestedManyWithoutSlotInput
  }

  export type EncounterSlotCreateOrConnectWithoutMethodInput = {
    where: EncounterSlotWhereUniqueInput
    create: XOR<EncounterSlotCreateWithoutMethodInput, EncounterSlotUncheckedCreateWithoutMethodInput>
  }

  export type EncounterSlotCreateManyMethodInputEnvelope = {
    data: EncounterSlotCreateManyMethodInput | EncounterSlotCreateManyMethodInput[]
    skipDuplicates?: boolean
  }

  export type LocationAreaEncounterRateCreateWithoutEncounter_methodInput = {
    id: number
    rate: number
    location_area: LocationAreaCreateNestedOneWithoutEncounterRatesInput
    version: VersionCreateNestedOneWithoutEncounterRatesInput
  }

  export type LocationAreaEncounterRateUncheckedCreateWithoutEncounter_methodInput = {
    id: number
    location_area_id: number
    version_id: number
    rate: number
  }

  export type LocationAreaEncounterRateCreateOrConnectWithoutEncounter_methodInput = {
    where: LocationAreaEncounterRateWhereUniqueInput
    create: XOR<LocationAreaEncounterRateCreateWithoutEncounter_methodInput, LocationAreaEncounterRateUncheckedCreateWithoutEncounter_methodInput>
  }

  export type LocationAreaEncounterRateCreateManyEncounter_methodInputEnvelope = {
    data: LocationAreaEncounterRateCreateManyEncounter_methodInput | LocationAreaEncounterRateCreateManyEncounter_methodInput[]
    skipDuplicates?: boolean
  }

  export type EncounterSlotUpsertWithWhereUniqueWithoutMethodInput = {
    where: EncounterSlotWhereUniqueInput
    update: XOR<EncounterSlotUpdateWithoutMethodInput, EncounterSlotUncheckedUpdateWithoutMethodInput>
    create: XOR<EncounterSlotCreateWithoutMethodInput, EncounterSlotUncheckedCreateWithoutMethodInput>
  }

  export type EncounterSlotUpdateWithWhereUniqueWithoutMethodInput = {
    where: EncounterSlotWhereUniqueInput
    data: XOR<EncounterSlotUpdateWithoutMethodInput, EncounterSlotUncheckedUpdateWithoutMethodInput>
  }

  export type EncounterSlotUpdateManyWithWhereWithoutMethodInput = {
    where: EncounterSlotScalarWhereInput
    data: XOR<EncounterSlotUpdateManyMutationInput, EncounterSlotUncheckedUpdateManyWithoutMethodInput>
  }

  export type LocationAreaEncounterRateUpsertWithWhereUniqueWithoutEncounter_methodInput = {
    where: LocationAreaEncounterRateWhereUniqueInput
    update: XOR<LocationAreaEncounterRateUpdateWithoutEncounter_methodInput, LocationAreaEncounterRateUncheckedUpdateWithoutEncounter_methodInput>
    create: XOR<LocationAreaEncounterRateCreateWithoutEncounter_methodInput, LocationAreaEncounterRateUncheckedCreateWithoutEncounter_methodInput>
  }

  export type LocationAreaEncounterRateUpdateWithWhereUniqueWithoutEncounter_methodInput = {
    where: LocationAreaEncounterRateWhereUniqueInput
    data: XOR<LocationAreaEncounterRateUpdateWithoutEncounter_methodInput, LocationAreaEncounterRateUncheckedUpdateWithoutEncounter_methodInput>
  }

  export type LocationAreaEncounterRateUpdateManyWithWhereWithoutEncounter_methodInput = {
    where: LocationAreaEncounterRateScalarWhereInput
    data: XOR<LocationAreaEncounterRateUpdateManyMutationInput, LocationAreaEncounterRateUncheckedUpdateManyWithoutEncounter_methodInput>
  }

  export type VersionGroupCreateWithoutSlotsInput = {
    id: number
    name: string
    generation: GenerationCreateNestedOneWithoutVersionGroupsInput
    versions?: VersionCreateNestedManyWithoutVersionGroupInput
    regions?: VersionGroupRegionCreateNestedManyWithoutVersion_groupInput
    moves?: PokemonMoveCreateNestedManyWithoutVersion_groupInput
    pokedex_version_groups?: PokedexVersionGroupCreateNestedManyWithoutVersion_groupInput
  }

  export type VersionGroupUncheckedCreateWithoutSlotsInput = {
    id: number
    name: string
    generation_id: number
    versions?: VersionUncheckedCreateNestedManyWithoutVersionGroupInput
    regions?: VersionGroupRegionUncheckedCreateNestedManyWithoutVersion_groupInput
    moves?: PokemonMoveUncheckedCreateNestedManyWithoutVersion_groupInput
    pokedex_version_groups?: PokedexVersionGroupUncheckedCreateNestedManyWithoutVersion_groupInput
  }

  export type VersionGroupCreateOrConnectWithoutSlotsInput = {
    where: VersionGroupWhereUniqueInput
    create: XOR<VersionGroupCreateWithoutSlotsInput, VersionGroupUncheckedCreateWithoutSlotsInput>
  }

  export type EncounterMethodCreateWithoutSlotsInput = {
    id: number
    name: string
    location_area_encounter_rates?: LocationAreaEncounterRateCreateNestedManyWithoutEncounter_methodInput
  }

  export type EncounterMethodUncheckedCreateWithoutSlotsInput = {
    id: number
    name: string
    location_area_encounter_rates?: LocationAreaEncounterRateUncheckedCreateNestedManyWithoutEncounter_methodInput
  }

  export type EncounterMethodCreateOrConnectWithoutSlotsInput = {
    where: EncounterMethodWhereUniqueInput
    create: XOR<EncounterMethodCreateWithoutSlotsInput, EncounterMethodUncheckedCreateWithoutSlotsInput>
  }

  export type EncounterCreateWithoutSlotInput = {
    id: number
    min_level: number
    max_level: number
    version: VersionCreateNestedOneWithoutEncountersInput
    pokemon: PokemonCreateNestedOneWithoutEncountersInput
    location_area: LocationAreaCreateNestedOneWithoutEncountersInput
    conditions?: EncounterConditionValueMapCreateNestedManyWithoutEncounterInput
  }

  export type EncounterUncheckedCreateWithoutSlotInput = {
    id: number
    version_id: number
    pokemon_id: number
    location_area_id: number
    min_level: number
    max_level: number
    conditions?: EncounterConditionValueMapUncheckedCreateNestedManyWithoutEncounterInput
  }

  export type EncounterCreateOrConnectWithoutSlotInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutSlotInput, EncounterUncheckedCreateWithoutSlotInput>
  }

  export type EncounterCreateManySlotInputEnvelope = {
    data: EncounterCreateManySlotInput | EncounterCreateManySlotInput[]
    skipDuplicates?: boolean
  }

  export type VersionGroupUpsertWithoutSlotsInput = {
    update: XOR<VersionGroupUpdateWithoutSlotsInput, VersionGroupUncheckedUpdateWithoutSlotsInput>
    create: XOR<VersionGroupCreateWithoutSlotsInput, VersionGroupUncheckedCreateWithoutSlotsInput>
    where?: VersionGroupWhereInput
  }

  export type VersionGroupUpdateToOneWithWhereWithoutSlotsInput = {
    where?: VersionGroupWhereInput
    data: XOR<VersionGroupUpdateWithoutSlotsInput, VersionGroupUncheckedUpdateWithoutSlotsInput>
  }

  export type VersionGroupUpdateWithoutSlotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation?: GenerationUpdateOneRequiredWithoutVersionGroupsNestedInput
    versions?: VersionUpdateManyWithoutVersionGroupNestedInput
    regions?: VersionGroupRegionUpdateManyWithoutVersion_groupNestedInput
    moves?: PokemonMoveUpdateManyWithoutVersion_groupNestedInput
    pokedex_version_groups?: PokedexVersionGroupUpdateManyWithoutVersion_groupNestedInput
  }

  export type VersionGroupUncheckedUpdateWithoutSlotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    versions?: VersionUncheckedUpdateManyWithoutVersionGroupNestedInput
    regions?: VersionGroupRegionUncheckedUpdateManyWithoutVersion_groupNestedInput
    moves?: PokemonMoveUncheckedUpdateManyWithoutVersion_groupNestedInput
    pokedex_version_groups?: PokedexVersionGroupUncheckedUpdateManyWithoutVersion_groupNestedInput
  }

  export type EncounterMethodUpsertWithoutSlotsInput = {
    update: XOR<EncounterMethodUpdateWithoutSlotsInput, EncounterMethodUncheckedUpdateWithoutSlotsInput>
    create: XOR<EncounterMethodCreateWithoutSlotsInput, EncounterMethodUncheckedCreateWithoutSlotsInput>
    where?: EncounterMethodWhereInput
  }

  export type EncounterMethodUpdateToOneWithWhereWithoutSlotsInput = {
    where?: EncounterMethodWhereInput
    data: XOR<EncounterMethodUpdateWithoutSlotsInput, EncounterMethodUncheckedUpdateWithoutSlotsInput>
  }

  export type EncounterMethodUpdateWithoutSlotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location_area_encounter_rates?: LocationAreaEncounterRateUpdateManyWithoutEncounter_methodNestedInput
  }

  export type EncounterMethodUncheckedUpdateWithoutSlotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location_area_encounter_rates?: LocationAreaEncounterRateUncheckedUpdateManyWithoutEncounter_methodNestedInput
  }

  export type EncounterUpsertWithWhereUniqueWithoutSlotInput = {
    where: EncounterWhereUniqueInput
    update: XOR<EncounterUpdateWithoutSlotInput, EncounterUncheckedUpdateWithoutSlotInput>
    create: XOR<EncounterCreateWithoutSlotInput, EncounterUncheckedCreateWithoutSlotInput>
  }

  export type EncounterUpdateWithWhereUniqueWithoutSlotInput = {
    where: EncounterWhereUniqueInput
    data: XOR<EncounterUpdateWithoutSlotInput, EncounterUncheckedUpdateWithoutSlotInput>
  }

  export type EncounterUpdateManyWithWhereWithoutSlotInput = {
    where: EncounterScalarWhereInput
    data: XOR<EncounterUpdateManyMutationInput, EncounterUncheckedUpdateManyWithoutSlotInput>
  }

  export type VersionCreateWithoutEncountersInput = {
    id: number
    name: string
    versionGroup: VersionGroupCreateNestedOneWithoutVersionsInput
    encounterRates?: LocationAreaEncounterRateCreateNestedManyWithoutVersionInput
  }

  export type VersionUncheckedCreateWithoutEncountersInput = {
    id: number
    name: string
    version_group_id: number
    encounterRates?: LocationAreaEncounterRateUncheckedCreateNestedManyWithoutVersionInput
  }

  export type VersionCreateOrConnectWithoutEncountersInput = {
    where: VersionWhereUniqueInput
    create: XOR<VersionCreateWithoutEncountersInput, VersionUncheckedCreateWithoutEncountersInput>
  }

  export type PokemonCreateWithoutEncountersInput = {
    id: number
    name: string
    abilities?: PokemonAbilityCreateNestedManyWithoutPokemonInput
    natures?: PokemonNatureCreateNestedManyWithoutPokemonInput
    stats?: PokemonStatCreateNestedManyWithoutPokemonInput
    types?: PokemonTypeCreateNestedManyWithoutPokemonInput
    egg_groups?: PokemonEggGroupCreateNestedManyWithoutPokemonInput
    dex_numbers?: PokemonDexNumberCreateNestedManyWithoutPokemonInput
    move?: PokemonMoveCreateNestedManyWithoutPokemonInput
  }

  export type PokemonUncheckedCreateWithoutEncountersInput = {
    id: number
    name: string
    abilities?: PokemonAbilityUncheckedCreateNestedManyWithoutPokemonInput
    natures?: PokemonNatureUncheckedCreateNestedManyWithoutPokemonInput
    stats?: PokemonStatUncheckedCreateNestedManyWithoutPokemonInput
    types?: PokemonTypeUncheckedCreateNestedManyWithoutPokemonInput
    egg_groups?: PokemonEggGroupUncheckedCreateNestedManyWithoutPokemonInput
    dex_numbers?: PokemonDexNumberUncheckedCreateNestedManyWithoutPokemonInput
    move?: PokemonMoveUncheckedCreateNestedManyWithoutPokemonInput
  }

  export type PokemonCreateOrConnectWithoutEncountersInput = {
    where: PokemonWhereUniqueInput
    create: XOR<PokemonCreateWithoutEncountersInput, PokemonUncheckedCreateWithoutEncountersInput>
  }

  export type LocationAreaCreateWithoutEncountersInput = {
    id: number
    name: string
    location: LocationCreateNestedOneWithoutAreasInput
    encounterRates?: LocationAreaEncounterRateCreateNestedManyWithoutLocation_areaInput
  }

  export type LocationAreaUncheckedCreateWithoutEncountersInput = {
    id: number
    name: string
    location_id: number
    encounterRates?: LocationAreaEncounterRateUncheckedCreateNestedManyWithoutLocation_areaInput
  }

  export type LocationAreaCreateOrConnectWithoutEncountersInput = {
    where: LocationAreaWhereUniqueInput
    create: XOR<LocationAreaCreateWithoutEncountersInput, LocationAreaUncheckedCreateWithoutEncountersInput>
  }

  export type EncounterSlotCreateWithoutEncountersInput = {
    id: number
    slot: number
    rarity: number
    version_group: VersionGroupCreateNestedOneWithoutSlotsInput
    method: EncounterMethodCreateNestedOneWithoutSlotsInput
  }

  export type EncounterSlotUncheckedCreateWithoutEncountersInput = {
    id: number
    version_group_id: number
    encounter_method_id: number
    slot: number
    rarity: number
  }

  export type EncounterSlotCreateOrConnectWithoutEncountersInput = {
    where: EncounterSlotWhereUniqueInput
    create: XOR<EncounterSlotCreateWithoutEncountersInput, EncounterSlotUncheckedCreateWithoutEncountersInput>
  }

  export type EncounterConditionValueMapCreateWithoutEncounterInput = {
    id: number
    value: EncounterConditionValueCreateNestedOneWithoutMapsInput
  }

  export type EncounterConditionValueMapUncheckedCreateWithoutEncounterInput = {
    id: number
    encounter_condition_value_id: number
  }

  export type EncounterConditionValueMapCreateOrConnectWithoutEncounterInput = {
    where: EncounterConditionValueMapWhereUniqueInput
    create: XOR<EncounterConditionValueMapCreateWithoutEncounterInput, EncounterConditionValueMapUncheckedCreateWithoutEncounterInput>
  }

  export type EncounterConditionValueMapCreateManyEncounterInputEnvelope = {
    data: EncounterConditionValueMapCreateManyEncounterInput | EncounterConditionValueMapCreateManyEncounterInput[]
    skipDuplicates?: boolean
  }

  export type VersionUpsertWithoutEncountersInput = {
    update: XOR<VersionUpdateWithoutEncountersInput, VersionUncheckedUpdateWithoutEncountersInput>
    create: XOR<VersionCreateWithoutEncountersInput, VersionUncheckedCreateWithoutEncountersInput>
    where?: VersionWhereInput
  }

  export type VersionUpdateToOneWithWhereWithoutEncountersInput = {
    where?: VersionWhereInput
    data: XOR<VersionUpdateWithoutEncountersInput, VersionUncheckedUpdateWithoutEncountersInput>
  }

  export type VersionUpdateWithoutEncountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    versionGroup?: VersionGroupUpdateOneRequiredWithoutVersionsNestedInput
    encounterRates?: LocationAreaEncounterRateUpdateManyWithoutVersionNestedInput
  }

  export type VersionUncheckedUpdateWithoutEncountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    version_group_id?: IntFieldUpdateOperationsInput | number
    encounterRates?: LocationAreaEncounterRateUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type PokemonUpsertWithoutEncountersInput = {
    update: XOR<PokemonUpdateWithoutEncountersInput, PokemonUncheckedUpdateWithoutEncountersInput>
    create: XOR<PokemonCreateWithoutEncountersInput, PokemonUncheckedCreateWithoutEncountersInput>
    where?: PokemonWhereInput
  }

  export type PokemonUpdateToOneWithWhereWithoutEncountersInput = {
    where?: PokemonWhereInput
    data: XOR<PokemonUpdateWithoutEncountersInput, PokemonUncheckedUpdateWithoutEncountersInput>
  }

  export type PokemonUpdateWithoutEncountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abilities?: PokemonAbilityUpdateManyWithoutPokemonNestedInput
    natures?: PokemonNatureUpdateManyWithoutPokemonNestedInput
    stats?: PokemonStatUpdateManyWithoutPokemonNestedInput
    types?: PokemonTypeUpdateManyWithoutPokemonNestedInput
    egg_groups?: PokemonEggGroupUpdateManyWithoutPokemonNestedInput
    dex_numbers?: PokemonDexNumberUpdateManyWithoutPokemonNestedInput
    move?: PokemonMoveUpdateManyWithoutPokemonNestedInput
  }

  export type PokemonUncheckedUpdateWithoutEncountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abilities?: PokemonAbilityUncheckedUpdateManyWithoutPokemonNestedInput
    natures?: PokemonNatureUncheckedUpdateManyWithoutPokemonNestedInput
    stats?: PokemonStatUncheckedUpdateManyWithoutPokemonNestedInput
    types?: PokemonTypeUncheckedUpdateManyWithoutPokemonNestedInput
    egg_groups?: PokemonEggGroupUncheckedUpdateManyWithoutPokemonNestedInput
    dex_numbers?: PokemonDexNumberUncheckedUpdateManyWithoutPokemonNestedInput
    move?: PokemonMoveUncheckedUpdateManyWithoutPokemonNestedInput
  }

  export type LocationAreaUpsertWithoutEncountersInput = {
    update: XOR<LocationAreaUpdateWithoutEncountersInput, LocationAreaUncheckedUpdateWithoutEncountersInput>
    create: XOR<LocationAreaCreateWithoutEncountersInput, LocationAreaUncheckedCreateWithoutEncountersInput>
    where?: LocationAreaWhereInput
  }

  export type LocationAreaUpdateToOneWithWhereWithoutEncountersInput = {
    where?: LocationAreaWhereInput
    data: XOR<LocationAreaUpdateWithoutEncountersInput, LocationAreaUncheckedUpdateWithoutEncountersInput>
  }

  export type LocationAreaUpdateWithoutEncountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: LocationUpdateOneRequiredWithoutAreasNestedInput
    encounterRates?: LocationAreaEncounterRateUpdateManyWithoutLocation_areaNestedInput
  }

  export type LocationAreaUncheckedUpdateWithoutEncountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location_id?: IntFieldUpdateOperationsInput | number
    encounterRates?: LocationAreaEncounterRateUncheckedUpdateManyWithoutLocation_areaNestedInput
  }

  export type EncounterSlotUpsertWithoutEncountersInput = {
    update: XOR<EncounterSlotUpdateWithoutEncountersInput, EncounterSlotUncheckedUpdateWithoutEncountersInput>
    create: XOR<EncounterSlotCreateWithoutEncountersInput, EncounterSlotUncheckedCreateWithoutEncountersInput>
    where?: EncounterSlotWhereInput
  }

  export type EncounterSlotUpdateToOneWithWhereWithoutEncountersInput = {
    where?: EncounterSlotWhereInput
    data: XOR<EncounterSlotUpdateWithoutEncountersInput, EncounterSlotUncheckedUpdateWithoutEncountersInput>
  }

  export type EncounterSlotUpdateWithoutEncountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    slot?: IntFieldUpdateOperationsInput | number
    rarity?: IntFieldUpdateOperationsInput | number
    version_group?: VersionGroupUpdateOneRequiredWithoutSlotsNestedInput
    method?: EncounterMethodUpdateOneRequiredWithoutSlotsNestedInput
  }

  export type EncounterSlotUncheckedUpdateWithoutEncountersInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
    encounter_method_id?: IntFieldUpdateOperationsInput | number
    slot?: IntFieldUpdateOperationsInput | number
    rarity?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterConditionValueMapUpsertWithWhereUniqueWithoutEncounterInput = {
    where: EncounterConditionValueMapWhereUniqueInput
    update: XOR<EncounterConditionValueMapUpdateWithoutEncounterInput, EncounterConditionValueMapUncheckedUpdateWithoutEncounterInput>
    create: XOR<EncounterConditionValueMapCreateWithoutEncounterInput, EncounterConditionValueMapUncheckedCreateWithoutEncounterInput>
  }

  export type EncounterConditionValueMapUpdateWithWhereUniqueWithoutEncounterInput = {
    where: EncounterConditionValueMapWhereUniqueInput
    data: XOR<EncounterConditionValueMapUpdateWithoutEncounterInput, EncounterConditionValueMapUncheckedUpdateWithoutEncounterInput>
  }

  export type EncounterConditionValueMapUpdateManyWithWhereWithoutEncounterInput = {
    where: EncounterConditionValueMapScalarWhereInput
    data: XOR<EncounterConditionValueMapUpdateManyMutationInput, EncounterConditionValueMapUncheckedUpdateManyWithoutEncounterInput>
  }

  export type EncounterConditionValueMapScalarWhereInput = {
    AND?: EncounterConditionValueMapScalarWhereInput | EncounterConditionValueMapScalarWhereInput[]
    OR?: EncounterConditionValueMapScalarWhereInput[]
    NOT?: EncounterConditionValueMapScalarWhereInput | EncounterConditionValueMapScalarWhereInput[]
    id?: IntFilter<"EncounterConditionValueMap"> | number
    encounter_id?: IntFilter<"EncounterConditionValueMap"> | number
    encounter_condition_value_id?: IntFilter<"EncounterConditionValueMap"> | number
  }

  export type EncounterConditionValueCreateWithoutConditionInput = {
    id: number
    name: string
    is_default: boolean
    maps?: EncounterConditionValueMapCreateNestedManyWithoutValueInput
  }

  export type EncounterConditionValueUncheckedCreateWithoutConditionInput = {
    id: number
    name: string
    is_default: boolean
    maps?: EncounterConditionValueMapUncheckedCreateNestedManyWithoutValueInput
  }

  export type EncounterConditionValueCreateOrConnectWithoutConditionInput = {
    where: EncounterConditionValueWhereUniqueInput
    create: XOR<EncounterConditionValueCreateWithoutConditionInput, EncounterConditionValueUncheckedCreateWithoutConditionInput>
  }

  export type EncounterConditionValueCreateManyConditionInputEnvelope = {
    data: EncounterConditionValueCreateManyConditionInput | EncounterConditionValueCreateManyConditionInput[]
    skipDuplicates?: boolean
  }

  export type EncounterConditionValueUpsertWithWhereUniqueWithoutConditionInput = {
    where: EncounterConditionValueWhereUniqueInput
    update: XOR<EncounterConditionValueUpdateWithoutConditionInput, EncounterConditionValueUncheckedUpdateWithoutConditionInput>
    create: XOR<EncounterConditionValueCreateWithoutConditionInput, EncounterConditionValueUncheckedCreateWithoutConditionInput>
  }

  export type EncounterConditionValueUpdateWithWhereUniqueWithoutConditionInput = {
    where: EncounterConditionValueWhereUniqueInput
    data: XOR<EncounterConditionValueUpdateWithoutConditionInput, EncounterConditionValueUncheckedUpdateWithoutConditionInput>
  }

  export type EncounterConditionValueUpdateManyWithWhereWithoutConditionInput = {
    where: EncounterConditionValueScalarWhereInput
    data: XOR<EncounterConditionValueUpdateManyMutationInput, EncounterConditionValueUncheckedUpdateManyWithoutConditionInput>
  }

  export type EncounterConditionValueScalarWhereInput = {
    AND?: EncounterConditionValueScalarWhereInput | EncounterConditionValueScalarWhereInput[]
    OR?: EncounterConditionValueScalarWhereInput[]
    NOT?: EncounterConditionValueScalarWhereInput | EncounterConditionValueScalarWhereInput[]
    id?: IntFilter<"EncounterConditionValue"> | number
    encounter_condition_id?: IntFilter<"EncounterConditionValue"> | number
    name?: StringFilter<"EncounterConditionValue"> | string
    is_default?: BoolFilter<"EncounterConditionValue"> | boolean
  }

  export type EncounterConditionCreateWithoutValuesInput = {
    id: number
    name: string
  }

  export type EncounterConditionUncheckedCreateWithoutValuesInput = {
    id: number
    name: string
  }

  export type EncounterConditionCreateOrConnectWithoutValuesInput = {
    where: EncounterConditionWhereUniqueInput
    create: XOR<EncounterConditionCreateWithoutValuesInput, EncounterConditionUncheckedCreateWithoutValuesInput>
  }

  export type EncounterConditionValueMapCreateWithoutValueInput = {
    id: number
    encounter: EncounterCreateNestedOneWithoutConditionsInput
  }

  export type EncounterConditionValueMapUncheckedCreateWithoutValueInput = {
    id: number
    encounter_id: number
  }

  export type EncounterConditionValueMapCreateOrConnectWithoutValueInput = {
    where: EncounterConditionValueMapWhereUniqueInput
    create: XOR<EncounterConditionValueMapCreateWithoutValueInput, EncounterConditionValueMapUncheckedCreateWithoutValueInput>
  }

  export type EncounterConditionValueMapCreateManyValueInputEnvelope = {
    data: EncounterConditionValueMapCreateManyValueInput | EncounterConditionValueMapCreateManyValueInput[]
    skipDuplicates?: boolean
  }

  export type EncounterConditionUpsertWithoutValuesInput = {
    update: XOR<EncounterConditionUpdateWithoutValuesInput, EncounterConditionUncheckedUpdateWithoutValuesInput>
    create: XOR<EncounterConditionCreateWithoutValuesInput, EncounterConditionUncheckedCreateWithoutValuesInput>
    where?: EncounterConditionWhereInput
  }

  export type EncounterConditionUpdateToOneWithWhereWithoutValuesInput = {
    where?: EncounterConditionWhereInput
    data: XOR<EncounterConditionUpdateWithoutValuesInput, EncounterConditionUncheckedUpdateWithoutValuesInput>
  }

  export type EncounterConditionUpdateWithoutValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EncounterConditionUncheckedUpdateWithoutValuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EncounterConditionValueMapUpsertWithWhereUniqueWithoutValueInput = {
    where: EncounterConditionValueMapWhereUniqueInput
    update: XOR<EncounterConditionValueMapUpdateWithoutValueInput, EncounterConditionValueMapUncheckedUpdateWithoutValueInput>
    create: XOR<EncounterConditionValueMapCreateWithoutValueInput, EncounterConditionValueMapUncheckedCreateWithoutValueInput>
  }

  export type EncounterConditionValueMapUpdateWithWhereUniqueWithoutValueInput = {
    where: EncounterConditionValueMapWhereUniqueInput
    data: XOR<EncounterConditionValueMapUpdateWithoutValueInput, EncounterConditionValueMapUncheckedUpdateWithoutValueInput>
  }

  export type EncounterConditionValueMapUpdateManyWithWhereWithoutValueInput = {
    where: EncounterConditionValueMapScalarWhereInput
    data: XOR<EncounterConditionValueMapUpdateManyMutationInput, EncounterConditionValueMapUncheckedUpdateManyWithoutValueInput>
  }

  export type EncounterCreateWithoutConditionsInput = {
    id: number
    min_level: number
    max_level: number
    version: VersionCreateNestedOneWithoutEncountersInput
    pokemon: PokemonCreateNestedOneWithoutEncountersInput
    location_area: LocationAreaCreateNestedOneWithoutEncountersInput
    slot: EncounterSlotCreateNestedOneWithoutEncountersInput
  }

  export type EncounterUncheckedCreateWithoutConditionsInput = {
    id: number
    version_id: number
    pokemon_id: number
    location_area_id: number
    encounter_slot_id: number
    min_level: number
    max_level: number
  }

  export type EncounterCreateOrConnectWithoutConditionsInput = {
    where: EncounterWhereUniqueInput
    create: XOR<EncounterCreateWithoutConditionsInput, EncounterUncheckedCreateWithoutConditionsInput>
  }

  export type EncounterConditionValueCreateWithoutMapsInput = {
    id: number
    name: string
    is_default: boolean
    condition: EncounterConditionCreateNestedOneWithoutValuesInput
  }

  export type EncounterConditionValueUncheckedCreateWithoutMapsInput = {
    id: number
    encounter_condition_id: number
    name: string
    is_default: boolean
  }

  export type EncounterConditionValueCreateOrConnectWithoutMapsInput = {
    where: EncounterConditionValueWhereUniqueInput
    create: XOR<EncounterConditionValueCreateWithoutMapsInput, EncounterConditionValueUncheckedCreateWithoutMapsInput>
  }

  export type EncounterUpsertWithoutConditionsInput = {
    update: XOR<EncounterUpdateWithoutConditionsInput, EncounterUncheckedUpdateWithoutConditionsInput>
    create: XOR<EncounterCreateWithoutConditionsInput, EncounterUncheckedCreateWithoutConditionsInput>
    where?: EncounterWhereInput
  }

  export type EncounterUpdateToOneWithWhereWithoutConditionsInput = {
    where?: EncounterWhereInput
    data: XOR<EncounterUpdateWithoutConditionsInput, EncounterUncheckedUpdateWithoutConditionsInput>
  }

  export type EncounterUpdateWithoutConditionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    min_level?: IntFieldUpdateOperationsInput | number
    max_level?: IntFieldUpdateOperationsInput | number
    version?: VersionUpdateOneRequiredWithoutEncountersNestedInput
    pokemon?: PokemonUpdateOneRequiredWithoutEncountersNestedInput
    location_area?: LocationAreaUpdateOneRequiredWithoutEncountersNestedInput
    slot?: EncounterSlotUpdateOneRequiredWithoutEncountersNestedInput
  }

  export type EncounterUncheckedUpdateWithoutConditionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    location_area_id?: IntFieldUpdateOperationsInput | number
    encounter_slot_id?: IntFieldUpdateOperationsInput | number
    min_level?: IntFieldUpdateOperationsInput | number
    max_level?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterConditionValueUpsertWithoutMapsInput = {
    update: XOR<EncounterConditionValueUpdateWithoutMapsInput, EncounterConditionValueUncheckedUpdateWithoutMapsInput>
    create: XOR<EncounterConditionValueCreateWithoutMapsInput, EncounterConditionValueUncheckedCreateWithoutMapsInput>
    where?: EncounterConditionValueWhereInput
  }

  export type EncounterConditionValueUpdateToOneWithWhereWithoutMapsInput = {
    where?: EncounterConditionValueWhereInput
    data: XOR<EncounterConditionValueUpdateWithoutMapsInput, EncounterConditionValueUncheckedUpdateWithoutMapsInput>
  }

  export type EncounterConditionValueUpdateWithoutMapsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    condition?: EncounterConditionUpdateOneRequiredWithoutValuesNestedInput
  }

  export type EncounterConditionValueUncheckedUpdateWithoutMapsInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounter_condition_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LocationAreaCreateWithoutEncounterRatesInput = {
    id: number
    name: string
    location: LocationCreateNestedOneWithoutAreasInput
    encounters?: EncounterCreateNestedManyWithoutLocation_areaInput
  }

  export type LocationAreaUncheckedCreateWithoutEncounterRatesInput = {
    id: number
    name: string
    location_id: number
    encounters?: EncounterUncheckedCreateNestedManyWithoutLocation_areaInput
  }

  export type LocationAreaCreateOrConnectWithoutEncounterRatesInput = {
    where: LocationAreaWhereUniqueInput
    create: XOR<LocationAreaCreateWithoutEncounterRatesInput, LocationAreaUncheckedCreateWithoutEncounterRatesInput>
  }

  export type EncounterMethodCreateWithoutLocation_area_encounter_ratesInput = {
    id: number
    name: string
    slots?: EncounterSlotCreateNestedManyWithoutMethodInput
  }

  export type EncounterMethodUncheckedCreateWithoutLocation_area_encounter_ratesInput = {
    id: number
    name: string
    slots?: EncounterSlotUncheckedCreateNestedManyWithoutMethodInput
  }

  export type EncounterMethodCreateOrConnectWithoutLocation_area_encounter_ratesInput = {
    where: EncounterMethodWhereUniqueInput
    create: XOR<EncounterMethodCreateWithoutLocation_area_encounter_ratesInput, EncounterMethodUncheckedCreateWithoutLocation_area_encounter_ratesInput>
  }

  export type VersionCreateWithoutEncounterRatesInput = {
    id: number
    name: string
    versionGroup: VersionGroupCreateNestedOneWithoutVersionsInput
    encounters?: EncounterCreateNestedManyWithoutVersionInput
  }

  export type VersionUncheckedCreateWithoutEncounterRatesInput = {
    id: number
    name: string
    version_group_id: number
    encounters?: EncounterUncheckedCreateNestedManyWithoutVersionInput
  }

  export type VersionCreateOrConnectWithoutEncounterRatesInput = {
    where: VersionWhereUniqueInput
    create: XOR<VersionCreateWithoutEncounterRatesInput, VersionUncheckedCreateWithoutEncounterRatesInput>
  }

  export type LocationAreaUpsertWithoutEncounterRatesInput = {
    update: XOR<LocationAreaUpdateWithoutEncounterRatesInput, LocationAreaUncheckedUpdateWithoutEncounterRatesInput>
    create: XOR<LocationAreaCreateWithoutEncounterRatesInput, LocationAreaUncheckedCreateWithoutEncounterRatesInput>
    where?: LocationAreaWhereInput
  }

  export type LocationAreaUpdateToOneWithWhereWithoutEncounterRatesInput = {
    where?: LocationAreaWhereInput
    data: XOR<LocationAreaUpdateWithoutEncounterRatesInput, LocationAreaUncheckedUpdateWithoutEncounterRatesInput>
  }

  export type LocationAreaUpdateWithoutEncounterRatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: LocationUpdateOneRequiredWithoutAreasNestedInput
    encounters?: EncounterUpdateManyWithoutLocation_areaNestedInput
  }

  export type LocationAreaUncheckedUpdateWithoutEncounterRatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location_id?: IntFieldUpdateOperationsInput | number
    encounters?: EncounterUncheckedUpdateManyWithoutLocation_areaNestedInput
  }

  export type EncounterMethodUpsertWithoutLocation_area_encounter_ratesInput = {
    update: XOR<EncounterMethodUpdateWithoutLocation_area_encounter_ratesInput, EncounterMethodUncheckedUpdateWithoutLocation_area_encounter_ratesInput>
    create: XOR<EncounterMethodCreateWithoutLocation_area_encounter_ratesInput, EncounterMethodUncheckedCreateWithoutLocation_area_encounter_ratesInput>
    where?: EncounterMethodWhereInput
  }

  export type EncounterMethodUpdateToOneWithWhereWithoutLocation_area_encounter_ratesInput = {
    where?: EncounterMethodWhereInput
    data: XOR<EncounterMethodUpdateWithoutLocation_area_encounter_ratesInput, EncounterMethodUncheckedUpdateWithoutLocation_area_encounter_ratesInput>
  }

  export type EncounterMethodUpdateWithoutLocation_area_encounter_ratesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slots?: EncounterSlotUpdateManyWithoutMethodNestedInput
  }

  export type EncounterMethodUncheckedUpdateWithoutLocation_area_encounter_ratesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slots?: EncounterSlotUncheckedUpdateManyWithoutMethodNestedInput
  }

  export type VersionUpsertWithoutEncounterRatesInput = {
    update: XOR<VersionUpdateWithoutEncounterRatesInput, VersionUncheckedUpdateWithoutEncounterRatesInput>
    create: XOR<VersionCreateWithoutEncounterRatesInput, VersionUncheckedCreateWithoutEncounterRatesInput>
    where?: VersionWhereInput
  }

  export type VersionUpdateToOneWithWhereWithoutEncounterRatesInput = {
    where?: VersionWhereInput
    data: XOR<VersionUpdateWithoutEncounterRatesInput, VersionUncheckedUpdateWithoutEncounterRatesInput>
  }

  export type VersionUpdateWithoutEncounterRatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    versionGroup?: VersionGroupUpdateOneRequiredWithoutVersionsNestedInput
    encounters?: EncounterUpdateManyWithoutVersionNestedInput
  }

  export type VersionUncheckedUpdateWithoutEncounterRatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    version_group_id?: IntFieldUpdateOperationsInput | number
    encounters?: EncounterUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type MoveCreateWithoutDamage_classInput = {
    id: number
    name: string
    generation_id: number
    pp: number
    accuracy?: number | null
    priority: number
    type: TypeCreateNestedOneWithoutMoveInput
    effect: MoveEffectCreateNestedOneWithoutMovesInput
    pokemon_moves?: PokemonMoveCreateNestedManyWithoutMoveInput
  }

  export type MoveUncheckedCreateWithoutDamage_classInput = {
    id: number
    name: string
    generation_id: number
    type_id: number
    pp: number
    accuracy?: number | null
    priority: number
    move_effect_id: number
    pokemon_moves?: PokemonMoveUncheckedCreateNestedManyWithoutMoveInput
  }

  export type MoveCreateOrConnectWithoutDamage_classInput = {
    where: MoveWhereUniqueInput
    create: XOR<MoveCreateWithoutDamage_classInput, MoveUncheckedCreateWithoutDamage_classInput>
  }

  export type MoveCreateManyDamage_classInputEnvelope = {
    data: MoveCreateManyDamage_classInput | MoveCreateManyDamage_classInput[]
    skipDuplicates?: boolean
  }

  export type MoveUpsertWithWhereUniqueWithoutDamage_classInput = {
    where: MoveWhereUniqueInput
    update: XOR<MoveUpdateWithoutDamage_classInput, MoveUncheckedUpdateWithoutDamage_classInput>
    create: XOR<MoveCreateWithoutDamage_classInput, MoveUncheckedCreateWithoutDamage_classInput>
  }

  export type MoveUpdateWithWhereUniqueWithoutDamage_classInput = {
    where: MoveWhereUniqueInput
    data: XOR<MoveUpdateWithoutDamage_classInput, MoveUncheckedUpdateWithoutDamage_classInput>
  }

  export type MoveUpdateManyWithWhereWithoutDamage_classInput = {
    where: MoveScalarWhereInput
    data: XOR<MoveUpdateManyMutationInput, MoveUncheckedUpdateManyWithoutDamage_classInput>
  }

  export type MoveCreateWithoutEffectInput = {
    id: number
    name: string
    generation_id: number
    pp: number
    accuracy?: number | null
    priority: number
    type: TypeCreateNestedOneWithoutMoveInput
    damage_class: MoveDamageClassCreateNestedOneWithoutMovesInput
    pokemon_moves?: PokemonMoveCreateNestedManyWithoutMoveInput
  }

  export type MoveUncheckedCreateWithoutEffectInput = {
    id: number
    name: string
    generation_id: number
    type_id: number
    pp: number
    accuracy?: number | null
    priority: number
    move_damage_class_id: number
    pokemon_moves?: PokemonMoveUncheckedCreateNestedManyWithoutMoveInput
  }

  export type MoveCreateOrConnectWithoutEffectInput = {
    where: MoveWhereUniqueInput
    create: XOR<MoveCreateWithoutEffectInput, MoveUncheckedCreateWithoutEffectInput>
  }

  export type MoveCreateManyEffectInputEnvelope = {
    data: MoveCreateManyEffectInput | MoveCreateManyEffectInput[]
    skipDuplicates?: boolean
  }

  export type MoveUpsertWithWhereUniqueWithoutEffectInput = {
    where: MoveWhereUniqueInput
    update: XOR<MoveUpdateWithoutEffectInput, MoveUncheckedUpdateWithoutEffectInput>
    create: XOR<MoveCreateWithoutEffectInput, MoveUncheckedCreateWithoutEffectInput>
  }

  export type MoveUpdateWithWhereUniqueWithoutEffectInput = {
    where: MoveWhereUniqueInput
    data: XOR<MoveUpdateWithoutEffectInput, MoveUncheckedUpdateWithoutEffectInput>
  }

  export type MoveUpdateManyWithWhereWithoutEffectInput = {
    where: MoveScalarWhereInput
    data: XOR<MoveUpdateManyMutationInput, MoveUncheckedUpdateManyWithoutEffectInput>
  }

  export type PokemonMoveCreateWithoutMethodInput = {
    id: number
    level: number
    version_group: VersionGroupCreateNestedOneWithoutMovesInput
    move: MoveCreateNestedOneWithoutPokemon_movesInput
    pokemon: PokemonCreateNestedOneWithoutMoveInput
  }

  export type PokemonMoveUncheckedCreateWithoutMethodInput = {
    id: number
    version_group_id: number
    move_id: number
    pokemon_id: number
    level: number
  }

  export type PokemonMoveCreateOrConnectWithoutMethodInput = {
    where: PokemonMoveWhereUniqueInput
    create: XOR<PokemonMoveCreateWithoutMethodInput, PokemonMoveUncheckedCreateWithoutMethodInput>
  }

  export type PokemonMoveCreateManyMethodInputEnvelope = {
    data: PokemonMoveCreateManyMethodInput | PokemonMoveCreateManyMethodInput[]
    skipDuplicates?: boolean
  }

  export type PokemonMoveUpsertWithWhereUniqueWithoutMethodInput = {
    where: PokemonMoveWhereUniqueInput
    update: XOR<PokemonMoveUpdateWithoutMethodInput, PokemonMoveUncheckedUpdateWithoutMethodInput>
    create: XOR<PokemonMoveCreateWithoutMethodInput, PokemonMoveUncheckedCreateWithoutMethodInput>
  }

  export type PokemonMoveUpdateWithWhereUniqueWithoutMethodInput = {
    where: PokemonMoveWhereUniqueInput
    data: XOR<PokemonMoveUpdateWithoutMethodInput, PokemonMoveUncheckedUpdateWithoutMethodInput>
  }

  export type PokemonMoveUpdateManyWithWhereWithoutMethodInput = {
    where: PokemonMoveScalarWhereInput
    data: XOR<PokemonMoveUpdateManyMutationInput, PokemonMoveUncheckedUpdateManyWithoutMethodInput>
  }

  export type TypeCreateWithoutMoveInput = {
    id: number
    name: string
    generation: GenerationCreateNestedOneWithoutTypesInput
    pokemon?: PokemonTypeCreateNestedManyWithoutTypeInput
    attacking?: TypeEffectivenessCreateNestedManyWithoutAttackerInput
    defending?: TypeEffectivenessCreateNestedManyWithoutDefenderInput
  }

  export type TypeUncheckedCreateWithoutMoveInput = {
    id: number
    name: string
    generation_id: number
    pokemon?: PokemonTypeUncheckedCreateNestedManyWithoutTypeInput
    attacking?: TypeEffectivenessUncheckedCreateNestedManyWithoutAttackerInput
    defending?: TypeEffectivenessUncheckedCreateNestedManyWithoutDefenderInput
  }

  export type TypeCreateOrConnectWithoutMoveInput = {
    where: TypeWhereUniqueInput
    create: XOR<TypeCreateWithoutMoveInput, TypeUncheckedCreateWithoutMoveInput>
  }

  export type MoveDamageClassCreateWithoutMovesInput = {
    id: number
    name: string
  }

  export type MoveDamageClassUncheckedCreateWithoutMovesInput = {
    id: number
    name: string
  }

  export type MoveDamageClassCreateOrConnectWithoutMovesInput = {
    where: MoveDamageClassWhereUniqueInput
    create: XOR<MoveDamageClassCreateWithoutMovesInput, MoveDamageClassUncheckedCreateWithoutMovesInput>
  }

  export type MoveEffectCreateWithoutMovesInput = {
    id: number
    description: string
  }

  export type MoveEffectUncheckedCreateWithoutMovesInput = {
    id: number
    description: string
  }

  export type MoveEffectCreateOrConnectWithoutMovesInput = {
    where: MoveEffectWhereUniqueInput
    create: XOR<MoveEffectCreateWithoutMovesInput, MoveEffectUncheckedCreateWithoutMovesInput>
  }

  export type PokemonMoveCreateWithoutMoveInput = {
    id: number
    level: number
    version_group: VersionGroupCreateNestedOneWithoutMovesInput
    method: MoveMethodCreateNestedOneWithoutMovesInput
    pokemon: PokemonCreateNestedOneWithoutMoveInput
  }

  export type PokemonMoveUncheckedCreateWithoutMoveInput = {
    id: number
    version_group_id: number
    move_method_id: number
    pokemon_id: number
    level: number
  }

  export type PokemonMoveCreateOrConnectWithoutMoveInput = {
    where: PokemonMoveWhereUniqueInput
    create: XOR<PokemonMoveCreateWithoutMoveInput, PokemonMoveUncheckedCreateWithoutMoveInput>
  }

  export type PokemonMoveCreateManyMoveInputEnvelope = {
    data: PokemonMoveCreateManyMoveInput | PokemonMoveCreateManyMoveInput[]
    skipDuplicates?: boolean
  }

  export type TypeUpsertWithoutMoveInput = {
    update: XOR<TypeUpdateWithoutMoveInput, TypeUncheckedUpdateWithoutMoveInput>
    create: XOR<TypeCreateWithoutMoveInput, TypeUncheckedCreateWithoutMoveInput>
    where?: TypeWhereInput
  }

  export type TypeUpdateToOneWithWhereWithoutMoveInput = {
    where?: TypeWhereInput
    data: XOR<TypeUpdateWithoutMoveInput, TypeUncheckedUpdateWithoutMoveInput>
  }

  export type TypeUpdateWithoutMoveInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation?: GenerationUpdateOneRequiredWithoutTypesNestedInput
    pokemon?: PokemonTypeUpdateManyWithoutTypeNestedInput
    attacking?: TypeEffectivenessUpdateManyWithoutAttackerNestedInput
    defending?: TypeEffectivenessUpdateManyWithoutDefenderNestedInput
  }

  export type TypeUncheckedUpdateWithoutMoveInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    pokemon?: PokemonTypeUncheckedUpdateManyWithoutTypeNestedInput
    attacking?: TypeEffectivenessUncheckedUpdateManyWithoutAttackerNestedInput
    defending?: TypeEffectivenessUncheckedUpdateManyWithoutDefenderNestedInput
  }

  export type MoveDamageClassUpsertWithoutMovesInput = {
    update: XOR<MoveDamageClassUpdateWithoutMovesInput, MoveDamageClassUncheckedUpdateWithoutMovesInput>
    create: XOR<MoveDamageClassCreateWithoutMovesInput, MoveDamageClassUncheckedCreateWithoutMovesInput>
    where?: MoveDamageClassWhereInput
  }

  export type MoveDamageClassUpdateToOneWithWhereWithoutMovesInput = {
    where?: MoveDamageClassWhereInput
    data: XOR<MoveDamageClassUpdateWithoutMovesInput, MoveDamageClassUncheckedUpdateWithoutMovesInput>
  }

  export type MoveDamageClassUpdateWithoutMovesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MoveDamageClassUncheckedUpdateWithoutMovesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MoveEffectUpsertWithoutMovesInput = {
    update: XOR<MoveEffectUpdateWithoutMovesInput, MoveEffectUncheckedUpdateWithoutMovesInput>
    create: XOR<MoveEffectCreateWithoutMovesInput, MoveEffectUncheckedCreateWithoutMovesInput>
    where?: MoveEffectWhereInput
  }

  export type MoveEffectUpdateToOneWithWhereWithoutMovesInput = {
    where?: MoveEffectWhereInput
    data: XOR<MoveEffectUpdateWithoutMovesInput, MoveEffectUncheckedUpdateWithoutMovesInput>
  }

  export type MoveEffectUpdateWithoutMovesInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type MoveEffectUncheckedUpdateWithoutMovesInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type PokemonMoveUpsertWithWhereUniqueWithoutMoveInput = {
    where: PokemonMoveWhereUniqueInput
    update: XOR<PokemonMoveUpdateWithoutMoveInput, PokemonMoveUncheckedUpdateWithoutMoveInput>
    create: XOR<PokemonMoveCreateWithoutMoveInput, PokemonMoveUncheckedCreateWithoutMoveInput>
  }

  export type PokemonMoveUpdateWithWhereUniqueWithoutMoveInput = {
    where: PokemonMoveWhereUniqueInput
    data: XOR<PokemonMoveUpdateWithoutMoveInput, PokemonMoveUncheckedUpdateWithoutMoveInput>
  }

  export type PokemonMoveUpdateManyWithWhereWithoutMoveInput = {
    where: PokemonMoveScalarWhereInput
    data: XOR<PokemonMoveUpdateManyMutationInput, PokemonMoveUncheckedUpdateManyWithoutMoveInput>
  }

  export type VersionGroupCreateWithoutMovesInput = {
    id: number
    name: string
    generation: GenerationCreateNestedOneWithoutVersionGroupsInput
    versions?: VersionCreateNestedManyWithoutVersionGroupInput
    regions?: VersionGroupRegionCreateNestedManyWithoutVersion_groupInput
    slots?: EncounterSlotCreateNestedManyWithoutVersion_groupInput
    pokedex_version_groups?: PokedexVersionGroupCreateNestedManyWithoutVersion_groupInput
  }

  export type VersionGroupUncheckedCreateWithoutMovesInput = {
    id: number
    name: string
    generation_id: number
    versions?: VersionUncheckedCreateNestedManyWithoutVersionGroupInput
    regions?: VersionGroupRegionUncheckedCreateNestedManyWithoutVersion_groupInput
    slots?: EncounterSlotUncheckedCreateNestedManyWithoutVersion_groupInput
    pokedex_version_groups?: PokedexVersionGroupUncheckedCreateNestedManyWithoutVersion_groupInput
  }

  export type VersionGroupCreateOrConnectWithoutMovesInput = {
    where: VersionGroupWhereUniqueInput
    create: XOR<VersionGroupCreateWithoutMovesInput, VersionGroupUncheckedCreateWithoutMovesInput>
  }

  export type MoveMethodCreateWithoutMovesInput = {
    id: number
    name: string
  }

  export type MoveMethodUncheckedCreateWithoutMovesInput = {
    id: number
    name: string
  }

  export type MoveMethodCreateOrConnectWithoutMovesInput = {
    where: MoveMethodWhereUniqueInput
    create: XOR<MoveMethodCreateWithoutMovesInput, MoveMethodUncheckedCreateWithoutMovesInput>
  }

  export type MoveCreateWithoutPokemon_movesInput = {
    id: number
    name: string
    generation_id: number
    pp: number
    accuracy?: number | null
    priority: number
    type: TypeCreateNestedOneWithoutMoveInput
    damage_class: MoveDamageClassCreateNestedOneWithoutMovesInput
    effect: MoveEffectCreateNestedOneWithoutMovesInput
  }

  export type MoveUncheckedCreateWithoutPokemon_movesInput = {
    id: number
    name: string
    generation_id: number
    type_id: number
    pp: number
    accuracy?: number | null
    priority: number
    move_damage_class_id: number
    move_effect_id: number
  }

  export type MoveCreateOrConnectWithoutPokemon_movesInput = {
    where: MoveWhereUniqueInput
    create: XOR<MoveCreateWithoutPokemon_movesInput, MoveUncheckedCreateWithoutPokemon_movesInput>
  }

  export type PokemonCreateWithoutMoveInput = {
    id: number
    name: string
    abilities?: PokemonAbilityCreateNestedManyWithoutPokemonInput
    natures?: PokemonNatureCreateNestedManyWithoutPokemonInput
    stats?: PokemonStatCreateNestedManyWithoutPokemonInput
    types?: PokemonTypeCreateNestedManyWithoutPokemonInput
    egg_groups?: PokemonEggGroupCreateNestedManyWithoutPokemonInput
    encounters?: EncounterCreateNestedManyWithoutPokemonInput
    dex_numbers?: PokemonDexNumberCreateNestedManyWithoutPokemonInput
  }

  export type PokemonUncheckedCreateWithoutMoveInput = {
    id: number
    name: string
    abilities?: PokemonAbilityUncheckedCreateNestedManyWithoutPokemonInput
    natures?: PokemonNatureUncheckedCreateNestedManyWithoutPokemonInput
    stats?: PokemonStatUncheckedCreateNestedManyWithoutPokemonInput
    types?: PokemonTypeUncheckedCreateNestedManyWithoutPokemonInput
    egg_groups?: PokemonEggGroupUncheckedCreateNestedManyWithoutPokemonInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutPokemonInput
    dex_numbers?: PokemonDexNumberUncheckedCreateNestedManyWithoutPokemonInput
  }

  export type PokemonCreateOrConnectWithoutMoveInput = {
    where: PokemonWhereUniqueInput
    create: XOR<PokemonCreateWithoutMoveInput, PokemonUncheckedCreateWithoutMoveInput>
  }

  export type VersionGroupUpsertWithoutMovesInput = {
    update: XOR<VersionGroupUpdateWithoutMovesInput, VersionGroupUncheckedUpdateWithoutMovesInput>
    create: XOR<VersionGroupCreateWithoutMovesInput, VersionGroupUncheckedCreateWithoutMovesInput>
    where?: VersionGroupWhereInput
  }

  export type VersionGroupUpdateToOneWithWhereWithoutMovesInput = {
    where?: VersionGroupWhereInput
    data: XOR<VersionGroupUpdateWithoutMovesInput, VersionGroupUncheckedUpdateWithoutMovesInput>
  }

  export type VersionGroupUpdateWithoutMovesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation?: GenerationUpdateOneRequiredWithoutVersionGroupsNestedInput
    versions?: VersionUpdateManyWithoutVersionGroupNestedInput
    regions?: VersionGroupRegionUpdateManyWithoutVersion_groupNestedInput
    slots?: EncounterSlotUpdateManyWithoutVersion_groupNestedInput
    pokedex_version_groups?: PokedexVersionGroupUpdateManyWithoutVersion_groupNestedInput
  }

  export type VersionGroupUncheckedUpdateWithoutMovesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    versions?: VersionUncheckedUpdateManyWithoutVersionGroupNestedInput
    regions?: VersionGroupRegionUncheckedUpdateManyWithoutVersion_groupNestedInput
    slots?: EncounterSlotUncheckedUpdateManyWithoutVersion_groupNestedInput
    pokedex_version_groups?: PokedexVersionGroupUncheckedUpdateManyWithoutVersion_groupNestedInput
  }

  export type MoveMethodUpsertWithoutMovesInput = {
    update: XOR<MoveMethodUpdateWithoutMovesInput, MoveMethodUncheckedUpdateWithoutMovesInput>
    create: XOR<MoveMethodCreateWithoutMovesInput, MoveMethodUncheckedCreateWithoutMovesInput>
    where?: MoveMethodWhereInput
  }

  export type MoveMethodUpdateToOneWithWhereWithoutMovesInput = {
    where?: MoveMethodWhereInput
    data: XOR<MoveMethodUpdateWithoutMovesInput, MoveMethodUncheckedUpdateWithoutMovesInput>
  }

  export type MoveMethodUpdateWithoutMovesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MoveMethodUncheckedUpdateWithoutMovesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MoveUpsertWithoutPokemon_movesInput = {
    update: XOR<MoveUpdateWithoutPokemon_movesInput, MoveUncheckedUpdateWithoutPokemon_movesInput>
    create: XOR<MoveCreateWithoutPokemon_movesInput, MoveUncheckedCreateWithoutPokemon_movesInput>
    where?: MoveWhereInput
  }

  export type MoveUpdateToOneWithWhereWithoutPokemon_movesInput = {
    where?: MoveWhereInput
    data: XOR<MoveUpdateWithoutPokemon_movesInput, MoveUncheckedUpdateWithoutPokemon_movesInput>
  }

  export type MoveUpdateWithoutPokemon_movesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    accuracy?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    type?: TypeUpdateOneRequiredWithoutMoveNestedInput
    damage_class?: MoveDamageClassUpdateOneRequiredWithoutMovesNestedInput
    effect?: MoveEffectUpdateOneRequiredWithoutMovesNestedInput
  }

  export type MoveUncheckedUpdateWithoutPokemon_movesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    accuracy?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    move_damage_class_id?: IntFieldUpdateOperationsInput | number
    move_effect_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonUpsertWithoutMoveInput = {
    update: XOR<PokemonUpdateWithoutMoveInput, PokemonUncheckedUpdateWithoutMoveInput>
    create: XOR<PokemonCreateWithoutMoveInput, PokemonUncheckedCreateWithoutMoveInput>
    where?: PokemonWhereInput
  }

  export type PokemonUpdateToOneWithWhereWithoutMoveInput = {
    where?: PokemonWhereInput
    data: XOR<PokemonUpdateWithoutMoveInput, PokemonUncheckedUpdateWithoutMoveInput>
  }

  export type PokemonUpdateWithoutMoveInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abilities?: PokemonAbilityUpdateManyWithoutPokemonNestedInput
    natures?: PokemonNatureUpdateManyWithoutPokemonNestedInput
    stats?: PokemonStatUpdateManyWithoutPokemonNestedInput
    types?: PokemonTypeUpdateManyWithoutPokemonNestedInput
    egg_groups?: PokemonEggGroupUpdateManyWithoutPokemonNestedInput
    encounters?: EncounterUpdateManyWithoutPokemonNestedInput
    dex_numbers?: PokemonDexNumberUpdateManyWithoutPokemonNestedInput
  }

  export type PokemonUncheckedUpdateWithoutMoveInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abilities?: PokemonAbilityUncheckedUpdateManyWithoutPokemonNestedInput
    natures?: PokemonNatureUncheckedUpdateManyWithoutPokemonNestedInput
    stats?: PokemonStatUncheckedUpdateManyWithoutPokemonNestedInput
    types?: PokemonTypeUncheckedUpdateManyWithoutPokemonNestedInput
    egg_groups?: PokemonEggGroupUncheckedUpdateManyWithoutPokemonNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutPokemonNestedInput
    dex_numbers?: PokemonDexNumberUncheckedUpdateManyWithoutPokemonNestedInput
  }

  export type RegionCreateWithoutPokedexInput = {
    id: number
    name: string
    locations?: LocationCreateNestedManyWithoutRegionInput
    version_groups?: VersionGroupRegionCreateNestedManyWithoutRegionInput
    generations?: GenerationCreateNestedOneWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutPokedexInput = {
    id: number
    name: string
    locations?: LocationUncheckedCreateNestedManyWithoutRegionInput
    version_groups?: VersionGroupRegionUncheckedCreateNestedManyWithoutRegionInput
    generations?: GenerationUncheckedCreateNestedOneWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutPokedexInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutPokedexInput, RegionUncheckedCreateWithoutPokedexInput>
  }

  export type PokedexVersionGroupCreateWithoutPokedexInput = {
    id: number
    version_group: VersionGroupCreateNestedOneWithoutPokedex_version_groupsInput
  }

  export type PokedexVersionGroupUncheckedCreateWithoutPokedexInput = {
    id: number
    version_group_id: number
  }

  export type PokedexVersionGroupCreateOrConnectWithoutPokedexInput = {
    where: PokedexVersionGroupWhereUniqueInput
    create: XOR<PokedexVersionGroupCreateWithoutPokedexInput, PokedexVersionGroupUncheckedCreateWithoutPokedexInput>
  }

  export type PokedexVersionGroupCreateManyPokedexInputEnvelope = {
    data: PokedexVersionGroupCreateManyPokedexInput | PokedexVersionGroupCreateManyPokedexInput[]
    skipDuplicates?: boolean
  }

  export type PokemonDexNumberCreateWithoutPokedexInput = {
    id: number
    pokedex_number: number
    pokemon: PokemonCreateNestedOneWithoutDex_numbersInput
  }

  export type PokemonDexNumberUncheckedCreateWithoutPokedexInput = {
    id: number
    pokemon_id: number
    pokedex_number: number
  }

  export type PokemonDexNumberCreateOrConnectWithoutPokedexInput = {
    where: PokemonDexNumberWhereUniqueInput
    create: XOR<PokemonDexNumberCreateWithoutPokedexInput, PokemonDexNumberUncheckedCreateWithoutPokedexInput>
  }

  export type PokemonDexNumberCreateManyPokedexInputEnvelope = {
    data: PokemonDexNumberCreateManyPokedexInput | PokemonDexNumberCreateManyPokedexInput[]
    skipDuplicates?: boolean
  }

  export type RegionUpsertWithoutPokedexInput = {
    update: XOR<RegionUpdateWithoutPokedexInput, RegionUncheckedUpdateWithoutPokedexInput>
    create: XOR<RegionCreateWithoutPokedexInput, RegionUncheckedCreateWithoutPokedexInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutPokedexInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutPokedexInput, RegionUncheckedUpdateWithoutPokedexInput>
  }

  export type RegionUpdateWithoutPokedexInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: LocationUpdateManyWithoutRegionNestedInput
    version_groups?: VersionGroupRegionUpdateManyWithoutRegionNestedInput
    generations?: GenerationUpdateOneWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutPokedexInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    locations?: LocationUncheckedUpdateManyWithoutRegionNestedInput
    version_groups?: VersionGroupRegionUncheckedUpdateManyWithoutRegionNestedInput
    generations?: GenerationUncheckedUpdateOneWithoutRegionNestedInput
  }

  export type PokedexVersionGroupUpsertWithWhereUniqueWithoutPokedexInput = {
    where: PokedexVersionGroupWhereUniqueInput
    update: XOR<PokedexVersionGroupUpdateWithoutPokedexInput, PokedexVersionGroupUncheckedUpdateWithoutPokedexInput>
    create: XOR<PokedexVersionGroupCreateWithoutPokedexInput, PokedexVersionGroupUncheckedCreateWithoutPokedexInput>
  }

  export type PokedexVersionGroupUpdateWithWhereUniqueWithoutPokedexInput = {
    where: PokedexVersionGroupWhereUniqueInput
    data: XOR<PokedexVersionGroupUpdateWithoutPokedexInput, PokedexVersionGroupUncheckedUpdateWithoutPokedexInput>
  }

  export type PokedexVersionGroupUpdateManyWithWhereWithoutPokedexInput = {
    where: PokedexVersionGroupScalarWhereInput
    data: XOR<PokedexVersionGroupUpdateManyMutationInput, PokedexVersionGroupUncheckedUpdateManyWithoutPokedexInput>
  }

  export type PokemonDexNumberUpsertWithWhereUniqueWithoutPokedexInput = {
    where: PokemonDexNumberWhereUniqueInput
    update: XOR<PokemonDexNumberUpdateWithoutPokedexInput, PokemonDexNumberUncheckedUpdateWithoutPokedexInput>
    create: XOR<PokemonDexNumberCreateWithoutPokedexInput, PokemonDexNumberUncheckedCreateWithoutPokedexInput>
  }

  export type PokemonDexNumberUpdateWithWhereUniqueWithoutPokedexInput = {
    where: PokemonDexNumberWhereUniqueInput
    data: XOR<PokemonDexNumberUpdateWithoutPokedexInput, PokemonDexNumberUncheckedUpdateWithoutPokedexInput>
  }

  export type PokemonDexNumberUpdateManyWithWhereWithoutPokedexInput = {
    where: PokemonDexNumberScalarWhereInput
    data: XOR<PokemonDexNumberUpdateManyMutationInput, PokemonDexNumberUncheckedUpdateManyWithoutPokedexInput>
  }

  export type VersionGroupCreateWithoutPokedex_version_groupsInput = {
    id: number
    name: string
    generation: GenerationCreateNestedOneWithoutVersionGroupsInput
    versions?: VersionCreateNestedManyWithoutVersionGroupInput
    regions?: VersionGroupRegionCreateNestedManyWithoutVersion_groupInput
    slots?: EncounterSlotCreateNestedManyWithoutVersion_groupInput
    moves?: PokemonMoveCreateNestedManyWithoutVersion_groupInput
  }

  export type VersionGroupUncheckedCreateWithoutPokedex_version_groupsInput = {
    id: number
    name: string
    generation_id: number
    versions?: VersionUncheckedCreateNestedManyWithoutVersionGroupInput
    regions?: VersionGroupRegionUncheckedCreateNestedManyWithoutVersion_groupInput
    slots?: EncounterSlotUncheckedCreateNestedManyWithoutVersion_groupInput
    moves?: PokemonMoveUncheckedCreateNestedManyWithoutVersion_groupInput
  }

  export type VersionGroupCreateOrConnectWithoutPokedex_version_groupsInput = {
    where: VersionGroupWhereUniqueInput
    create: XOR<VersionGroupCreateWithoutPokedex_version_groupsInput, VersionGroupUncheckedCreateWithoutPokedex_version_groupsInput>
  }

  export type PokedexCreateWithoutPokedex_version_groupsInput = {
    id: number
    name: string
    region: RegionCreateNestedOneWithoutPokedexInput
    pokemon_dex_numbers?: PokemonDexNumberCreateNestedManyWithoutPokedexInput
  }

  export type PokedexUncheckedCreateWithoutPokedex_version_groupsInput = {
    id: number
    name: string
    region_id: number
    pokemon_dex_numbers?: PokemonDexNumberUncheckedCreateNestedManyWithoutPokedexInput
  }

  export type PokedexCreateOrConnectWithoutPokedex_version_groupsInput = {
    where: PokedexWhereUniqueInput
    create: XOR<PokedexCreateWithoutPokedex_version_groupsInput, PokedexUncheckedCreateWithoutPokedex_version_groupsInput>
  }

  export type VersionGroupUpsertWithoutPokedex_version_groupsInput = {
    update: XOR<VersionGroupUpdateWithoutPokedex_version_groupsInput, VersionGroupUncheckedUpdateWithoutPokedex_version_groupsInput>
    create: XOR<VersionGroupCreateWithoutPokedex_version_groupsInput, VersionGroupUncheckedCreateWithoutPokedex_version_groupsInput>
    where?: VersionGroupWhereInput
  }

  export type VersionGroupUpdateToOneWithWhereWithoutPokedex_version_groupsInput = {
    where?: VersionGroupWhereInput
    data: XOR<VersionGroupUpdateWithoutPokedex_version_groupsInput, VersionGroupUncheckedUpdateWithoutPokedex_version_groupsInput>
  }

  export type VersionGroupUpdateWithoutPokedex_version_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation?: GenerationUpdateOneRequiredWithoutVersionGroupsNestedInput
    versions?: VersionUpdateManyWithoutVersionGroupNestedInput
    regions?: VersionGroupRegionUpdateManyWithoutVersion_groupNestedInput
    slots?: EncounterSlotUpdateManyWithoutVersion_groupNestedInput
    moves?: PokemonMoveUpdateManyWithoutVersion_groupNestedInput
  }

  export type VersionGroupUncheckedUpdateWithoutPokedex_version_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    versions?: VersionUncheckedUpdateManyWithoutVersionGroupNestedInput
    regions?: VersionGroupRegionUncheckedUpdateManyWithoutVersion_groupNestedInput
    slots?: EncounterSlotUncheckedUpdateManyWithoutVersion_groupNestedInput
    moves?: PokemonMoveUncheckedUpdateManyWithoutVersion_groupNestedInput
  }

  export type PokedexUpsertWithoutPokedex_version_groupsInput = {
    update: XOR<PokedexUpdateWithoutPokedex_version_groupsInput, PokedexUncheckedUpdateWithoutPokedex_version_groupsInput>
    create: XOR<PokedexCreateWithoutPokedex_version_groupsInput, PokedexUncheckedCreateWithoutPokedex_version_groupsInput>
    where?: PokedexWhereInput
  }

  export type PokedexUpdateToOneWithWhereWithoutPokedex_version_groupsInput = {
    where?: PokedexWhereInput
    data: XOR<PokedexUpdateWithoutPokedex_version_groupsInput, PokedexUncheckedUpdateWithoutPokedex_version_groupsInput>
  }

  export type PokedexUpdateWithoutPokedex_version_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutPokedexNestedInput
    pokemon_dex_numbers?: PokemonDexNumberUpdateManyWithoutPokedexNestedInput
  }

  export type PokedexUncheckedUpdateWithoutPokedex_version_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
    pokemon_dex_numbers?: PokemonDexNumberUncheckedUpdateManyWithoutPokedexNestedInput
  }

  export type PokemonCreateWithoutDex_numbersInput = {
    id: number
    name: string
    abilities?: PokemonAbilityCreateNestedManyWithoutPokemonInput
    natures?: PokemonNatureCreateNestedManyWithoutPokemonInput
    stats?: PokemonStatCreateNestedManyWithoutPokemonInput
    types?: PokemonTypeCreateNestedManyWithoutPokemonInput
    egg_groups?: PokemonEggGroupCreateNestedManyWithoutPokemonInput
    encounters?: EncounterCreateNestedManyWithoutPokemonInput
    move?: PokemonMoveCreateNestedManyWithoutPokemonInput
  }

  export type PokemonUncheckedCreateWithoutDex_numbersInput = {
    id: number
    name: string
    abilities?: PokemonAbilityUncheckedCreateNestedManyWithoutPokemonInput
    natures?: PokemonNatureUncheckedCreateNestedManyWithoutPokemonInput
    stats?: PokemonStatUncheckedCreateNestedManyWithoutPokemonInput
    types?: PokemonTypeUncheckedCreateNestedManyWithoutPokemonInput
    egg_groups?: PokemonEggGroupUncheckedCreateNestedManyWithoutPokemonInput
    encounters?: EncounterUncheckedCreateNestedManyWithoutPokemonInput
    move?: PokemonMoveUncheckedCreateNestedManyWithoutPokemonInput
  }

  export type PokemonCreateOrConnectWithoutDex_numbersInput = {
    where: PokemonWhereUniqueInput
    create: XOR<PokemonCreateWithoutDex_numbersInput, PokemonUncheckedCreateWithoutDex_numbersInput>
  }

  export type PokedexCreateWithoutPokemon_dex_numbersInput = {
    id: number
    name: string
    region: RegionCreateNestedOneWithoutPokedexInput
    pokedex_version_groups?: PokedexVersionGroupCreateNestedManyWithoutPokedexInput
  }

  export type PokedexUncheckedCreateWithoutPokemon_dex_numbersInput = {
    id: number
    name: string
    region_id: number
    pokedex_version_groups?: PokedexVersionGroupUncheckedCreateNestedManyWithoutPokedexInput
  }

  export type PokedexCreateOrConnectWithoutPokemon_dex_numbersInput = {
    where: PokedexWhereUniqueInput
    create: XOR<PokedexCreateWithoutPokemon_dex_numbersInput, PokedexUncheckedCreateWithoutPokemon_dex_numbersInput>
  }

  export type PokemonUpsertWithoutDex_numbersInput = {
    update: XOR<PokemonUpdateWithoutDex_numbersInput, PokemonUncheckedUpdateWithoutDex_numbersInput>
    create: XOR<PokemonCreateWithoutDex_numbersInput, PokemonUncheckedCreateWithoutDex_numbersInput>
    where?: PokemonWhereInput
  }

  export type PokemonUpdateToOneWithWhereWithoutDex_numbersInput = {
    where?: PokemonWhereInput
    data: XOR<PokemonUpdateWithoutDex_numbersInput, PokemonUncheckedUpdateWithoutDex_numbersInput>
  }

  export type PokemonUpdateWithoutDex_numbersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abilities?: PokemonAbilityUpdateManyWithoutPokemonNestedInput
    natures?: PokemonNatureUpdateManyWithoutPokemonNestedInput
    stats?: PokemonStatUpdateManyWithoutPokemonNestedInput
    types?: PokemonTypeUpdateManyWithoutPokemonNestedInput
    egg_groups?: PokemonEggGroupUpdateManyWithoutPokemonNestedInput
    encounters?: EncounterUpdateManyWithoutPokemonNestedInput
    move?: PokemonMoveUpdateManyWithoutPokemonNestedInput
  }

  export type PokemonUncheckedUpdateWithoutDex_numbersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abilities?: PokemonAbilityUncheckedUpdateManyWithoutPokemonNestedInput
    natures?: PokemonNatureUncheckedUpdateManyWithoutPokemonNestedInput
    stats?: PokemonStatUncheckedUpdateManyWithoutPokemonNestedInput
    types?: PokemonTypeUncheckedUpdateManyWithoutPokemonNestedInput
    egg_groups?: PokemonEggGroupUncheckedUpdateManyWithoutPokemonNestedInput
    encounters?: EncounterUncheckedUpdateManyWithoutPokemonNestedInput
    move?: PokemonMoveUncheckedUpdateManyWithoutPokemonNestedInput
  }

  export type PokedexUpsertWithoutPokemon_dex_numbersInput = {
    update: XOR<PokedexUpdateWithoutPokemon_dex_numbersInput, PokedexUncheckedUpdateWithoutPokemon_dex_numbersInput>
    create: XOR<PokedexCreateWithoutPokemon_dex_numbersInput, PokedexUncheckedCreateWithoutPokemon_dex_numbersInput>
    where?: PokedexWhereInput
  }

  export type PokedexUpdateToOneWithWhereWithoutPokemon_dex_numbersInput = {
    where?: PokedexWhereInput
    data: XOR<PokedexUpdateWithoutPokemon_dex_numbersInput, PokedexUncheckedUpdateWithoutPokemon_dex_numbersInput>
  }

  export type PokedexUpdateWithoutPokemon_dex_numbersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    region?: RegionUpdateOneRequiredWithoutPokedexNestedInput
    pokedex_version_groups?: PokedexVersionGroupUpdateManyWithoutPokedexNestedInput
  }

  export type PokedexUncheckedUpdateWithoutPokemon_dex_numbersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
    pokedex_version_groups?: PokedexVersionGroupUncheckedUpdateManyWithoutPokedexNestedInput
  }

  export type PokemonAbilityCreateManyPokemonInput = {
    id: number
    ability_id: number
    is_hidden: boolean
  }

  export type PokemonNatureCreateManyPokemonInput = {
    id: number
    nature_id: number
  }

  export type PokemonStatCreateManyPokemonInput = {
    id: number
    stat_id: number
    base_stat: number
  }

  export type PokemonTypeCreateManyPokemonInput = {
    id: number
    type_id: number
  }

  export type PokemonEggGroupCreateManyPokemonInput = {
    id: number
    egg_group_id: number
  }

  export type EncounterCreateManyPokemonInput = {
    id: number
    version_id: number
    location_area_id: number
    encounter_slot_id: number
    min_level: number
    max_level: number
  }

  export type PokemonDexNumberCreateManyPokemonInput = {
    id: number
    pokedex_id: number
    pokedex_number: number
  }

  export type PokemonMoveCreateManyPokemonInput = {
    id: number
    version_group_id: number
    move_method_id: number
    move_id: number
    level: number
  }

  export type PokemonAbilityUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    is_hidden?: BoolFieldUpdateOperationsInput | boolean
    ability?: AbilityUpdateOneRequiredWithoutPokemonNestedInput
  }

  export type PokemonAbilityUncheckedUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    ability_id?: IntFieldUpdateOperationsInput | number
    is_hidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PokemonAbilityUncheckedUpdateManyWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    ability_id?: IntFieldUpdateOperationsInput | number
    is_hidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PokemonNatureUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    nature?: NatureUpdateOneRequiredWithoutPokemonNestedInput
  }

  export type PokemonNatureUncheckedUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    nature_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonNatureUncheckedUpdateManyWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    nature_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonStatUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    base_stat?: IntFieldUpdateOperationsInput | number
    stat?: StatUpdateOneRequiredWithoutPokemon_statsNestedInput
  }

  export type PokemonStatUncheckedUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    stat_id?: IntFieldUpdateOperationsInput | number
    base_stat?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonStatUncheckedUpdateManyWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    stat_id?: IntFieldUpdateOperationsInput | number
    base_stat?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonTypeUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: TypeUpdateOneRequiredWithoutPokemonNestedInput
  }

  export type PokemonTypeUncheckedUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonTypeUncheckedUpdateManyWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonEggGroupUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    egg_group?: EggGroupUpdateOneRequiredWithoutPokemon_egg_groupNestedInput
  }

  export type PokemonEggGroupUncheckedUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    egg_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonEggGroupUncheckedUpdateManyWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    egg_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    min_level?: IntFieldUpdateOperationsInput | number
    max_level?: IntFieldUpdateOperationsInput | number
    version?: VersionUpdateOneRequiredWithoutEncountersNestedInput
    location_area?: LocationAreaUpdateOneRequiredWithoutEncountersNestedInput
    slot?: EncounterSlotUpdateOneRequiredWithoutEncountersNestedInput
    conditions?: EncounterConditionValueMapUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_id?: IntFieldUpdateOperationsInput | number
    location_area_id?: IntFieldUpdateOperationsInput | number
    encounter_slot_id?: IntFieldUpdateOperationsInput | number
    min_level?: IntFieldUpdateOperationsInput | number
    max_level?: IntFieldUpdateOperationsInput | number
    conditions?: EncounterConditionValueMapUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_id?: IntFieldUpdateOperationsInput | number
    location_area_id?: IntFieldUpdateOperationsInput | number
    encounter_slot_id?: IntFieldUpdateOperationsInput | number
    min_level?: IntFieldUpdateOperationsInput | number
    max_level?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonDexNumberUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokedex_number?: IntFieldUpdateOperationsInput | number
    pokedex?: PokedexUpdateOneRequiredWithoutPokemon_dex_numbersNestedInput
  }

  export type PokemonDexNumberUncheckedUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokedex_id?: IntFieldUpdateOperationsInput | number
    pokedex_number?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonDexNumberUncheckedUpdateManyWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokedex_id?: IntFieldUpdateOperationsInput | number
    pokedex_number?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonMoveUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    version_group?: VersionGroupUpdateOneRequiredWithoutMovesNestedInput
    method?: MoveMethodUpdateOneRequiredWithoutMovesNestedInput
    move?: MoveUpdateOneRequiredWithoutPokemon_movesNestedInput
  }

  export type PokemonMoveUncheckedUpdateWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
    move_method_id?: IntFieldUpdateOperationsInput | number
    move_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonMoveUncheckedUpdateManyWithoutPokemonInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
    move_method_id?: IntFieldUpdateOperationsInput | number
    move_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonAbilityCreateManyAbilityInput = {
    id: number
    pokemon_id: number
    is_hidden: boolean
  }

  export type PokemonAbilityUpdateWithoutAbilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    is_hidden?: BoolFieldUpdateOperationsInput | boolean
    pokemon?: PokemonUpdateOneRequiredWithoutAbilitiesNestedInput
  }

  export type PokemonAbilityUncheckedUpdateWithoutAbilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    is_hidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PokemonAbilityUncheckedUpdateManyWithoutAbilityInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    is_hidden?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PokemonNatureCreateManyNatureInput = {
    id: number
    pokemon_id: number
  }

  export type PokemonNatureUpdateWithoutNatureInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon?: PokemonUpdateOneRequiredWithoutNaturesNestedInput
  }

  export type PokemonNatureUncheckedUpdateWithoutNatureInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonNatureUncheckedUpdateManyWithoutNatureInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
  }

  export type NatureCreateManyStat_increasedInput = {
    id: number
    name: string
    decreased_stat_id: number
  }

  export type NatureCreateManyStat_decreasedInput = {
    id: number
    name: string
    increased_stat_id: number
  }

  export type PokemonStatCreateManyStatInput = {
    id: number
    pokemon_id: number
    base_stat: number
  }

  export type NatureUpdateWithoutStat_increasedInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    stat_decreased?: StatUpdateOneRequiredWithoutNatures_decreaseNestedInput
    pokemon?: PokemonNatureUpdateManyWithoutNatureNestedInput
  }

  export type NatureUncheckedUpdateWithoutStat_increasedInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    decreased_stat_id?: IntFieldUpdateOperationsInput | number
    pokemon?: PokemonNatureUncheckedUpdateManyWithoutNatureNestedInput
  }

  export type NatureUncheckedUpdateManyWithoutStat_increasedInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    decreased_stat_id?: IntFieldUpdateOperationsInput | number
  }

  export type NatureUpdateWithoutStat_decreasedInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    stat_increased?: StatUpdateOneRequiredWithoutNatures_increaseNestedInput
    pokemon?: PokemonNatureUpdateManyWithoutNatureNestedInput
  }

  export type NatureUncheckedUpdateWithoutStat_decreasedInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    increased_stat_id?: IntFieldUpdateOperationsInput | number
    pokemon?: PokemonNatureUncheckedUpdateManyWithoutNatureNestedInput
  }

  export type NatureUncheckedUpdateManyWithoutStat_decreasedInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    increased_stat_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonStatUpdateWithoutStatInput = {
    id?: IntFieldUpdateOperationsInput | number
    base_stat?: IntFieldUpdateOperationsInput | number
    pokemon?: PokemonUpdateOneRequiredWithoutStatsNestedInput
  }

  export type PokemonStatUncheckedUpdateWithoutStatInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    base_stat?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonStatUncheckedUpdateManyWithoutStatInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    base_stat?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonTypeCreateManyTypeInput = {
    id: number
    pokemon_id: number
  }

  export type TypeEffectivenessCreateManyAttackerInput = {
    id: number
    target_type_id: number
    damage_factor: number
  }

  export type TypeEffectivenessCreateManyDefenderInput = {
    id: number
    type_id: number
    damage_factor: number
  }

  export type MoveCreateManyTypeInput = {
    id: number
    name: string
    generation_id: number
    pp: number
    accuracy?: number | null
    priority: number
    move_damage_class_id: number
    move_effect_id: number
  }

  export type PokemonTypeUpdateWithoutTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon?: PokemonUpdateOneRequiredWithoutTypesNestedInput
  }

  export type PokemonTypeUncheckedUpdateWithoutTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonTypeUncheckedUpdateManyWithoutTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
  }

  export type TypeEffectivenessUpdateWithoutAttackerInput = {
    id?: IntFieldUpdateOperationsInput | number
    damage_factor?: IntFieldUpdateOperationsInput | number
    defender?: TypeUpdateOneRequiredWithoutDefendingNestedInput
  }

  export type TypeEffectivenessUncheckedUpdateWithoutAttackerInput = {
    id?: IntFieldUpdateOperationsInput | number
    target_type_id?: IntFieldUpdateOperationsInput | number
    damage_factor?: IntFieldUpdateOperationsInput | number
  }

  export type TypeEffectivenessUncheckedUpdateManyWithoutAttackerInput = {
    id?: IntFieldUpdateOperationsInput | number
    target_type_id?: IntFieldUpdateOperationsInput | number
    damage_factor?: IntFieldUpdateOperationsInput | number
  }

  export type TypeEffectivenessUpdateWithoutDefenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    damage_factor?: IntFieldUpdateOperationsInput | number
    attacker?: TypeUpdateOneRequiredWithoutAttackingNestedInput
  }

  export type TypeEffectivenessUncheckedUpdateWithoutDefenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    damage_factor?: IntFieldUpdateOperationsInput | number
  }

  export type TypeEffectivenessUncheckedUpdateManyWithoutDefenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    damage_factor?: IntFieldUpdateOperationsInput | number
  }

  export type MoveUpdateWithoutTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    accuracy?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    damage_class?: MoveDamageClassUpdateOneRequiredWithoutMovesNestedInput
    effect?: MoveEffectUpdateOneRequiredWithoutMovesNestedInput
    pokemon_moves?: PokemonMoveUpdateManyWithoutMoveNestedInput
  }

  export type MoveUncheckedUpdateWithoutTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    accuracy?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    move_damage_class_id?: IntFieldUpdateOperationsInput | number
    move_effect_id?: IntFieldUpdateOperationsInput | number
    pokemon_moves?: PokemonMoveUncheckedUpdateManyWithoutMoveNestedInput
  }

  export type MoveUncheckedUpdateManyWithoutTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    accuracy?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    move_damage_class_id?: IntFieldUpdateOperationsInput | number
    move_effect_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonEggGroupCreateManyEgg_groupInput = {
    id: number
    pokemon_id: number
  }

  export type PokemonEggGroupUpdateWithoutEgg_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon?: PokemonUpdateOneRequiredWithoutEgg_groupsNestedInput
  }

  export type PokemonEggGroupUncheckedUpdateWithoutEgg_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonEggGroupUncheckedUpdateManyWithoutEgg_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
  }

  export type LocationCreateManyRegionInput = {
    id: number
    name: string
  }

  export type VersionGroupRegionCreateManyRegionInput = {
    id: number
    version_group_id: number
  }

  export type PokedexCreateManyRegionInput = {
    id: number
    name: string
  }

  export type LocationUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    areas?: LocationAreaUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    areas?: LocationAreaUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateManyWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VersionGroupRegionUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group?: VersionGroupUpdateOneRequiredWithoutRegionsNestedInput
  }

  export type VersionGroupRegionUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type VersionGroupRegionUncheckedUpdateManyWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokedexUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    pokedex_version_groups?: PokedexVersionGroupUpdateManyWithoutPokedexNestedInput
    pokemon_dex_numbers?: PokemonDexNumberUpdateManyWithoutPokedexNestedInput
  }

  export type PokedexUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    pokedex_version_groups?: PokedexVersionGroupUncheckedUpdateManyWithoutPokedexNestedInput
    pokemon_dex_numbers?: PokemonDexNumberUncheckedUpdateManyWithoutPokedexNestedInput
  }

  export type PokedexUncheckedUpdateManyWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TypeCreateManyGenerationInput = {
    id: number
    name: string
  }

  export type VersionGroupCreateManyGenerationInput = {
    id: number
    name: string
  }

  export type TypeUpdateWithoutGenerationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    pokemon?: PokemonTypeUpdateManyWithoutTypeNestedInput
    attacking?: TypeEffectivenessUpdateManyWithoutAttackerNestedInput
    defending?: TypeEffectivenessUpdateManyWithoutDefenderNestedInput
    move?: MoveUpdateManyWithoutTypeNestedInput
  }

  export type TypeUncheckedUpdateWithoutGenerationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    pokemon?: PokemonTypeUncheckedUpdateManyWithoutTypeNestedInput
    attacking?: TypeEffectivenessUncheckedUpdateManyWithoutAttackerNestedInput
    defending?: TypeEffectivenessUncheckedUpdateManyWithoutDefenderNestedInput
    move?: MoveUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type TypeUncheckedUpdateManyWithoutGenerationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VersionGroupUpdateWithoutGenerationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    versions?: VersionUpdateManyWithoutVersionGroupNestedInput
    regions?: VersionGroupRegionUpdateManyWithoutVersion_groupNestedInput
    slots?: EncounterSlotUpdateManyWithoutVersion_groupNestedInput
    moves?: PokemonMoveUpdateManyWithoutVersion_groupNestedInput
    pokedex_version_groups?: PokedexVersionGroupUpdateManyWithoutVersion_groupNestedInput
  }

  export type VersionGroupUncheckedUpdateWithoutGenerationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    versions?: VersionUncheckedUpdateManyWithoutVersionGroupNestedInput
    regions?: VersionGroupRegionUncheckedUpdateManyWithoutVersion_groupNestedInput
    slots?: EncounterSlotUncheckedUpdateManyWithoutVersion_groupNestedInput
    moves?: PokemonMoveUncheckedUpdateManyWithoutVersion_groupNestedInput
    pokedex_version_groups?: PokedexVersionGroupUncheckedUpdateManyWithoutVersion_groupNestedInput
  }

  export type VersionGroupUncheckedUpdateManyWithoutGenerationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VersionCreateManyVersionGroupInput = {
    id: number
    name: string
  }

  export type VersionGroupRegionCreateManyVersion_groupInput = {
    id: number
    region_id: number
  }

  export type EncounterSlotCreateManyVersion_groupInput = {
    id: number
    encounter_method_id: number
    slot: number
    rarity: number
  }

  export type PokemonMoveCreateManyVersion_groupInput = {
    id: number
    move_method_id: number
    move_id: number
    pokemon_id: number
    level: number
  }

  export type PokedexVersionGroupCreateManyVersion_groupInput = {
    id: number
    pokedex_id: number
  }

  export type VersionUpdateWithoutVersionGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    encounters?: EncounterUpdateManyWithoutVersionNestedInput
    encounterRates?: LocationAreaEncounterRateUpdateManyWithoutVersionNestedInput
  }

  export type VersionUncheckedUpdateWithoutVersionGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    encounters?: EncounterUncheckedUpdateManyWithoutVersionNestedInput
    encounterRates?: LocationAreaEncounterRateUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type VersionUncheckedUpdateManyWithoutVersionGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VersionGroupRegionUpdateWithoutVersion_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    region?: RegionUpdateOneRequiredWithoutVersion_groupsNestedInput
  }

  export type VersionGroupRegionUncheckedUpdateWithoutVersion_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    region_id?: IntFieldUpdateOperationsInput | number
  }

  export type VersionGroupRegionUncheckedUpdateManyWithoutVersion_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    region_id?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterSlotUpdateWithoutVersion_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    slot?: IntFieldUpdateOperationsInput | number
    rarity?: IntFieldUpdateOperationsInput | number
    method?: EncounterMethodUpdateOneRequiredWithoutSlotsNestedInput
    encounters?: EncounterUpdateManyWithoutSlotNestedInput
  }

  export type EncounterSlotUncheckedUpdateWithoutVersion_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounter_method_id?: IntFieldUpdateOperationsInput | number
    slot?: IntFieldUpdateOperationsInput | number
    rarity?: IntFieldUpdateOperationsInput | number
    encounters?: EncounterUncheckedUpdateManyWithoutSlotNestedInput
  }

  export type EncounterSlotUncheckedUpdateManyWithoutVersion_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounter_method_id?: IntFieldUpdateOperationsInput | number
    slot?: IntFieldUpdateOperationsInput | number
    rarity?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonMoveUpdateWithoutVersion_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    method?: MoveMethodUpdateOneRequiredWithoutMovesNestedInput
    move?: MoveUpdateOneRequiredWithoutPokemon_movesNestedInput
    pokemon?: PokemonUpdateOneRequiredWithoutMoveNestedInput
  }

  export type PokemonMoveUncheckedUpdateWithoutVersion_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    move_method_id?: IntFieldUpdateOperationsInput | number
    move_id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonMoveUncheckedUpdateManyWithoutVersion_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    move_method_id?: IntFieldUpdateOperationsInput | number
    move_id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type PokedexVersionGroupUpdateWithoutVersion_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokedex?: PokedexUpdateOneRequiredWithoutPokedex_version_groupsNestedInput
  }

  export type PokedexVersionGroupUncheckedUpdateWithoutVersion_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokedex_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokedexVersionGroupUncheckedUpdateManyWithoutVersion_groupInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokedex_id?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterCreateManyVersionInput = {
    id: number
    pokemon_id: number
    location_area_id: number
    encounter_slot_id: number
    min_level: number
    max_level: number
  }

  export type LocationAreaEncounterRateCreateManyVersionInput = {
    id: number
    location_area_id: number
    encounter_method_id: number
    rate: number
  }

  export type EncounterUpdateWithoutVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    min_level?: IntFieldUpdateOperationsInput | number
    max_level?: IntFieldUpdateOperationsInput | number
    pokemon?: PokemonUpdateOneRequiredWithoutEncountersNestedInput
    location_area?: LocationAreaUpdateOneRequiredWithoutEncountersNestedInput
    slot?: EncounterSlotUpdateOneRequiredWithoutEncountersNestedInput
    conditions?: EncounterConditionValueMapUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    location_area_id?: IntFieldUpdateOperationsInput | number
    encounter_slot_id?: IntFieldUpdateOperationsInput | number
    min_level?: IntFieldUpdateOperationsInput | number
    max_level?: IntFieldUpdateOperationsInput | number
    conditions?: EncounterConditionValueMapUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    location_area_id?: IntFieldUpdateOperationsInput | number
    encounter_slot_id?: IntFieldUpdateOperationsInput | number
    min_level?: IntFieldUpdateOperationsInput | number
    max_level?: IntFieldUpdateOperationsInput | number
  }

  export type LocationAreaEncounterRateUpdateWithoutVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
    location_area?: LocationAreaUpdateOneRequiredWithoutEncounterRatesNestedInput
    encounter_method?: EncounterMethodUpdateOneRequiredWithoutLocation_area_encounter_ratesNestedInput
  }

  export type LocationAreaEncounterRateUncheckedUpdateWithoutVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    location_area_id?: IntFieldUpdateOperationsInput | number
    encounter_method_id?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
  }

  export type LocationAreaEncounterRateUncheckedUpdateManyWithoutVersionInput = {
    id?: IntFieldUpdateOperationsInput | number
    location_area_id?: IntFieldUpdateOperationsInput | number
    encounter_method_id?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
  }

  export type LocationAreaCreateManyLocationInput = {
    id: number
    name: string
  }

  export type LocationAreaUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    encounters?: EncounterUpdateManyWithoutLocation_areaNestedInput
    encounterRates?: LocationAreaEncounterRateUpdateManyWithoutLocation_areaNestedInput
  }

  export type LocationAreaUncheckedUpdateWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    encounters?: EncounterUncheckedUpdateManyWithoutLocation_areaNestedInput
    encounterRates?: LocationAreaEncounterRateUncheckedUpdateManyWithoutLocation_areaNestedInput
  }

  export type LocationAreaUncheckedUpdateManyWithoutLocationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EncounterCreateManyLocation_areaInput = {
    id: number
    version_id: number
    pokemon_id: number
    encounter_slot_id: number
    min_level: number
    max_level: number
  }

  export type LocationAreaEncounterRateCreateManyLocation_areaInput = {
    id: number
    encounter_method_id: number
    version_id: number
    rate: number
  }

  export type EncounterUpdateWithoutLocation_areaInput = {
    id?: IntFieldUpdateOperationsInput | number
    min_level?: IntFieldUpdateOperationsInput | number
    max_level?: IntFieldUpdateOperationsInput | number
    version?: VersionUpdateOneRequiredWithoutEncountersNestedInput
    pokemon?: PokemonUpdateOneRequiredWithoutEncountersNestedInput
    slot?: EncounterSlotUpdateOneRequiredWithoutEncountersNestedInput
    conditions?: EncounterConditionValueMapUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutLocation_areaInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    encounter_slot_id?: IntFieldUpdateOperationsInput | number
    min_level?: IntFieldUpdateOperationsInput | number
    max_level?: IntFieldUpdateOperationsInput | number
    conditions?: EncounterConditionValueMapUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutLocation_areaInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    encounter_slot_id?: IntFieldUpdateOperationsInput | number
    min_level?: IntFieldUpdateOperationsInput | number
    max_level?: IntFieldUpdateOperationsInput | number
  }

  export type LocationAreaEncounterRateUpdateWithoutLocation_areaInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
    encounter_method?: EncounterMethodUpdateOneRequiredWithoutLocation_area_encounter_ratesNestedInput
    version?: VersionUpdateOneRequiredWithoutEncounterRatesNestedInput
  }

  export type LocationAreaEncounterRateUncheckedUpdateWithoutLocation_areaInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounter_method_id?: IntFieldUpdateOperationsInput | number
    version_id?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
  }

  export type LocationAreaEncounterRateUncheckedUpdateManyWithoutLocation_areaInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounter_method_id?: IntFieldUpdateOperationsInput | number
    version_id?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterSlotCreateManyMethodInput = {
    id: number
    version_group_id: number
    slot: number
    rarity: number
  }

  export type LocationAreaEncounterRateCreateManyEncounter_methodInput = {
    id: number
    location_area_id: number
    version_id: number
    rate: number
  }

  export type EncounterSlotUpdateWithoutMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    slot?: IntFieldUpdateOperationsInput | number
    rarity?: IntFieldUpdateOperationsInput | number
    version_group?: VersionGroupUpdateOneRequiredWithoutSlotsNestedInput
    encounters?: EncounterUpdateManyWithoutSlotNestedInput
  }

  export type EncounterSlotUncheckedUpdateWithoutMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
    slot?: IntFieldUpdateOperationsInput | number
    rarity?: IntFieldUpdateOperationsInput | number
    encounters?: EncounterUncheckedUpdateManyWithoutSlotNestedInput
  }

  export type EncounterSlotUncheckedUpdateManyWithoutMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
    slot?: IntFieldUpdateOperationsInput | number
    rarity?: IntFieldUpdateOperationsInput | number
  }

  export type LocationAreaEncounterRateUpdateWithoutEncounter_methodInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
    location_area?: LocationAreaUpdateOneRequiredWithoutEncounterRatesNestedInput
    version?: VersionUpdateOneRequiredWithoutEncounterRatesNestedInput
  }

  export type LocationAreaEncounterRateUncheckedUpdateWithoutEncounter_methodInput = {
    id?: IntFieldUpdateOperationsInput | number
    location_area_id?: IntFieldUpdateOperationsInput | number
    version_id?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
  }

  export type LocationAreaEncounterRateUncheckedUpdateManyWithoutEncounter_methodInput = {
    id?: IntFieldUpdateOperationsInput | number
    location_area_id?: IntFieldUpdateOperationsInput | number
    version_id?: IntFieldUpdateOperationsInput | number
    rate?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterCreateManySlotInput = {
    id: number
    version_id: number
    pokemon_id: number
    location_area_id: number
    min_level: number
    max_level: number
  }

  export type EncounterUpdateWithoutSlotInput = {
    id?: IntFieldUpdateOperationsInput | number
    min_level?: IntFieldUpdateOperationsInput | number
    max_level?: IntFieldUpdateOperationsInput | number
    version?: VersionUpdateOneRequiredWithoutEncountersNestedInput
    pokemon?: PokemonUpdateOneRequiredWithoutEncountersNestedInput
    location_area?: LocationAreaUpdateOneRequiredWithoutEncountersNestedInput
    conditions?: EncounterConditionValueMapUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateWithoutSlotInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    location_area_id?: IntFieldUpdateOperationsInput | number
    min_level?: IntFieldUpdateOperationsInput | number
    max_level?: IntFieldUpdateOperationsInput | number
    conditions?: EncounterConditionValueMapUncheckedUpdateManyWithoutEncounterNestedInput
  }

  export type EncounterUncheckedUpdateManyWithoutSlotInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    location_area_id?: IntFieldUpdateOperationsInput | number
    min_level?: IntFieldUpdateOperationsInput | number
    max_level?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterConditionValueMapCreateManyEncounterInput = {
    id: number
    encounter_condition_value_id: number
  }

  export type EncounterConditionValueMapUpdateWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: EncounterConditionValueUpdateOneRequiredWithoutMapsNestedInput
  }

  export type EncounterConditionValueMapUncheckedUpdateWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounter_condition_value_id?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterConditionValueMapUncheckedUpdateManyWithoutEncounterInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounter_condition_value_id?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterConditionValueCreateManyConditionInput = {
    id: number
    name: string
    is_default: boolean
  }

  export type EncounterConditionValueUpdateWithoutConditionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    maps?: EncounterConditionValueMapUpdateManyWithoutValueNestedInput
  }

  export type EncounterConditionValueUncheckedUpdateWithoutConditionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
    maps?: EncounterConditionValueMapUncheckedUpdateManyWithoutValueNestedInput
  }

  export type EncounterConditionValueUncheckedUpdateManyWithoutConditionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    is_default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EncounterConditionValueMapCreateManyValueInput = {
    id: number
    encounter_id: number
  }

  export type EncounterConditionValueMapUpdateWithoutValueInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounter?: EncounterUpdateOneRequiredWithoutConditionsNestedInput
  }

  export type EncounterConditionValueMapUncheckedUpdateWithoutValueInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounter_id?: IntFieldUpdateOperationsInput | number
  }

  export type EncounterConditionValueMapUncheckedUpdateManyWithoutValueInput = {
    id?: IntFieldUpdateOperationsInput | number
    encounter_id?: IntFieldUpdateOperationsInput | number
  }

  export type MoveCreateManyDamage_classInput = {
    id: number
    name: string
    generation_id: number
    type_id: number
    pp: number
    accuracy?: number | null
    priority: number
    move_effect_id: number
  }

  export type MoveUpdateWithoutDamage_classInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    accuracy?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    type?: TypeUpdateOneRequiredWithoutMoveNestedInput
    effect?: MoveEffectUpdateOneRequiredWithoutMovesNestedInput
    pokemon_moves?: PokemonMoveUpdateManyWithoutMoveNestedInput
  }

  export type MoveUncheckedUpdateWithoutDamage_classInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    accuracy?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    move_effect_id?: IntFieldUpdateOperationsInput | number
    pokemon_moves?: PokemonMoveUncheckedUpdateManyWithoutMoveNestedInput
  }

  export type MoveUncheckedUpdateManyWithoutDamage_classInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    accuracy?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    move_effect_id?: IntFieldUpdateOperationsInput | number
  }

  export type MoveCreateManyEffectInput = {
    id: number
    name: string
    generation_id: number
    type_id: number
    pp: number
    accuracy?: number | null
    priority: number
    move_damage_class_id: number
  }

  export type MoveUpdateWithoutEffectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    accuracy?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    type?: TypeUpdateOneRequiredWithoutMoveNestedInput
    damage_class?: MoveDamageClassUpdateOneRequiredWithoutMovesNestedInput
    pokemon_moves?: PokemonMoveUpdateManyWithoutMoveNestedInput
  }

  export type MoveUncheckedUpdateWithoutEffectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    accuracy?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    move_damage_class_id?: IntFieldUpdateOperationsInput | number
    pokemon_moves?: PokemonMoveUncheckedUpdateManyWithoutMoveNestedInput
  }

  export type MoveUncheckedUpdateManyWithoutEffectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    generation_id?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    pp?: IntFieldUpdateOperationsInput | number
    accuracy?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: IntFieldUpdateOperationsInput | number
    move_damage_class_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonMoveCreateManyMethodInput = {
    id: number
    version_group_id: number
    move_id: number
    pokemon_id: number
    level: number
  }

  export type PokemonMoveUpdateWithoutMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    version_group?: VersionGroupUpdateOneRequiredWithoutMovesNestedInput
    move?: MoveUpdateOneRequiredWithoutPokemon_movesNestedInput
    pokemon?: PokemonUpdateOneRequiredWithoutMoveNestedInput
  }

  export type PokemonMoveUncheckedUpdateWithoutMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
    move_id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonMoveUncheckedUpdateManyWithoutMethodInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
    move_id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonMoveCreateManyMoveInput = {
    id: number
    version_group_id: number
    move_method_id: number
    pokemon_id: number
    level: number
  }

  export type PokemonMoveUpdateWithoutMoveInput = {
    id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    version_group?: VersionGroupUpdateOneRequiredWithoutMovesNestedInput
    method?: MoveMethodUpdateOneRequiredWithoutMovesNestedInput
    pokemon?: PokemonUpdateOneRequiredWithoutMoveNestedInput
  }

  export type PokemonMoveUncheckedUpdateWithoutMoveInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
    move_method_id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonMoveUncheckedUpdateManyWithoutMoveInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
    move_method_id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
  }

  export type PokedexVersionGroupCreateManyPokedexInput = {
    id: number
    version_group_id: number
  }

  export type PokemonDexNumberCreateManyPokedexInput = {
    id: number
    pokemon_id: number
    pokedex_number: number
  }

  export type PokedexVersionGroupUpdateWithoutPokedexInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group?: VersionGroupUpdateOneRequiredWithoutPokedex_version_groupsNestedInput
  }

  export type PokedexVersionGroupUncheckedUpdateWithoutPokedexInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokedexVersionGroupUncheckedUpdateManyWithoutPokedexInput = {
    id?: IntFieldUpdateOperationsInput | number
    version_group_id?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonDexNumberUpdateWithoutPokedexInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokedex_number?: IntFieldUpdateOperationsInput | number
    pokemon?: PokemonUpdateOneRequiredWithoutDex_numbersNestedInput
  }

  export type PokemonDexNumberUncheckedUpdateWithoutPokedexInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    pokedex_number?: IntFieldUpdateOperationsInput | number
  }

  export type PokemonDexNumberUncheckedUpdateManyWithoutPokedexInput = {
    id?: IntFieldUpdateOperationsInput | number
    pokemon_id?: IntFieldUpdateOperationsInput | number
    pokedex_number?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}